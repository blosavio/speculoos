2024Mar08 change (fn-var) to use (demunge (.getName (.getClass f))) for cleaner code, more robust beahvior

2024Feb28: rename
    (wrap-fn) to (instrument)
	(unwrap-fn) to (unstrument)
	(test-fn-with) to (validate-fn-with)

2024Feb29: write (arg-vs-ret-spec-validate) function to compare the args to the returns

2024Mar01: write branching logic for (validate-fn-with) and (wrapping-fn) that validates a function's scalar return with a bare predicate (i.e., not a collection)

2024Feb27: write (clamp) function that restricts eval of lazy sequences in either the data or the spec (but not both)

test sequences, lazy-sequences, infinite lazy sequences
2024Feb23: Regarding bare sequences, things get goofy. You can't merely create a de novo sequence, you can only coerce one by calling (sequence) or (seq) on a collection literal. The resulting sequence is not its own type, but a derivation of that original collection. 
	(type (sequence [11 22 33])) ; clojure.lang.PersistentVector$ChunkedSeq
	(type (sequence {:a 11 :b 22})) ; clojure.lang.PersistentArrayMap$Seq
	(type (sequence '(11 22 33))) ; clojure.lang.PersistentList
	(type (sequence #{11 22 33})) ; clojure.lang.APersistentMap$KeySeq
	Running (first) on a sequence derived from a map returns a MapElement.
	Running (first) on a sequence derived from a set returns some un-defined 'first' element. (i.e., once it's been sequence-ized, you can't address a set element by it's value, only its un-predicatable (nth)-able sequence index). Once a collection has been sequence-ized, we can't tell what it was originally, because every seq and every sequence returns true for both (sequential?) and (seqable?).

2024Feb25: upgraded (get*), (get-in*), (assoc*), (assoc-in*), (update*), (update-in*), (dissoc*), (dissoc-in*) to consume (possibly) non-terminating sequences including
    clojure.lang.{Cycle,Iterate,LazySeq,LongRange,Range,Repeat}

2024Feb26: You must tread lightly at the REPL, or something you do may trigger evaluation. However, if you send a function a non-terminating sequence and immediately bind it (e.g., (def)) or send it off to another function, and don't do anything lame, like try to (println) it, it may work...
	One strategy for working with infinite sequences is to have a policy to always wrap them with a (take 99 __), which doesn't usually blow up the stack unless the sequence contents are themselves really large.

2024Feb28: Adapted the various (validate-*) and (valid?*) functions to consume non-terminating sequences. (Strategy is to 'clamp' them at the length of their counterpart.)

2024Mar01: In (validate-fn-with) and (instrument), wrap (apply f args) in a (try (catch...)) block so that improper invocation is a little helpful.

2024Mar08: add clojore.lang.Symbol to type+predicate+canonical+generator registry

2024Mar12: use numeric coercion functions plus type.check generators to fill out type+predicate+canonical+generator registry
    add hex and binary types
    re-order registry so that they're in some kind of semantic/lexographical  order
	ensure full/exhaustive test coverage of all types

2024Mar09: switch (only-valids) to catch not-false and not-nil, and
	(only-valids) to catch false or nil
	 so that predicate application for regex et al that return a non-true nontheless truthy value, will validate

2024Mar10: added set-as-a-predicate feature to scalar specs

2024Mar12: upgrade higher-order function validation to handle arbitrary depth and bare (i.e., non-coll) return values

2024Apr15: generalize (only-valid), (only-invalid), etc to filter both scalar validation results and collection validation results
*earmuffs* on namespace-wide constants (esp., clamp depths)

adjust (validate-scalar-spec) to seemlessly accept non-coll val and predicate, return something normalized like [{:path nil :value val :predicate pred :valid? bool :bare-val-pred true}]
	Since an empty path [] is minimal valid path for a true container, {:path nil} is a good sentinel for a bare value/predicate.
	This would obviate much logic spread around in other functions, particularly in the function-spec namespace, where every function does it's own special handling of bare values.

2024Apr24: add (utility/in?) as a replacement for what clojure.core/contains? appears to be
    (defn in? [coll item] (boolean (some #(= item %) coll)))

2024Mar14: add generator for set-as-a-predicate

2024Apr27: check collection specs for false-or-nil; update to simple clojure.core/not


2024May10: move ordinal accessor helper functions from core to utility namespace; migrate tests

2024May12: rename get-assoc-update-dissoc namespace to something like fn-in

2024May13: change :refer :all to :refer :only [] for more specificity

2024May16: Refactor function-specification utilities to consolidate common code paths: validate-fn-with, validate-fn-meta-spec, wrapping-fn.

2024May22: Adjust data-from-spec to search for a random sample generator within a predicate function's metadata
	
2024May23: create utility to find predicates in a scalar specification that do not provide a random sample generator

2024May23: create utility to verify that a random sample generator produces a value that satisfies its predicate

create a collection-without-predicate utility to report collections in data that lack a predicate within a collection specification

check UUIDv4 for all functions and relevant data

2024May18: list trade-offs, limitations, and intentionally rejected features (i.e., "to-don't")

license and copyright statements

check terminology consistency: specification/spec, datums, etc
check for proper elispses, em-dashes
check for passive voice

add inline code comment elucidations where helpful

2024May30: change seq-regex operators from symbols to keywords
	'* '+ '. '?
	:* :+ :. :?

for data-from-spec, add optional :random-truncate to shorten sequences, remove key-vals, and/or set members

Fix grammer and puctuation of public todo
