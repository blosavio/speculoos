<!DOCTYPE html>
<html lang="en"><head><link href="tufte.css" rel="stylesheet" type="text/css"><link href="speculoos.css" rel="stylesheet" type="text/css"><title>Speculoos --- 3 Ideas</title><meta charset="utf-8" compile-date="2024-07-25 19:22:42" content="width=device-width, initial-scale=1" name="viewport"><body><nav id="nav-bar"><ul><li><a href="home.html">Home</a></li><li>Ideas</li><li><a href="documentation.html">Documentation</a></li><li><a href="recipes.html">Recipes</a></li><li><a href="diff.html"><code>diff</code></a></li><li><a href="pros_cons.html">Pros, Cons, &amp; Alts</a></li><li class="small-caps"><a href="index.html">api</a></li><li><a href="source.html">Source</a></li><li><a href="contact.html">Contact</a></li></ul></nav><article><section><h1>Speculoos Ideas</h1><p>Speculoos aims to do what <code>clojure.spec.alpha</code> does, for the same <a href="https://clojure.org/about/spec">reasons</a>, but with its own twist.</p><p>So what does <a href="https://clojure.org/guides/spec"><code>spec.alpha</code></a> do? Briefly, it provides a system to describe Clojure data, validate data, and thoroughly test function input and output.<label class="margin-toggle sidenote-number" for="side-by-side"></label><input class="margin-toggle" id="side-by-side" type="checkbox"><span class="sidenote">See <a href="diff.html"><code>diff</code></a> for a side-by-side comparison.</span></input> What does that look like? First, we'll start with some regular old Clojure data.</p><pre><code>(def person-1
  {:name "Nathaniel Bumppo",
   :phone "314-1592",
   :address {:street-number 1789,
             :street-name "Fenimore Avenue"},
   :occupation "deer veterinarian",
   :favorite-ice-cream-flavor :butter-pecan})</code></pre><p>Writing a Speculoos specification involves creating a regular old Clojure data structure that mimics the data: replace every datum with a predicate.</p><pre><code>(def person-spec
  {:name string?,
   :phone #(and string? (re-matches #"\d{3}-\d{4}" %)),
   :address {:street-number int?,
             :street-name string?,
             :apt-number int?},
   :occupation string?,
   :favorite-ice-cream-flavor keyword?})</code></pre><p>Now, we merely send both to Speculoos.</p><pre><code>(require '[speculoos.core :refer
           [valid-scalars? only-invalid validate-scalars]])</code><br><code>(valid-scalars? person-1 person-spec) ;; => true</code></pre><p>Let's create some invalid data.</p><pre><code>(def person-2
  {:name "Lucy Ricardo",
   :phone "Klondike5-6553",
   :address {:street-number 623,
             :street-name "East 68th Street",
             :apt-number 4},
   :occupation "candy assembly line operator",
   :favorite-ice-cream-flavor :vita-meata-vegemin})</code><br><code>(valid-scalars? person-2 person-spec) ;; => false</code></pre><p>And when we delve a little deeper</p><pre><code>(only-invalid (validate-scalars person-2 person-spec))
;; => ({:datum "Klondike5-6553",
;;      :path [:phone],
;;      :predicate #function [ideas/fn--23261],
;;      :valid? nil})</code></pre><p>we can see that the phone number in <code>person-2</code> is not valid.<label class="margin-toggle sidenote-number" for="invalid-phone"></label><input class="margin-toggle" id="invalid-phone" type="checkbox"><span class="sidenote">Perhaps in this case, though, our phone number specification doesn&apos;t properly cover all the possible formats in the wild.</span></input></p><p>Speculoos checks sequences with the same concept.</p><pre><code>(def vegetables
  [:bundle "carrots" :crown "broccoli" :stalks "celery"])</code></pre><p>A Speculoos specification is a plain Clojure data structure that mimics the data: predicates replace the datums.</p><pre><code>(def vegetable-spec
  [keyword? string? keyword? string? keyword? string?])</code></pre><p>We check our veggies in the same way.</p><pre><code>(valid-scalars? vegetables vegetable-spec) ;; => true</code></pre><p>And some invalid data.</p><pre><code>(def rotten-vegetables [:basket :onions])</code></pre><p>Speculoos tells us what's wrong.</p><pre><code>(only-invalid (validate-scalars rotten-vegetables
                                vegetable-spec))
;; => ({:datum :onions,
;;      :path [1],
;;      :predicate #function [clojure.core/string?--5475],
;;      :valid? false})</code></pre><p>Speculoos has a similar story for testing functions. Speculoos function specifications live in the function's metadata.</p><pre><code>(defn transmogrifier
  {:speculoos/arg-scalar-spec [string? string?],
   :speculoos/ret-scalar-spec string?}
  [x y]
  (str x " is a " y))</code></pre><p>Speculoos can instrument a function in the same way as <code>spec.alpha</code>, but I often prefer to do it like this.</p><pre><code>(require '[speculoos.function-specs :refer
           [validate-fn-meta-spec exercise-fn]])</code><br><code>(validate-fn-meta-spec transmogrifier "Hobbes" "tiger")
;; => "Hobbes is a tiger"</code><br><code>(validate-fn-meta-spec transmogrifier
                       "Hobbes"
                       :stuffed-tiger)
;; => ({:datum :stuffed-tiger,
;;      :fn-spec-type :speculoos/argument,
;;      :path [1],
;;      :predicate #function [clojure.core/string?--5475],
;;      :valid? false})</code></pre><p>If we want to exercise our function, Speculoos can.</p><pre><code>(exercise-fn transmogrifier 5)
;; => ([["jP6v29" "2O25Ex998c8v37P057a"]
;;      "jP6v29 is a 2O25Ex998c8v37P057a"]
;;     [["QI0OmH1" "4b1c7c3Y71K7"] "QI0OmH1 is a 4b1c7c3Y71K7"]
;;     [["71Ht19n" "H81u05vxoHwv17"]
;;      "71Ht19n is a H81u05vxoHwv17"]
;;     [["SB364XmyBClF" "5tOu5bEYEMcYKW3e"]
;;      "SB364XmyBClF is a 5tOu5bEYEMcYKW3e"]
;;     [["077pSSKgh5xYNsg9e55" "dz39Bkj"]
;;      "077pSSKgh5xYNsg9e55 is a dz39Bkj"])</code></pre><p>So while doing similar tasks as <code>spec.alpha</code>, we can see that Speculoos does things a bit differently.</p><p>Speculoos explores three ideas. First, creating specifications with standard Clojure data structures is intuitive and powerful without sacrificing any necessary features. Second, and related to the first, Clojure's extensive data structure manipulation functions, augmented with a handful of <code>get-in</code> style functions, will allow Clojurists to inspect, manipulate, and delete any data and/or specification to accomplish their task. Third, specifying data collections ought to be conceptually and practically distinct from specifying the scalar values they contain.</p><p>Let's examine each of those ideas in turn.</p></section><section><h2>Literal specifications</h2><p>Speculoos validation functions consume run-of-the-mill Clojure data structures. To specify a vector, you write vector. To specify a map, you write a map. Same for lists, same for sets. Speculoos specifications can be composed and modified with any function in <code>clojure.core</code>, a <a href="https://github.com/plumatic/plumbing">pre</a>-<a href="https://github.com/redplanetlabs/specter">existing</a> <a href="https://github.com/weavejester/medley">library</a>, or any pet tool you created that makes sense to the way your brain thinks.</p><p>This carries enormous benefits. First, writing Speculoos specifications is natural and intuitive. Simply make your specification look like your data.</p><pre><code>(valid-scalars? [99 "abc" :foo \c false 'sym 22/7]
                [int? string? keyword? char? boolean?
                 symbol? ratio?])
;; => true</code></pre><p>Speculoos handles heterogenous, arbitrarily-nested data structures of all of Clojure's data collection types.</p><pre><code>(def data-1
  {:a 72, :b ["xyz" :baz], :c {:d (list \z true)}})</code><br><code>(def spec-1
  {:a int?,
   :b [string? keyword?],
   :c {:d (list char? boolean?)}})</code><br><code>(valid-scalars? data-1 spec-1) ;; => true</code></pre><p>There is a very nearly one-to-one correspondence between your data and a Speculoos specification.</p><p>Since specifications are pure Clojure data structures, any function that operates on a Clojure data structure will work, such as old reliable <code>clojure.core/assoc</code>.</p><pre><code>(valid-scalars? {:x 33, :y 44} (assoc {:y int?} :x int?))
;; => true</code></pre><p>Composing a specification with <code>concat</code> is like a set of well-worn flannel pyjamas.</p><pre><code>(def spec-from-ten-years-ago [#(> % 5) #(not= % 3)])</code><br><code>(def spec-from-the-wire [#(= % "hello") #(even? %)])</code><br><code>(valid-scalars? [6 2 ["hello" 4]]
                (concat spec-from-ten-years-ago
                        spec-from-the-wire))
;; => true</code></pre><p>What if your little software machine works at the middle of a long pipeline, and the pipeline hands you some data and a specification, but your little machine's needs aren't as strict as the specification? Speculoos can relax the specification on-the-fly with standard <code>core</code> functions, because the specification is just a map.</p><pre><code>(def overly-strict-spec
  {:a float?,
   :b #(and (string? %) (< 10 (count %)))})</code><br><code>(valid-scalars? {:a 5.5, :b "baz"}
                (assoc overly-strict-spec :b string?))
;; => true</code></pre><p>Your little machine does its job, and then sends off the processed data and the original specifciation.</p><p>I propose that any other way of composing data specifications could, at most, only <em>match</em> it in power, but never exceed it. And to merely match it would require replicating all of Clojure plus all external libraries, everywhere. It's almost cheating to have the entirety of Clojure and its ecosystem to write specifications. People won't have to learn a new grammar or <span class="small-caps">dsl</span>. Clojurists are already adept at diving into a data structure, pulling it apart, manipulating values, and putting them back together. It's difficult to imagine a method superior to writing specifications with pure Clojure data literals.</p><p>Speculoos' second core idea closely relates to the first, but I wanted to separate them so that if the second idea is a dud, it wouldn't sink both.</p></section><section><h2>Augemented functions for manipulating nested data structures</h2><p>I mentioned earlier Clojure's extensive core library for handling data structures. <code>get-in</code>, <code>assoc-in</code>, <code>update-in</code>, <code>dissoc</code> are among my favorites. However, they have some limitations that block them from serving in all the scenarios I wanted. I envisioned a set of functions that presented a consistent, familiar interface to inspect, change, and remove elements in vectors, maps, lists, and sets, at any arbitrary level of nesting.</p><p>To that end, I wrote <em>starred</em> versions: <code>get-in*</code>, <code>assoc-in*</code>, <code>update-in*</code>, <code>dissoc-in*</code> which all operate similar to their <code>clojure.core</code> namesakes, but work on any heterogenous, arbitrarily-nested data structure. Their unified interface pivots on the concept of a <em>path</em>, a vector of elements that unambiguously addresses a single datum in a heterogenous, arbitrarily-nested data structure. Elements in vectors and lists are referenced by zero-based integers, map elements are addressed by their keys<label class="margin-toggle sidenote-number" for="tread-carefully"></label><input class="margin-toggle" id="tread-carefully" type="checkbox"><span class="sidenote">Which are often keywords, but could be integers or any composite value, so tread carefully.</span></input>, and set elements are addressed by the elements themselves. This family of functions makes a useful toolbox to compose and adjust Speculoos specification literals.</p><p>Let's take a look at what the starred functions can do. First, an example heterogenous, arbitrarily-nested data structure.</p><pre><code>(def crazy-data
  [11 22 {:a 33, :b [44 55], :c [66 [77 {:d [88]}]]} 99
   [[[111]] (list 222)] #{333 [444]}])</code></pre><p>Inspecting a nested value,</p><pre><code>(require '[speculoos.fn-in :refer
           [get-in* assoc-in* update-in* dissoc-in*]])</code><br><code>(get-in* crazy-data [2 :c 1 1 :d 0]) ;; => 88</code></pre><p>Associating a nested value,</p><pre><code>(assoc-in* crazy-data [4 1 2] 999)
;; => [11 22 {:a 33, :b [44 55], :c [66 [77 {:d [88]}]]} 99
;;     [[[111]] (222 nil 999)] #{333 [444]}]</code></pre><p>Updating a nested value,</p><pre><code>(update-in* crazy-data [5 [444] 0] #(+ 444 %))
;; => [11 22 {:a 33, :b [44 55], :c [66 [77 {:d [88]}]]} 99
;;     [[[111]] (222)] #{333 [888]}]</code></pre><p>Dissociating a nested value.</p><pre><code>(dissoc-in* crazy-data [2 :b 0])
;; => [11 22 {:a 33, :b [55], :c [66 [77 {:d [88]}]]} 99
;;     [[[111]] (222)] #{333 [444]}]</code></pre><p>Note how the starred functions are able to dive into any of the collection types to do their jobs. Such capabilities are invaluable to straightforwardly manipulating Speculoos specification literals, or adjusting invalid/non-conforming data. In fact, the Speculoos implementation makes liberal use of each of these starred functions to perform the mechanics of validation. Beyond that, they also enable many of the Speculoos utility functions, such as generating sample data from a specification and data repair.</p><p>One of <code>spec.alpha</code>'s headline features that Speculoos does not attempt to replicate is returning conformed values. This part of the Speculoos experiment tests if having the family of starred functions alleviates some of the need of conformed returns.</p></section><section><h2>Separating scalar specification and collection specification</h2><p>You may have been uncomfortably shifting in your chair while reading through the Speculoos examples above. Every example we've seen so far shows Speculoos validating individual scalars, such as integers, strings, booleans, etc.</p><pre><code>(valid-scalars? [false "qwz" -88] [false? string? neg-int?])
;; => true</code></pre><p>However, you might need to specify some property of a collection itself, such as a vector's length, the presence of a key in a map, relationships <em>between</em> datums, etc.</p><p>Speculoos' third idea is that specification of scalars and specification of collections should be explicitly separate. You perhaps noticed that the function name wasn't <code>valid?</code> but instead <code>valid-scalars?</code>. Speculoos provides a parallel group of functions to validate the properties of collections, independent of the scalar values they contain.</p><pre><code>(def scalars-not-important
  [33 {:Q 77, :W [:granite :marble :basalt]}])</code><br><code>(def spec-for-collections
  [#(= 2 (count %))
   {:W [vector? #(every? (complement coll?) %)],
    :all-keywords-capitals?
      (fn [m]
        (every? #(re-matches #"^[A-Z]$" (name %))
                (keys m)))}])</code><br><code>(require '[speculoos.core :refer
           [valid-collections? valid?]])</code><br><code>(valid-collections? scalars-not-important
                    spec-for-collections)
;; => true</code></pre><p>To show how strongly I believe this idea, I reserved a very precious resource — the shortest, most mnemonic function name, <code>valid?</code> — for simultanesouly, but separately, checking a scalar specification and a collection specification.</p><pre><code>(valid? [11 "abc" :foo \c]
        [int? string? keyword? char?]
        [vector? #(< (count %) 5)])
;; => true</code></pre><p>Having to write two specifications for each data structure does increase work, but I think the benefits are worth it. It is much simpler conceptually, requiring only a few memorable rules for either task. Merging scalar and collection specification requires a grammar that somehow describes the bottom-level values immediately adjacent to describing the containers that contain those values. Cramming all those characters into one spot makes for a visually noisy specification. At every moment, you have to mentally keep track of what kind of thing you are specifying, scalar or collection. And, I hope you can appreciate the downstream benefits that the implementation code is much simpler.</p><p>In practice, you don't have to write two specifications if you don't need both. Specify only as much as you want; Speculoos validates only what you provide. If you want to specify some subset of your scalar values, Speculoos is happy to check only those.</p><p>Here, we only care about the second and fourth scalars, and completely ignore saying anything about the collection.<label class="margin-toggle sidenote-number" for="implied"></label><input class="margin-toggle" id="implied" type="checkbox"><span class="sidenote">Although this particular scalar specification appears to imply a vector of four elements, Speculoos&apos; scalar validation does not enforce that. Collection validation could check the count if we weren&apos;t leaving it empty for the puproses of this example.</span></input></p><pre><code>(valid? [11 "abc" :foo \c]
        [any? string? (constantly true) char?]
        [])
;; => true</code></pre><p>If you don't care about the values themselves but only want to specify properties of the collection, Speculoos will check those properties of the collections and ignore the datums.</p><pre><code>(valid? {:a [11 22], :b [33 44], :c [55 66]}
        {}
        {:b [vector? #(= 2 (count %))]})
;; => true</code></pre><p>Speculoos is <em>à la carte</em> as much as possible.</p></section></article><p id="page-footer">Copyright © 2024 Brad Losavio.<br>Compiled 2024 July 25.<span id="uuid"><br>27fd9200-3869-488b-9604-1f88ee84c053</span></p></body></head></html>