<!DOCTYPE html>
<html lang="en"><head><link href="tufte.css" rel="stylesheet" type="text/css"><link href="speculoos.css" rel="stylesheet" type="text/css"><title>Speculoos — Home</title><meta charset="utf-8" compile-date="2024-07-24 09:05:18" content="width=device-width, initial-scale=1" name="viewport"><body><nav id="nav-bar"><ul><li>Home</li><li><a href="ideas.html">Ideas</a></li><li><a href="documentation.html">Documentation</a></li><li><a href="recipes.html">Recipes</a></li><li><a href="diff.html"><code>diff</code></a></li><li><a href="pros_cons.html">Pros, Cons, &amp; Alts</a></li><li class="small-caps"><a href="index.html">api</a></li><li><a href="source.html">Source</a></li><li><a href="contact.html">Contact</a></li></ul></nav><article><h1>Speculoos</h1><p class="subtitle">An experiment in Clojure specification literals</p><section><p>I thought it might be nice if I could <a href="https://clojure.org/guides/spec">specify</a> some <a href="https://clojure.org/">Clojure</a> data like this</p><pre><code>(valid? [42 "abc" \z] [int? string? char?]) ;; => true</code></pre><p>That idea blossomed into Speculoos, an experiment in specifying data. It felt natural to compose a specification by its shape, so Speculoos can also do maps</p><pre><code>(valid? {:a 22/7, :b true, :c nil}
        {:a ratio?, :b boolean?, :c nil?})
;; => true</code></pre><p>or any other <em>heterogeneous, arbitrarily-nested Clojure data structure</em>. And when a datum doesn't conform</p><pre><code>(only-invalid (validate-scalars [:foo 1.23 (list 0 4)]
                                [keyword? float?
                                 (list zero? odd?)]))
;; => ({:datum 4,
;;      :path [2 1],
;;      :predicate #function [clojure.core/odd?],
;;      :valid? false})</code></pre><p>Speculoos returns why and where with a path that can be used to inspect, manipulate, or delete invalid datums with <code>get-in</code> style tools. Speculoos can <code>update</code> that invalid <code>4</code> at path <code>[2 1]</code> by diving into the data structure and incrementing it to an odd integer.</p><pre><code>(valid? (update-in* [:foo 1.23 (list 0 4)] [2 1] inc)
        [keyword? float? (list zero? odd?)])
;; => true</code></pre><p>Speculoos avoids new syntax by separately specifying the scalars (i.e., integers, strings, booleans, etc.) and the Clojure collections that contain those scalars (i.e., vectors, maps, sets, and lists). Speculoos distinguishes a <em>scalar specification</em> (seen in the previous examples), and a <em>collection specification</em></p><pre><code>(valid-collections? [11 :foo 22 \z]
                    [vector? #(= 4 (count %))])
;; => true</code></pre><p>which only concerns properties of the collection itself.</p><p>Speculoos explores <a href="ideas.html">three ideas</a>.<ol><li>Is shape-based data specification merely a gimmick, or is it powerful enough to do what <code>clojure.spec.alpha</code> does? </li><li>Is <code>get-in</code> addressing sufficient to inspect, manipulate, add, and delete Clojure data and specifications?</li><li>Does separately specifying scalars and collections strike a good balance between mental clarity and requiring extra work?</li></ol><p>I think the answer to all three questions is <em>Yes</em>. Speculoos is an experiment to see just how far I could push those ideas. I arbitrarily set a goal of performing the same tasks as <code>clojure.spec.alpha</code>. In my hands, Speculoos can do a flimsy version of most of those tasks. In the hands of someone experienced, a better implementation of these ideas might go even further.</p><p><a href="contact.html">Let me know</a> what you think.</p></p></section></article><p id="page-footer">Copyright © 2024 Brad Losavio.<br>Compiled 2024 July 24.<span id="uuid"><br>8bb02c87-c3bf-4f58-bb76-269040d3e8c4</span></p></body></head></html>