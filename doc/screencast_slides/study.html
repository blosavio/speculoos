<!DOCTYPE html>
<html lang="en"><head><link href="screedcast.css" rel="stylesheet" type="text/css"><script src="jquery-3.7.1.min.js" type="text/javascript"></script><script src="screedcast.js" type="text/javascript"></script><title>Speculoos — An experimental Clojure data validation library</title><meta charset="utf-8" compile-date="2024-12-02 15:48:38" content="width=device-width, initial-scale=1" name="viewport"><body><div class="panel"><div class="panel-header"></div><h1>Speculoos Screencast 17 — Case study</h1><h3><em>Specifying and validating Speculoos' changelog</em></h3><div class="note"><p>What it's like to use <a href="https://github.com/blosavio/speculoos">Speculoos</a> on a task that's not merely a demonstration? Specify and validate the Speculoos library <a href="https://github.com/blosavio/speculoos/tree/main/resources/changelog_entries/changelog.edn"><code>changelog.edn</code></a>. To begin, a few words about the changelog itself.</p></div><div class="panel-footer"><span class="panel-number">1/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>An <em>experimental</em> changelog</h3><ul><li>Human- and machine-readable</li><li>Query-able</li><li>Generate formatted representations</li></ul><div class="note"><p>Speculoos is an experimental library. Among the ideas I wanted to explore is a changelog published in Clojure <strong>e</strong>xtensible <strong>d</strong>ata <strong>n</strong>otation (<a href="https://github.com/edn-format/edn">edn</a>). The goal is to have a single, canonical, human- and machine-readable document that describes the project's changes from one version to the next. That way, it would be straightforward to automatically generate a nicely-formatted changelog webpage and query the changelog data so that people can make informed decisions about changing versions.</p></div><div class="panel-footer"><span class="panel-number">2/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Concept: <em>Version</em></h3><ul><li>Version number</li><li>Date</li><li>Person responsible, with contact info</li><li>Status of the project (i.e., stable, deprecated, etc.)</li><li>Urgency (i.e., high for a security fix, etc.)</li><li>Flag if changes are breaking from previous version</li><li>Free-form comments</li></ul><div class="note"><p>Here's the info that I think would be useful for a changelog entry.</p></div><div class="panel-footer"><span class="panel-number">3/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Example <em>version</em> entry</h3><pre><code>{:version 99
 :date {:year 2025
        :month "November"
        :day 12}
 :responsible {:name "Kermit Frog"
               :email "its.not.easy@being.gre.en"}
 :project-status :stable
 :urgency :low
 :breaking? false
 :comment "Improved arithmetic capabilities."
 :changes [«see upcoming discussion»]}</code></pre><p>Each version may have multiple <em>changes</em>.</p><div class="note"><p>We can quickly assemble an example.</p></div><div class="panel-footer"><span class="panel-number">4/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Concept: <em>Change</em></h3><ul><li>A free-form, textual description of the change.</li><li>A reference, (e.g., GitHub issue number, JIRA ticket number, etc.)</li><li>Kind of change (i.e., bug fix, renamed function, removed function, improved performance, etc.)</li><li>Flag indicating if this particular change is breaking.</li><li>Added, renamed, moved, altered, or deleted functions.</li></ul><div class="note"><p>Furthermore, for each of those changelog entries, I think it would be nice to tell people more details about the individual changes so they can make technically supported decisions about changing versions. A single, published version could consist of multiple changes, associated to a key <code>:changes</code>, with each change detailed with this info.</p></div><div class="panel-footer"><span class="panel-number">5/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Example <em>change</em> entry</h3><pre><code>{:description "Addition function `+` now handles floating point decimal number types."
 :reference {:source "Issue #78"
             :url "https://example.com/issue/87"}
 :change-type :relaxed-input-requirements
 :breaking? false
 :altered-functions ['+]
 :date {:year 2025
        :month "November"
        :day 8}
 :responsible {:name "Fozzie Bear"
               :email "fozzie@wocka-industries.com"}}</code></pre><div class="note"><p>Here's an example of one change included in a published version.</p><p>The date and person responsible for an individual change need not be the same as the date and person responsible for the version that contains it. So while Kermit was responsible for publishing the overall version on 2025 November 12, Fozzie was responsible for creating the individual change to the plus function on 2025 November 08.</p></div><div class="panel-footer"><span class="panel-number">6/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>★ Three Mottos</h3><ol class="side-by-side-by-side-container"><div class="side-by-side-by-side"><li>Validate scalars separately from validating collections.</li><div class="vspace"></div><p>scalars:<br><code>&emsp;&emsp;42, "abc", \c, 22/7, :kw, 'foo, true, nil</code></p><div class="vspace"></div><p>collections:<br><code>&emsp;&emsp;[…], {…}, (…), #{…}</code></p><div class="note"><p>Distinct functions for validating scalars and collections in HANDS. Advantages:<ol><li>Simpler. No mini-language that mixes identities and quantities. Specs Cloj data structures w/functions. Manipulate specs w/anything, e.g. <code>assoc-in</code> No macros.</li><li>Mental clarity. Validation only applies to scalar, or to collection, never both. Predicate doesn't have to know anything about the quantity or location of the element.</li><li>Only specify as much, or as little, as necessary. If only a few scalars, won't be forced to specify a property concerning a collection.</li></ol></p></div></div><div class="side-by-side-by-side"><li>Shape the specification to mimic the data.</li><div>data</div><div>↓</div><pre><code>{:x 42   :y "abc"  }</code><br><code>{:x int? :y string?}</code></pre><div>↑</div><div>specification</div><div class="note"><p>Composing specs straightforward; mimic shape of data. Arrangement of nested vectors, lists, maps, sequences, and sets that contain predicates. Pattern instruct the validation functions where to apply the predicates. Spec for a vector is a vector. Spec for a map, is a map. ~1-to-1 correspondence b/t shape of data and shape of specific. Strategy: copy-paste data, delete contents,  use as a template, replace elements with predicates. Peek at by eye — merely eval them at <span class="small-caps">repl</span> — easy alteration: any Clojure data wrangling functions to tighten, relax, or remove portions of spec. <code>assoc-in</code>, <code>update-in</code>, & <code>dissoc</code>.</p></div></div><div class="side-by-side-by-side"><li>Ignore un-paired predicates and un-paired datums.</li><div>data</div><div>↓</div><pre><code>{:x 42   <s>:y "abc"</s>}</code><br><code>{:x int? <s>:q double?</s>}</code></pre><div>↑</div><div>specification</div><div class="note"><p>Ignoring -> Flexibility, power, optionality, and re-usability. Ex #1: pipeline. Supplying predicates for subset of datums only validates those specified datums while being agnostic towards the other datums. Ex #2 Sprawling specification that describes a myriad of data about a person, postal address,  contact info, etc. B/c a spec just  data structure with regular predicates, can, on-the-fly, <code>get-in</code> portion relevant to postal addresses and apply that to our particular instances of address data. Specify exactly what elements we'd like to validate. No more, no less.</p></div></div></ol><div class="note"><p>Three Mottos speaker notes</p><div><p>Efficiently using Speculoos requires remembering three mottos.</p><ol><li>Validate scalars separately from validating collections.</li><li>Shape the specification to mimic the data.</li><li>Ignore un-paired predicates and un-paired datums.</li></ol><p> Motto #2 reminds us to shape the specification so that it mimics the data. This motto reveals a convenient tactic: copy-paste the data, delete the scalars, and insert predicates.</p><p>Motto #3 reminds us to ignore un-paired predicates and un-paired datums. In practice, the consequence of this principle is that we may provide more data than we specify, and the un-specified data merely flows through, un-validated. On the other hand, we may specify more elements than actually exist in a particular piece of data. That's okay, too. Those un-paired predicates will be ignored.</p></div></div><div class="panel-footer"><span class="panel-number">7/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Strategy: Build from small pieces</h3><ol><li>Specify & validate scalars</li><li>Specify & validate collections</li><li>'Combo' validate</li></ol><div class="note"><p>Our overall strategy is this: Build up specifications from small pieces, testing those small pieces along the way. Then, after we we're confident in the small pieces, we can assemble them at the end. We'll start with specifying and validating the scalars. Once we've done that, we'll put them aside. Then, we'll specify and validate the collections, testing them until we're confident we've got the correct specifications. At the end, we'll bring together both scalar validation and collection validation into a combo validation.</p><p>Scalars and collections are separate concepts, so we handle them in different steps. At the end, merely for convenience, we can use a combo validation that separately validates the scalars and the collections with a single invocation.</p></div><div class="panel-footer"><span class="panel-number">8/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Develpoment environment setup</h3><pre><code>(require '[speculoos.core :refer [valid-scalars? valid-collections? valid?]]
         '[fn-in.core :refer [get-in*]])</code></pre><div class="vspace"></div><pre><code class="form">(set! *print-length* 99)</code><br><code class="eval">;; => 99</code></pre><p>Code and fictitious data at <a href="">https://github.com/blosavio/speculoos</a></p><div class="note"><p>Let's set up our environment with the tools we'll need.</p></div><div class="panel-footer"><span class="panel-number">9/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Specifying scalars: Year</h3><pre><code>(defn year-predicate [n] (and (int? n) (<= 2000 n)))</code></pre><div class="vspace"></div><div class="side-by-side-container"><div class="side-by-side"><pre><code class="form">(year-predicate 2025)</code><br><code class="eval">;; => true</code></pre></div><div class="side-by-side"><pre><code class="form">(year-predicate "2077")</code><br><code class="eval">;; => false</code></pre></div></div><div class="note"><p>We'll start simple. Let's compose a <em>date</em> specification. Informally, a date is a year, a month, and a day. Let's stipulate that a valid year is <em>An integer greater-than-or-equal-to two-thousand</em>. Here's a predicate for that concept.</p><p>Speculoos predicates are merely Clojure functions. Let's try it.</p><p>That looks good. Integer <code>2025</code> is greater than two-thousand, while string <code>"2077"</code> is not an integer.</p></div><div class="panel-footer"><span class="panel-number">10/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Specifying scalars: Day</h3><pre><code>(defn day-predicate [n] (and (int? n) (<= 1 n 31)))</code></pre><div class="note"><p>Checking day of the month is similar.</p><p><code>day-predicate</code> is satisfied only by an integer between one and thirty-one, inclusive.</p></div><div class="panel-footer"><span class="panel-number">11/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Specifying scalars: Month</h3><div class="no-display">#'screedcast-generator/month-predicate</div><div class="side-by-side-container"><div class="side-by-side"><pre><code>(def month-predicate #{"January"
                       "February"
                       "March"
                       "April"
                       "May"
                       "June"
                       "July"
                       "August"
                       "September"
                       "October"
                       "November"
                       "December"})</code></pre></div><div class="side-by-side"><pre><code class="form">(month-predicate "August")</code><br><code class="eval">;; => "August"</code></pre><div class="vspace"></div><pre><code class="form">(month-predicate :November)</code><br><code class="eval">;; => nil</code></pre></div></div><div class="note"><p>Speculoos can validate a scalar by testing if it's a member of a set. A valid month may only be one of twelve elements. Let's enumerate the months of the year, months represented as strings.</p><p>Let's see how that works.</p><p><code>month-predicate</code> is satisfied (i.e., returns a truthy value) because string <code>"August"</code> is a member of the set.</p><p>Keyword <code>:November</code> does not satisfy <code>month-predicate</code> because it is not a member of the set. <code>month-predicate</code> returns a falsey value, <code>nil</code>.</p></div><div class="panel-footer"><span class="panel-number">12/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Specifying scalars: Composing a <em>date</em> specification</h3><pre><code>{:year 2020 :month "January" :day 1}</code></pre><div class="vspace"></div><pre><code>{:year ____ :month _________ :day __}</code></pre><div class="vspace"></div><pre><code>(def date-spec
  {:year year-predicate, :month month-predicate, :day day-predicate})</code></pre><div class="note"><p>We've now got predicates to check a year, a month, and day. The notion of <em>date</em> includes a year, month, and a day traveling around together. We can collect them into one group using a Clojure collection. A hash-map works well in this scenario.</p><p>Speculoos specifications are plain old regular Clojure data collections. <a href="https://github.com/blosavio/speculoos?tab=readme-ov-file#-three-mottos">Motto #2</a> reminds us to shape the specification to mimic the data. To create a scalar specification, we could copy-paste the data, and delete the scalars…and insert our predicates.</p></div><div class="panel-footer"><span class="panel-number">13/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Check <em>date</em> scalar specification: Correct data</h3><pre><code class="form">(valid-scalars? {:year 2024, :month "January", :day 1}
                {:year year-predicate, :month month-predicate, :day day-predicate})</code><br><code class="eval">;; => true</code></pre><div class="note"><p>Let's check our progress against some valid data. We're validating scalars (Motto #1), so we'll use a function with a <code>-scalars</code> suffix. The data is the first argument on the upper row, the specification is the second argument on the lower row.</p><p>Each of the three scalars satisfies their respective predicates (Motto #3), so <code>valid-scalars?</code> returns <code>true</code>.</p></div><div class="panel-footer"><span class="panel-number">14/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Check<em>date</em> scalar specification: Incorrect data</h3><pre><code class="form">(valid-scalars? {:year 2024, :month "Wednesday", :day 1}
                {:year year-predicate, :month month-predicate, :day day-predicate})</code><br><code class="eval">;; => false</code></pre><div class="note"><p>Now let's feed in some invalid data.</p><p>While <code>"Wednesday"</code> is indeed a string, it is not a member of the <code>month-predicate</code> set, so <code>valid-scalars?</code> returns <code>false</code>.</p></div><div class="panel-footer"><span class="panel-number">15/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Specifying scalars: A <em>person</em></h3><ul><li>name</li><li>email</li></ul><div class="note"><p>Now that we can validate the date component of the changelog, we'll need to specify and validate the information about the person responsible for that publication. The changelog information about a person gathers their name, a free-form string, and an email address, also a string. In addition to being a string, a valid email address:</p><ul><li>Starts with one or more alphanumeric characters or periods,</li><li>Followed by exactly one <code>@</code> character,</li><li>Followed by one or more alphanumeric characters or periods.</li></ul></div><div class="panel-footer"><span class="panel-number">16/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Specifying scalars: A person's email</h3><pre><code>(def person-spec {:name string?, :email #"^[\w\.]+@[\w\.]+"})</code></pre><div class="note"><p>Regular expressions are powerful tools for testing those kind of string properties, and Speculoos scalar validation supports them. A regular expression appearing in a scalar specification is considered a predicate. Let's make the following a specification about a changelog person.</p></div><div class="panel-footer"><span class="panel-number">17/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Testing <em>person</em> scalar specification #1</h3><pre><code class="form">(valid-scalars? {:name "Abraham Lincoln", :email "four.score.seven.years@gettysburg.org"}
                {:name string?, :email #"^[\w\.]+@[\w\.]+"})</code><br><code class="eval">;; => true</code></pre><div class="note"><p>Let's give that specification a whirl. First, we validate some valid person data (data in upper row, specification in lower row).</p><p>Both name and email scalars satisfied their paired predicates. </p></div><div class="panel-footer"><span class="panel-number">18/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Testing <em>person</em>scalar specification #2</h3><pre><code class="form">(valid-scalars? {:name "George Washington", :email "crossing_at_potomac"}
                {:name string?, :email #"^[\w\.]+@[\w\.]+"})</code><br><code class="eval">;; => false</code></pre><div class="note"><p>Now, let's see what happens when we validate some data that is invalid.</p><p>Oops. That email address does not satisfy the regular expression because it does not contain an <code>@</code> character, so the person data is invalid.</p></div><div class="panel-footer"><span class="panel-number">19/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Specifying scalars: version number</h3><pre><code>(defn version-predicate [i] (and (int? i) (<= 0 i)))</code></pre><div class="vspace"></div><div class="side-by-side-container"><div class="side-by-side"><pre><code class="form">(version-predicate 99)</code><br><code class="eval">;; => true</code></pre></div><div class="side-by-side"><pre><code class="form">(version-predicate -1)</code><br><code class="eval">;; => false</code></pre></div></div><div class="note"><p>Perhaps the most pivotal single datum in a changelog entry is the version number. For our discussion, let's stipulate that a version is an integer greater-than-or-equal-to zero. Here's a predicate for that.</p><p>And a pair of quick demos.</p></div><div class="panel-footer"><span class="panel-number">20/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Specifying scalars: Assemble existing parts</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code>{:version version-predicate
 :date date-spec
 :person person-spec}</code></pre></div><div class="side-by-side"><pre><code>{:version 99
 :date {:year 2025
        :month "August"
        :day 1}
 :person {:name "Abraham Lincoln"
          :email "four.score.seven.years@gettysburg.org"}}</code></pre></div></div><div class="note"><p>At this point, let's assemble what we have. Speculoos specifications are merely Clojure collections that mimic the shape of the data. So let's collect those predicates into a map.</p><p>Notice, <code>date-spec</code> and <code>person-spec</code> are each themselves specifications. We compose a Speculoos specification using standard Clojure composition.</p><p>The partial changelog entry might look something like this.</p></div><div class="panel-footer"><span class="panel-number">21/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Quick check: scalar validation #1</h3><pre><code class="form">(valid-scalars?
  {:version 99,
   :date {:year 2025, :month "August", :day 1},
   :person {:name "Abraham Lincoln",
            :email "four.score.seven.years@gettysburg.org"}}
  {:version version-predicate, :date date-spec, :person person-spec})</code><br><code class="eval">;; => true</code></pre><div class="note"><p>Let's check our work so far. First, we'll validate some data we know is valid.</p></div><div class="panel-footer"><span class="panel-number">22/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Quick check: scalar validation #2</h3><pre><code class="form">(valid-scalars?
  {:version 1234,
   :date {:year 2055, :month "Octoberfest", :day 1},
   :person {:name "Paul Bunyan", :email "babe@blue.ox"}}
  {:version version-predicate, :date date-spec, :person person-spec})</code><br><code class="eval">;; => false</code></pre><div class="note"><p>Second, we'll feed in some data we suspect is invalid.</p><p>Hmm. <em>Something</em> doesn't satisfy their predicate, but my eyesight isn't great and I can't immediately spot the problem. Let's use a more verbose function, <code>validate-scalars</code>, which returns detailed results.</p></div><div class="panel-footer"><span class="panel-number">23/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Quick check: scalar validation #3, verbose</h3><pre><code class="form">(validate-scalars
  {:version 1234,
   :date {:year 2055, :month "Octoberfest", :day 1},
   :person {:name "Paul Bunyan", :email "babe@blue.ox"}}
  {:version version-predicate, :date date-spec, :person person-spec})</code><br><code class="eval">;; => [{:datum "Octoberfest",
;;      :path [:date :month],
;;      :predicate #{"April" "August"
;;                   "December" "February"
;;                   "January" "July" "June"
;;                   "March" "May" "November"
;;                   "October" "September"},
;;      :valid? nil}
;;     {:datum 1234,
;;      :path [:version],
;;      :predicate version-predicate,
;;      :valid? true}
;;     {:datum 2055,
;;      :path [:date :year],
;;      :predicate year-predicate,
;;      :valid? true}
;;     {:datum 1,
;;      :path [:date :day],
;;      :predicate day-predicate,
;;      :valid? true}
;;     {:datum "Paul Bunyan",
;;      :path [:person :name],
;;      :predicate string?,
;;      :valid? true}
;;     {:datum "babe@blue.ox",
;;      :path [:person :email],
;;      :predicate #"^[\w\.]+@[\w\.]+",
;;      :valid? "babe@blue.ox"}]</code></pre><div class="note"><p>Ugh, too verbose. Let's pull in a utility that filters the validation results so only the invalid results are displayed.</p></div><div class="panel-footer"><span class="panel-number">24/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Quick check: scalar validation #4, just right verbosity</h3><pre><code>(require '[speculoos.core :refer [only-invalid]])</code></pre><pre><code class="form">(only-invalid
  (validate-scalars
    {:version 1234,
     :date {:year 2055, :month "Octoberfest", :day 1},
     :person {:name "Paul Bunyan", :email "babe@blue.ox"}}
    {:version version-predicate, :date date-spec, :person person-spec}))</code><br><code class="eval">;; => ({:datum "Octoberfest",
;;      :path [:date :month],
;;      :predicate #{"April" "August"
;;                   "December" "February"
;;                   "January" "July" "June"
;;                   "March" "May" "November"
;;                   "October" "September"},
;;      :valid? nil})</code></pre><div class="note"><p>Now we can focus.</p><p>Aha. One scalar datum failed to satisfy the predicate it was paired with. <code>"Octoberfest"</code> is not a month enumerated by our month predicate.</p></div><div class="panel-footer"><span class="panel-number">25/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Specifying scalars: breakage</h3><pre><code>(defn breaking-predicate [b] (or (nil? b) (boolean? b)))</code></pre><div class="note"><p>So far, our changelog entry has a version number, a date, and a person. In the introduction, we outlined that a changelog entry would contain more info than that. So let's expand it.</p><p>It would be nice to tell people whether that release was breaking relative to the previous version. The initial release doesn't have a previous version, so it's breakage will be <code>nil</code>. For all subsequent versions, breakage will carry a <code>true</code> or <code>false</code> notion, so we'll require that datum be a boolean or <code>nil</code>.</p></div><div class="panel-footer"><span class="panel-number">26/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Specifying scalars: project status</h3><pre><code>(def status-predicate #{:experimental :active :stable :inactive :deprecated})</code></pre><div class="note"><p>Also, it would be nice if we indicate the status of the project upon that release. A <a href="https://github.com/metosin/open-source/blob/main/project-status.md">reasonable enumeration of a project's status</a> might be <em>experimental</em>, <em>active</em>, <em>stable</em>, <em>inactive</em>, or <em>deprecated</em>. Since a valid status may only be one of a handful of values, a set makes a good membership predicate.</p></div><div class="panel-footer"><span class="panel-number">27/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Quick check: scalar validation #5</h3><pre><code>{:version version-predicate
 :breaking? breaking-predicate
 :project-status status-predicate}</code></pre><div class="vspace"></div><pre><code class="form">(valid-scalars? {:version 99, :breaking? false, :project-status :stable}
                {:version version-predicate, :breaking? breaking-predicate, :project-status status-predicate})</code><br><code class="eval">;; => true</code></pre><div class="note"><p>Let's assemble the version predicate, the breaking predicate, and the status predicate into another partial, temporary specification.</p><p>Now that we have another temporary, partial specification, let's use it to validate (data in the upper row, specification in the lower row).</p></div><div class="panel-footer"><span class="panel-number">28/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Quick check: scalar validation #6</h3><pre><code class="form">(valid-scalars? {:version 123, :breaking? true, :project-status "finished!"}
                {:version version-predicate, :breaking? breaking-predicate, :project-status status-predicate})</code><br><code class="eval">;; => false</code></pre><div class="vspace"></div><pre><code class="form">(only-invalid (validate-scalars
                {:version 123, :breaking? true, :project-status :finished!}
                {:version version-predicate, :breaking? breaking-predicate, :project-status status-predicate}))</code><br><code class="eval">;; => ({:datum :finished!,
;;      :path [:project-status],
;;      :predicate #{:active :deprecated :experimental :inactive :stable},
;;      :valid? nil})</code></pre><div class="note"><p>Now, let's validate some invalid data.</p><p>Perhaps we're curious about exactly which datum failed to satisfy its predicate. So we switch to <code>validate-scalars</code> and filter with <code>only-invalid</code>.</p><p>Yup. Scalar <code>:finished!</code> is not enumerated by <code>status-predicate</code>.</p></div><div class="panel-footer"><span class="panel-number">29/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Scalar specification: upgrade urgency & comments</h3><pre><code>{:version version-predicate
 :date date-spec
 :responsible person-spec
 :project-status status-predicate
 :breaking? breaking-predicate
 :urgency #{:low :medium :high}
 :comment string?}</code></pre><div class="note"><p>A comment concerning a version is a free-form string, so we can use a bare <code>string?</code> predicate. Upgrade urgency could be represented by three discrete levels, so a set <code>#{:low :medium :high}</code> makes a fine predicate.</p><p>Now that we've got all the individual components for validating the version number, date (with year, month, day), person responsible (with name and email), project status, breakage, urgency, and a comment, we can assemble the specification for one changelog entry.</p></div><div class="panel-footer"><span class="panel-number">30/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Example <em>version</em> data</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code>{:version ___
 :date {:year ___
        :month ___
        :day ___}
 :responsible {:name ___
               :email___}
 :project-status ___
 :breaking? ___
 :urgency ___
 :comment ___}</code></pre></div><div class="side-by-side"><pre><code>{:version 55
 :date {:year 2025
        :month "December"
        :day 31}
 :responsible {:name "Rowlf"
               :email "piano@example.org"}
 :project-status :active
 :breaking? false
 :urgency :medium
 :comment "Performance improvements and bug fixes."}</code></pre></div></div><div class="note"><p>Let's use that specification to validate some data. Here's a peek behind the curtain: At this very moment, I don't have sample data to show you. I need to write some. I'm going to take advantage of the fact that a Speculoos specification is a regular Clojure data structure whose shape mimics the data. I already have the specification in hand. I'm going to copy-paste the specification, delete the predicates, and then insert some scalars.</p><p>Here's the specification with the predicates deleted.</p><p>That will serve as a template. Then I'll insert some scalars.</p></div><div class="panel-footer"><span class="panel-number">31/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating scalars of valid <em>version</em> data</h3><pre><pre><code class="form">(valid-scalars? {:version 55,
                 :date {:year 2025, :month "December", :day 31},
                 :responsible {:name "Rowlf Dog", :email "piano@example.org"},
                 :project-status :active,
                 :breaking? false,
                 :urgency :medium,
                 :comment "Performance improvements and bug fixes."}
                {:version version-predicate,
                 :date date-spec,
                 :responsible person-spec,
                 :project-status status-predicate,
                 :breaking? breaking-predicate,
                 :urgency #{:low :medium :high},
                 :comment string?})</code><br><code class="eval">;; => true</code></pre></pre><div class="note"><p>Let's run a validation with that data and specification.</p><p>Since I wrote the data based on the specification, it's a good thing the data is valid.</p></div><div class="panel-footer"><span class="panel-number">32/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating scalars of <strong>invalid</strong> version data</h3><pre><pre><code class="form">(only-invalid (validate-scalars
                {:version "foo-bar-baz",
                 :date {:year 2025, :month "December", :day 31},
                 :responsible {:name "Rowlf Dog", :email "piano@example.org"},
                 :project-status :active,
                 :breaking? false,
                 :urgency :medium,
                 :comment "Performance improvements and bug fixes.",
                 :changes []}
                {:version version-predicate,
                 :date date-spec,
                 :responsible person-spec,
                 :project-status status-predicate,
                 :breaking? breaking-predicate,
                 :urgency #{:low :medium :high},
                 :comment string?}))</code><br><code class="eval">;; => ({:datum "foo-bar-baz",
;;      :path [:version],
;;      :predicate version-predicate,
;;      :valid? false})</code></pre></pre><div class="note"><p>Let me change the version to a string, validate with the verbose <code>validate-scalars</code> and filter the output with <code>only-invalid</code> to keep only the invalid scalar+predicate pairs.</p><p>Yup. String <code>"foo-bar-baz"</code> is not a valid version number according to <code>version-predicate</code>. If I had made a typo while writing that changelog entry, before it got any further, validation would have informed me that I needed to correct that version number.</p><p>In the introduction, we mentioned that each version entry could contain a sequence of maps detailing the specific changes. That sequence is associated to <code>:changes</code>. Maybe you noticed I snuck that into the data in the last example. We haven't yet written any predicates for that key-val, so <code>validate-scalars</code> ignored it (Motto #3). We won't ignore it any longer.</p></div><div class="panel-footer"><span class="panel-number">33/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Reviewing the <em>changes</em> concept</h3><pre><code>{:description "Addition function `+` now handles floating point decimal number types."
 :reference {:source "Issue #78"
             :url "https://example.com/issue/87"}
 :change-type :relaxed-input-requirements
 :breaking? false
 :altered-functions ['+]
 :date {:year 2025
        :month "November"
        :day 8}
 :responsible {:name "Fozzie Bear"
               :email "fozzie@wocka-industries.com"}}</code></pre><div class="note"><p>The nesting depth is going to get messy, so let's put aside the version entry and zoom in on what a change entry might look like. Way back at the beginning, of this case study, we introduced this example.</p><p>This 'change' entry provides details about who changed what, when, and a reference to an issue-tracker. A single version may bundle multiple of these change entries.</p></div><div class="panel-footer"><span class="panel-number">34/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Specifying scalars of a <em>change</em></h3><pre><code>{:description ___
 :reference {:source ___
             :url ___}
 :change-type ___
 :breaking? ___
 :altered-functions []
 :date {:year ___
        :month ___
        :day ___}
 :responsible {:name ___
               :email ___}}</code></pre><div class="note"><p>I'll copy-paste the sample and delete the scalars.</p><p>That'll be a good template for a change entry specification.</p></div><div class="panel-footer"><span class="panel-number">35/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Specifying scalars of a <em>change</em>: re-using predicates</h3><pre><code>{:description string?
 :reference {:source ___
             :url ___}
 :change-type ___
 :breaking? breaking-predicate
 :altered-functions []
 :date date-spec
 :responsible person-spec}</code></pre><div class="note"><p>We can start filling in the blanks because we already have specifications for <em>date</em>, <em>person</em>, and <em>breaking</em>. Similarly, a description is merely free-form text which can be validated with a simple <code>string?</code> predicate.</p></div><div class="panel-footer"><span class="panel-number">36/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Specifing scalars of a change's <em>reference</em></h3><table><tr><td>source<div class="vspace"></div></td><td><code>string?</code><div class="vspace"></div></td></tr><tr><td>url</td><td><pre><code class="form">(re-find #"^https:\/{2}[\w\/\.]*"
         "https://example.com")</code><br><code class="eval">;; => "https://example.com"</code></pre><div class="vspace"></div><pre><code class="form">(re-find #"^https:\/{2}[\w\/\.]*"
         "ht://example.com")</code><br><code class="eval">;; => nil</code></pre><div class="vspace"></div></td></tr><tr><td>ticket</td><td><pre><code>(defn ticket-predicate [t] (or (string? t) (uuid? t)))</code></pre></td></tr></table><div class="note"><p>Now we can tackle the remaining blanks. The <em>reference</em> associates this change to a issue-tracker. The <code>:source</code> is a free-form string (i.e., "GitHub Issue #27", etc.), while <code>:url</code> points to a web-accessible resource. Let's require that a valid entry be a string that starts with "https://". We can demonstrate that regex.</p><p>The first example returns a match (truthy), while the second example is a malformed url and fails to find a match (falsey).</p><p>Different issue trackers have different ways of referring to issues, so to accommodate that, we can include an optional <code>:ticket</code> entry that can be a free-form string or a <span class="small-caps">uuid</span>.</p></div><div class="panel-footer"><span class="panel-number">37/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Assembling the scalar specification for a <em>reference</em> sub-component</h3><pre><pre><code>(def reference-spec
  {:source string?, :url #"^https:\/{2}[\w\/\.]*", :ticket ticket-predicate})</code></pre></pre><div class="note"><p>Let's assemble those predicates to define this sub-component.</p></div><div class="panel-footer"><span class="panel-number">38/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Assembling the scalar specification for a <em>change</em></h3><pre><code>{:description string?
 :reference reference-spec
 :change-type ___
 :breaking? breaking-predicate
 :altered-functions []
 :date date-spec
 :responsible person-spec}</code></pre><div class="note"><p>Slowly and steadily filling in the blanks, our change specification currently looks like this.</p><p>Let's take a look at the first remaining blank. <em>Change type</em> may be one of an enumerated set of values. That term <em>set</em> is a clue to writing the predicate. </p></div><div class="panel-footer"><span class="panel-number">39/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Specifying <em>change types</em></h3><div class="no-display">#'screedcast-generator/change-kinds-ordered#'screedcast-generator/change-kinds#'screedcast-generator/change-kinds-str</div><pre>(def
  change-kinds
  #{:initial-release
    :security
    :performance-improvement
    :performance-regression
    :memory-improvement
    :memory-regression
    :network-resource-improvement
    :network-resource-regression
    :added-dependency
    :removed-dependency
    :dependency-version
    :added-functions
    :renamed-functions
    :moved-functions
    :removed-functions
    :altered-functions
    :function-arguments
    :relaxed-input-requirements
    :stricter-input-requirements
    :increased-return
    :decreased-return
    :altered-return
    :defaults
    :implementation
    :source-formatting
    :error-message
    :tests
    :bug-fix
    :deprecated-something
    :policy
    :meta-data
    :documentation
    :website
    :release-note
    :other})</pre><div class="note"><p>We ought to use a set as a membership predicate if we can enumerate all possible valid values. I've jotted down the common cases I can think of.</p><p>Maybe this a good idea for validating changelog data, maybe it's not. But it's an experiment either way.</p></div><div class="panel-footer"><span class="panel-number">40/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><div class="panel-footer"><span class="panel-number">41/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Specifying scalars: zero-or-more symbols</h3><div class="side-by-side-container"><div class="side-by-side"><p><em>change</em> specification, so far…</p><pre><code>{:description string?
 :reference reference-spec
 :change-type change-kinds
 :breaking? breaking-predicate
 <strong>:altered-functions [___]</strong>
 :date date-spec
 :responsible person-spec}</code></pre></div><div class="side-by-side"><p>specifying an unknown quantity of scalars</p><pre><code>;; data           scalar specification</code><br><code>['foo          ] [symbol?                ]</code><br><code>['foo 'bar     ] [symbol? symbol?        ]</code><br><code>['foo 'bar 'baz] [symbol? symbol? symbol?]</code><br><br><code>     ⋮              ⋮</code><br><br><code>['foo 'bar 'baz 'zab 'oof…] (repeat symbol?)</code></pre></div></div><div class="note"><p>On to that second blank. An <em>altered function</em> is a collection of symbols that inform the reader of the changelog the precise names of functions that were altered during that particular change. There may be zero or more, so a <a href="https://github.com/blosavio/speculoos?tab=readme-ov-file#non-terminating-sequences">non-terminating repeat</a> of predicates is an elegant tool to specify that concept.</p><p>Because Speculoos ignores un-paired predicates, the non-terminating sequence of <code>symbol?</code> predicates conveys the notion of <em>zero or more symbols</em>.</p></div><div class="panel-footer"><span class="panel-number">42/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Completed <em>change</em> scalar specification</h3><pre><code>(def change-scalar-spec
  {:date date-spec,
   :description string?,
   :reference reference-spec,
   :change-type change-kinds,
   :breaking? breaking-predicate,
   :altered-functions (repeat symbol?)})</code></pre><div class="note"><p>Now we've created all the predicates for the parts of a change entry. When assembled into a scalar specification, it looks like this.</p><p>Remember, any single changelog version may contain zero or more of that shape of changelog data. To remind ourselves what that looks like...</p></div><div class="panel-footer"><span class="panel-number">43/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Naming the <em>version</em> scalar specification</h3><pre><code>(def version-scalar-spec
  {:date date-spec,
   :responsible person-spec,
   :version version-predicate,
   :comment string?,
   :project-status status-predicate,
   :stable boolean?,
   :urgency #{:low :medium :high},
   :breaking? boolean?,
   :changes (repeat change-scalar-spec)})</code></pre><pre><code>;;           ^--- zero-or-more 'change' specifications</code></pre><div class="note"><p>...let's bind that version specification from before to a name.</p><p>Let's stuff an infinite number of <code>change-scalar-spec</code>s into the <code>:changes</code> slot of <code>version-scalar-spec</code>.</p><p>Now, this one, single <code>version-scalar-spec</code> could potentially validate an arbitrary number of changes. Each of those changes can announce alterations to an arbitrary number of functions.</p></div><div class="panel-footer"><span class="panel-number">44/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>How many versions could a changelog contain?</h3><pre><code>[version-scalar-spec]</code><br><code>[version-scalar-spec version-scalar-spec]</code><br><code>[version-scalar-spec version-scalar-spec version-scalar-spec]</code><br><code>         ⋮                    ⋮                   ⋮</code></pre><div class="vspace"></div><pre><code>(def changelog-scalar-spec (repeat version-scalar-spec))</code></pre><div class="note"><p>If we recall from the beginning, a changelog is an ever-growing sequence of versions. Upon the initial release, we have one version, which we could validate with this specification.</p><p>After a while, we make some upgrades, and release a second version. The changelog has a version entry appended the sequence. The two-element changelog can be validated with this specification.</p><p>Oops. We found a bug, and need to make a third version. The changelog describing the new version now has three entries, validated with this specification.</p><p>Hmm. We can't know ahead of time how many versions we'll have, and it would be nice if we didn't have to keep manually updating the sequence each time we need to add to the changelog. Speculoos specifications are merely standard Clojure collections. <code>clojure.core/repeat</code> provides a convenient way to express <em>an infinite number of things</em>.</p><p>Fun! A <code>clojure.lang/repeat</code> nested in a <code>clojure.lang/repeat</code>. Speculoos can handle that without a sweating. As long as there's not a repeat at the same path in the data. And there isn't. The changelog is hand-written, with each entry unique.</p></div><div class="panel-footer"><span class="panel-number">45/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating (fictitious) changelog data</h3><div class="no-display">#'screedcast-generator/changelog-data</div><pre><code class="form">(only-invalid (validate-scalars changelog-data
                                changelog-scalar-spec))</code><br><code class="eval">;; => ({:datum "okay!",
;;      :path [1 :project-status],
;;      :predicate #{:active :deprecated :experimental
;;                   :inactive :stable},
;;      :valid? nil}
;;     {:datum nil,
;;      :path [2 :date :month],
;;      :predicate #{"April" "August" "December" "February"
;;                   "January" "July" "June" "March" "May"
;;                   "November" "October" "September"},
;;      :valid? nil}
;;     {:datum :removed-function,
;;      :path [2 :changes 2 :change-type],
;;      :predicate
;;        #{:added-dependency :added-functions
;;          :altered-functions :altered-return :bug-fix
;;          :decreased-return :defaults :dependency-version
;;          :deprecated-something :documentation
;;          :error-message :function-arguments
;;          :implementation :increased-return
;;          :initial-release :memory-improvement
;;          :memory-regression :meta-data :moved-functions
;;          :network-resource-improvement
;;          :network-resource-regression :other
;;          :performance-improvement :performance-regression
;;          :policy :relaxed-input-requirements :release-note
;;          :removed-dependency :removed-functions
;;          :renamed-functions :security :source-formatting
;;          :stricter-input-requirements :tests :website},
;;      :valid? nil}
;;     {:datum "me_at_example.com",
;;      :path [0 :responsible :email],
;;      :predicate #"^[\w\.]+@[\w\.]+",
;;      :valid? nil}
;;     {:datum 32,
;;      :path [2 :changes 0 :date :day],
;;      :predicate day-predicate,
;;      :valid? false})</code></pre><div class="note"><p>So, I don't see any reason we shouldn't validate a changelog. This is Speculoos' actual <a href="https://github.com/blosavio/speculoos/tree/main/resources/changelog_entries/changelog.edn">operational changelog</a>. While writing the first draft of this case study, I validated it and corrected the errors (see the case study <a href="#conclusion">conclusion</a>). Therefore, validating the real changelog doesn't have any interesting errors to look at.</p><p>For our walk-through, I've cooked up a somewhat <a href="https://github.com/blosavio/speculoos/tree/main/resources/case_study/edited_changelog.edn">fictitious changelog</a> to try out our scalar specification. I trimmed the Speculoos library changelog and added a few deliberate invalid scalars. We'll invoke <code>validate-scalars</code> with the changelog data in the upper row, and the scalar specification in the lower row.</p><p><code>validate-scalars</code> returns a sequence of validation results, and <code>only-invalid</code> filters the sequence to keep only the results where the scalar did not satisfy the predicate it was paired with. We can see that there are six invalid scalars, each with its own map that details the problem.</p><ul><li>String <code>"okay?"</code> is not a valid <em>project status</em> because it is not a member of the set <code>#{:active :deprecated :experimental :inactive :stable}</code>.</li><li><code>nil</code> is not a valid month because it is not a member of the enumerated months.</li><li><code>:removed-function</code> (note the lack of a trailing 's') is not a valid <em>change type</em> because it is not a member of the enumerated possibilities.</li><li><code>me_at_example.com</code> is not a valid <em>email</em> because it does not satisfy the regular expression predicate.</li><li><code>32</code> is an invalid <em>day</em> because it is greater than <code>31</code> and therefore fails to satisfy <code>day-predicate</code>.</li><li><code>:smash-data</code> is not a valid <em>removed function</em> datum because the specification requires it to be a symbol.</li></ul><p>While this demonstration used slightly fictitious data, it is representative of the actual problems I discovered when I validated the real changelog.</p></div><div class="panel-footer"><span class="panel-number">46/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><div class="panel-footer"><span class="panel-number">47/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>★ Three Mottos</h3><ol class="side-by-side-by-side-container"><div class="side-by-side-by-side"><li>Validate scalars separately from validating collections.</li><div class="vspace"></div><p>scalars:<br><code>&emsp;&emsp;42, "abc", \c, 22/7, :kw, 'foo, true, nil</code></p><div class="vspace"></div><p>collections:<br><code>&emsp;&emsp;[…], {…}, (…), #{…}</code></p><div class="note"><p>Distinct functions for validating scalars and collections in HANDS. Advantages:<ol><li>Simpler. No mini-language that mixes identities and quantities. Specs Cloj data structures w/functions. Manipulate specs w/anything, e.g. <code>assoc-in</code> No macros.</li><li>Mental clarity. Validation only applies to scalar, or to collection, never both. Predicate doesn't have to know anything about the quantity or location of the element.</li><li>Only specify as much, or as little, as necessary. If only a few scalars, won't be forced to specify a property concerning a collection.</li></ol></p></div></div><div class="side-by-side-by-side"><li>Shape the specification to mimic the data.</li><div>data</div><div>↓</div><pre><code>{:x 42   :y "abc"  }</code><br><code>{:x int? :y string?}</code></pre><div>↑</div><div>specification</div><div class="note"><p>Composing specs straightforward; mimic shape of data. Arrangement of nested vectors, lists, maps, sequences, and sets that contain predicates. Pattern instruct the validation functions where to apply the predicates. Spec for a vector is a vector. Spec for a map, is a map. ~1-to-1 correspondence b/t shape of data and shape of specific. Strategy: copy-paste data, delete contents,  use as a template, replace elements with predicates. Peek at by eye — merely eval them at <span class="small-caps">repl</span> — easy alteration: any Clojure data wrangling functions to tighten, relax, or remove portions of spec. <code>assoc-in</code>, <code>update-in</code>, & <code>dissoc</code>.</p></div></div><div class="side-by-side-by-side"><li>Ignore un-paired predicates and un-paired datums.</li><div>data</div><div>↓</div><pre><code>{:x 42   <s>:y "abc"</s>}</code><br><code>{:x int? <s>:q double?</s>}</code></pre><div>↑</div><div>specification</div><div class="note"><p>Ignoring -> Flexibility, power, optionality, and re-usability. Ex #1: pipeline. Supplying predicates for subset of datums only validates those specified datums while being agnostic towards the other datums. Ex #2 Sprawling specification that describes a myriad of data about a person, postal address,  contact info, etc. B/c a spec just  data structure with regular predicates, can, on-the-fly, <code>get-in</code> portion relevant to postal addresses and apply that to our particular instances of address data. Specify exactly what elements we'd like to validate. No more, no less.</p></div></div></ol><div class="note"><p>Three Mottos speaker notes</p></div><div class="panel-footer"><span class="panel-number">48/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Specifying & validating collections</h3><ol><li>Required keys.</li><li>Relationship between version numbers.</li></ol><div class="note"><p><a href="https://github.com/blosavio/speculoos#mottos">Motto #1</a> for using Speculoos is to separate scalar validation from collection validation. Scalar validation concerns the properties of individual datums, such as <em>Is the day thirty-one or less?</em> or <em>Is the email a string with an @ symbol?</em></p><p>Collection validation concerns itself with properties of the collections themselves, such as <em>Does this map contain the required keys?</em>, as well as <em>relationships</em> between scalars, such as <em>Is the second integer one greater than the first integer?</em></p><p>Collection validation is powerful, but writing collection specifications can by a tad tricky. So judgment is called for. There's no need to validate everything in the universe. Let's just validate two properties of interest.</p></div><div class="panel-footer"><span class="panel-number">49/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Ensuring required keys</h3><div class="no-display">#'screedcast-generator/version-required-keys#'screedcast-generator/changes-required-keys</div><div class="side-by-side-container"><div class="side-by-side"><pre><code>(def
  version-required-keys
  #{:date
    :breaking?
    :project-status
    :urgency
    :responsible
    :comment
    :changes
    :version})</code></pre></div><div class="side-by-side"><pre><code>(def
  changes-required-keys
  #{:description
    :date
    :breaking?
    :change-type})</code></pre></div></div><div class="note"><p>Earlier when we were validating the scalars, we were concerned with whether the date was an integer or whether the email was a string. But scalar validation does not concern itself with the <em>existence</em> of a particular datum. If a datum exists and it can be paired with a predicate, the datum is validated. If there's no datum to pair with a predicate, the predicate is ignored. When we want to ensure the existence of a datum, we use a collection predicate.</p><p>It seems reasonable that a changelog entry for a version must have a version number, a date, a person responsible, a comment, the project's status, the urgency of switching to that version, whether that version is breaking with respect to the previous version, and a listing of the actual changes. Let's gather those required keys into a set.</p><p>The scalar specification was concerned with the properties of those concepts, <em>if they exist in the data</em>. This collection predicate tests whether or not they are present.</p><p>Furthermore, we'd like to require that each of those change listings contains a description, a date, a change type, and whether it is a breaking change. Here are those required keys.</p></div><div class="panel-footer"><span class="panel-number">50/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Writing a predicate-returning function</h3><pre><pre><code>(defn contains-required-keys?
  "Returns a predicate that tests whether a map passed as the first argument contains all keys enumerated in set `req-keys`."
  [req-keys]
  #(empty? (clojure.set/difference req-keys (set (keys %)))))</code></pre></pre><div class="vspace"></div><pre><code class="form">((contains-required-keys? #{:a :b :c}) {:a 1, :b 2, :c 3})</code><br><code class="eval">;; => true</code></pre><pre><code class="form">((contains-required-keys? #{:a :b :c}) {:a 1, :b 2, :c 3, :d 4})</code><br><code class="eval">;; => true</code></pre><pre><code class="form">((contains-required-keys? #{:a :b :c}) {:a 1})</code><br><code class="eval">;; => false</code></pre><div class="note"><p>Collection validation doesn't regard a set as a predicate they way scalar validation does, so we need to write a predicate function that will accept a collection and a list of required keys and returns a boolean reporting whether that collection contains those keys. However, we have two situations where we want to do mostly the same things: keys required in a <em>version</em> map, and keys required in a <em>change</em> map. We don't want to repeat code. So we write a higher order function that returns a predicate.</p><p>Let's give that a spin.</p><p>The first two examples evaluate to <code>true</code> because the maps do indeed contain all three required keys. The second example contains an extra <code>:d</code> key, but the predicate doesn't mind. The third example returns <code>false</code> because the map is missing keys <code>:b</code> and <code>:c</code>.</p></div><div class="panel-footer"><span class="panel-number">51/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Required keys predicates</h3><pre><code>(contains-required-keys? version-required-keys)</code></pre><div class="vspace"></div><pre><code>(contains-required-keys? changes-required-keys)</code></pre><div class="note"><p>The following creates a predicate that tests whether a version map contains the required keys.</p><p>And this predicate tests whether a change map contains the required keys.</p></div><div class="panel-footer"><span class="panel-number">52/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Collection predicates apply to their parent container</h3><pre><pre><code>(def version-coll-spec
  {:req-ver-keys? (contains-required-keys? version-required-keys),
   :changes (vec (repeat 99
                         {:req-chng-keys? (contains-required-keys?
                                            changes-required-keys)}))})</code></pre></pre><div class="note"><p>One of the principles of composing a collection specification is <a href="https://github.com/blosavio/speculoos?tab=readme-ov-file#where-collection-predicates-apply"><em>Predicates apply to their immediate parent collection</em></a>. The practical consequence of that is we insert the predicate into a collection of the same kind that we want to validate. We define a collection specification for a version map like this.</p><p>There is one required-keys predicate aimed at the top-level version map. There is a second required-keys predicate aimed at the changes sequence. (Because of the current implementation, it is not possible to use an infinite <code>repeat</code> to validate zero or more collections. I therefore had to make a defined number of them — 99 because that seems plenty for this situation — and convert it to a vector. I very much want to revisit this implementation to see if this restriction can be removed, for generality, and so that writing the specification is more elegant.)</p><p>Kinda complicated, but this Case Study isn't a tutorial.</p></div><div class="panel-footer"><span class="panel-number">53/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Quick test: validating required keys</h3><pre><code class="form">(only-invalid (validate-collections (get-in* changelog-data [1])
                                             version-coll-spec))</code><br><code class="eval">;; => ({:datum {:date {:year 2024,
;;                     :month "July",
;;                     :day 26},
;;              :breaking? true,
;;              :project-status "okay!",
;;              :stable false,
;;              :responsible {:name "Brad Losavio",
;;                            :email "me@example.com"},
;;              :comment "Request for comments.",
;;              :changes [«listing elided»],
;;              :version 1},
;;      :valid? false,
;;      :path-predicate [:req-ver-keys?],
;;      :predicate #function[case-study/contains-required-keys?/fn--30138],
;;      :ordinal-path-datum [],
;;      :path-datum []})</code></pre><div class="note"><p>We can run a quick test on version 1 of the trimmed changelog version.</p><p>We can see that one predicate was not satisfied: the anonymous predicate produced by the <code>contains-required-keys</code> higher-order function. It tells us that this map doesn't contain at least one required key, in this case, <code>:urgency</code>.</p><p>In that example, we used <code>get-in*</code> to extract a single changelog entry describing a single version. But ultimately, we want to validate zero or more version entries as the project develops over time, so we use our <code>repeat</code> trick.</p></div><div class="panel-footer"><span class="panel-number">54/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Zero-or-more <em>version</em> collection specificaitons</h3><pre><pre><code>(def changelog-coll-spec (vec (repeat 99 version-coll-spec)))</code></pre></pre><div class="note"><p>Now, we can validate an ever-growing changelog with that one collection specification.</p><p>That takes care of testing for the presence of all the required keys.</p></div><div class="panel-footer"><span class="panel-number">55/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Predicate to test proper version incrementing</h3><pre><pre><code>(defn properly-incrementing-versions?
  "Returns `true` if each successive version is exactly one more than previous."
  [c-log]
  (every? #{1} (map #(- (:version %2) (:version %1)) c-log (next c-log))))</code></pre></pre><div class="note"><p>Someone might reasonably point out that manually declaring the version number inside a sequential collection is redundant and error-prone. It is. But, I may change my mind in the future and switch to dotted version numbers, or version letters, or some other format. Plus, the changelog is intended to be machine- and human-readable (with priority on the latter), and for organizing purposes, the subsections are split between different files. So it's more ergonomic to include an explicit version number. In that case, we can validate the version number sequence as a kind of 'spell-check' to alert me when I've made an error writing a changelog entry.</p><p>Here's a predicate that will extract the version number from each changelog entry and compare it to the previous.</p></div><div class="panel-footer"><span class="panel-number">56/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Quick test: Validate version increments</h3><pre><code class="form">(validate-collections changelog-data
                      [properly-incrementing-versions?])</code><br><code class="eval">;; => ({:datum [«data elided»],
;;      :valid? false,
;;      :path-predicate [0],
;;      :predicate properly-incrementing-versions?,
;;      :ordinal-path-datum [],
;;      :path-datum []})</code></pre><div class="note"><p>Let's give it a spin. Collection predicates apply to their immediate parent collection, so we insert the predicate into the root of the specification.</p></div><div class="panel-footer"><span class="panel-number">57/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Quick test: Finind offending values</h3><pre><code class="form">(map #(:version %) changelog-data)</code><br><code class="eval">;; => (0 1 99)</code></pre><div class="note"><p>Our <em>ad hoc</em> specification contained only a single predicate, <code>properly-incrementing-versions?</code>, and it was not satisfied with the datum it was paired with. Unfortunately, we only have the identity of the unsatisfied predicate, and the value of the datum, which is the entire changelog in this case. So we don't have any details on <em>where</em> exactly the version numbers are wrong. We need to use our Clojure powers for more insight. Fortunately, it's a one-liner to pull out the version datums.</p><p>Oops. <code>99</code> does not properly follow <code>1</code>. Gotta go edit the third changelog entry.</p><p>Notice that, while on a basic level, we are inspecting scalars, we couldn't use scalar validation for this task. We are validating the <em>relationships</em> between multiple scalars. Handling multiple scalars necessarily requires a collection validation.</p></div><div class="panel-footer"><span class="panel-number">58/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Assembling the collection specification</h3><pre><code>(def changelog-coll-spec
  (concat [properly-incrementing-versions?]
          (vec (repeat 99 version-coll-spec))))</code></pre><div class="note"><p>We've now created and demonstrated collection specifications for both the required keys and for properly-incrementing version numbers. Let's put them together into a single specification. Speculoos specifications are standard Clojure collections, so we can use regular composition. The changelog collection specification is a vector — mimicking the shape of the changelog data — containing the <code>properly-incrementing-versions?</code> predicate followed by an infinite number of version collection specifications.</p></div><div class="panel-footer"><span class="panel-number">59/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Sanity check: validate with composed collection specification</h3><pre><code class="form">(only-invalid (validate-collections changelog-data
                                    changelog-coll-spec))</code><br><code class="eval">;; => ({:datum [«data elided»],
;;      :valid? false,
;;      :path-predicate [0],
;;      :predicate properly-incrementing-versions?,
;;      :ordinal-path-datum [],
;;      :path-datum []}
;;     {:datum {«data elided»},
;;      :valid? false,
;;      :path-predicate [2 :req-ver-keys?],
;;      :predicate #function[case-study/contains-required-keys?/fn--32159],
;;      :ordinal-path-datum [1],
;;      :path-datum [1]})</code></pre><div class="note"><p>As a sanity check, let's re-run the validation with the composed collection specification.</p><p>Exactly the same two invalid results we saw before. There is a problem with the version number intervals. And one of the changelog version entries is missing a required key. The only difference is that we used one comprehensive collection specification, <code>changelog-collection-spec</code>.</p></div><div class="panel-footer"><span class="panel-number">60/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>'Combo' validation</h3><pre><code>(only-invalid (validate changelog-data
                        changelog-scalar-spec
                        changelog-coll-spec))</code></pre><div class="note"><p>If we find it convenient, we could do a combo so that both scalars and collections are validated with a single function invocation.</p><p>I won't evaluate the expression because we've already seen the results.</p><p>I should also mention that <a href="https://github.com/blosavio/speculoos?tab=readme-ov-file#combo-validation">'combo' validation</a> with <code>validate</code> and friends does not violate <a href="https://github.com/blosavio/speculoos?tab=readme-ov-file#mottos">Motto #1</a>. It performs a scalar validation, then a wholly distinct collection validation, then merges the results. The two tasks are, as always, distinct. <code>validate</code> merely provides us with a convenient way to perform both with one function evaluation.</p></div><div class="panel-footer"><span class="panel-number">61/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Observations & conclusion</h3><ul><li>efficiency & expressiveness</li><li>importance of unit-testing predicates</li><li>real-world counts of changelog errors</li><li>results suggest procedural changes</li><li>experiences beyond simplified examples</li></ul><div class="vspace"></div><pre><code>{:year int?
 :month string?
 :day int?}</code></pre><div class="note"><p>Valuable exercise. Bespoke validation functions, but specifications faster. (proper scientific test...) Predicates+specifications more understandable & maintainable than one-off validation functions.</p><p>Realization: Real-world predicate functions ought to be formally unit-tested. 1. Edge-case bug and 2. fumbling a set operation, created dedicated namespace with  tests. Specifications, and by extension, validation, are only as good as the predicates. If predicates crummy,  validation crummy, too. Unit-testing does take a little time and effort. But like unit-testing, the time and effort is worth the investment.</p><p>Eleven errors spread across multiple files, including two errant <code>nil</code>s, and numerous mis-spelled keywords. From now on, can validate each changelog entry with the exact same specifications we've already written here. Checking the changelog's correctness the moment typing it in, instead of finding out sometime later.</p><p>Validation suggestsed procedural changes: keyboarding mistakes was eye-opening, create template based upon the specification, so that each new entry will have spellings that conform to specification. Long-term, a command-line tool?</p><p>Beyond intentionally simplified examples. Performance. But<em>experimental</em>. And interactive development (i.e., at the <span class="small-caps">repl</span>, not in the middle of a high-throughput pipeline), tolerable. Also, validation report unwieldy. Glossed with <code>«data elided»</code>. When processing it with machines, it doesn't matter much. Going to think about.</p><p>Maybe not test-driven dev, but similar realization: Writing specifications for some data (or a function's arguments/returns) before you have the data is a legit tactic. Forces clarified thinking about how the data ought to arranged, and documents it in human- and machine-readable form. Specification for a date…</p><p>…without having any concrete substantiation of data, can discuss the merits of those choices. Restrictions on <em>year</em>? Should <em>month</em> values be strings, or keywords? Should  key for <em>day of the month</em> be <code>:day</code> or <code>:date</code>? That little map is not pseudo-code! We could send it, un-modified, to <code>validate-scalars</code> and get a feel for how it would work with real data.</p><p>Let me know what you think.</p></div><div class="panel-footer"><span class="panel-number">62/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>What's next.</h3><ol class="de-highlight whats-next"><li>Introduction</li><li>Mechanics</li><li>Validating Scalars</li><li>Validating Collections, Basics</li><li>Validating Collections, Advanced</li><li>Validating Collections, Extras</li><li>Validation Summaries & Thoroughness</li><li>Function Validation</li><li>Generating Random Samples & Exercising</li><li>Utilities</li><li>Predicates</li><li>Non-Terminating Sequences</li><li>Sets</li><li>Troubleshooting</li><li>Comparing spec.alpha to Speculoos</li><li>Perhaps So</li><li>Case Study</li></ol><div class="note">What's next speaker note within 'Case Study' screencast...</div><div class="panel-footer"><span class="panel-number">63/63</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><p id="page-footer">Copyright © 2024 Brad Losavio.<br>Compiled 2024 December 02.<div class="license"><p>This program and the accompanying materials are made available under the terms of the <a href="https://opensource.org/license/MIT">MIT License</a>.</p></div><span id="uuid"><br>7c4ba802-9f14-46c2-aa8b-411a86629b44</span></p></body></head></html>