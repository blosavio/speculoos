<!DOCTYPE html>
<html lang="en"><head><link href="screedcast.css" rel="stylesheet" type="text/css"><script src="jquery-3.7.1.min.js" type="text/javascript"></script><script src="screedcast.js" type="text/javascript"></script><title>Speculoos — An experimental Clojure data validation library</title><meta charset="utf-8" compile-date="2024-12-02 15:48:34" content="width=device-width, initial-scale=1" name="viewport"><body><div class="panel"><div class="panel-header"></div><h1>Speculoos Screencast 4 — Collection Validation: Basics</h1><p>So far…</p><pre><code class="form">(valid-scalars? [42 "abc" 22/7]
                [int? string? ratio?])</code><br><code class="eval">;; => true</code></pre><div class="note"><p>You may have been bothered about something while going through the 'scalar validation' screencast. Every example we've seen so far shows Speculoos validating individual scalars, such as integers, strings, booleans, etc.</p><p>However, we might need to specify some property of a collection itself, such as a vector's length, the presence of a key in a map, relationships <em>between</em> datums, etc. That is <em>collection validation</em>.</p></div><div class="panel-footer"><span class="panel-number">1/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Scalars versus Collections</h3><table><tr><td>scalars</td><td><code><span class="de-highlight">[</span><span class="highlight">42</span><span class="de-highlight"> {:x </span><span class="highlight">"abc"</span><span class="de-highlight"> :y </span><span class="highlight">22/7</span><span class="de-highlight">}]</span></code></td></tr><tr><td>collections</td><td><code><span class="highlight">[</span><span class="de-highlight">42</span><span class="highlight"> {:x </span><span class="de-highlight">"abc"</span><span class="highlight"> :y </span><span class="de-highlight">22/7</span><span class="highlight">}]</span></code></td></tr></table><div class="note"><p>This is one way to visualize the difference. Scalar validation targets only the scalars: numbers, strings, characters, etc.. Collection validation only validates the collections themselves: vectors, maps, sequences, lists, sets. We could kinda think about it as validating the brackets, parens, braces, etc.</p></div><div class="panel-footer"><span class="panel-number">2/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3><em>Validating</em> scalars versus <em>validating</em> collections</h3><code>speculoos.core/validate-scalars</code><div class="vspace"></div><code>speculoos.core/validate-collections</code><div class="note"><p>One of Speculoos' main concepts is that scalars are specified and validated explicitly separately from collections. You perhaps noticed that the function name we have been using wasn't <code>validate</code> but instead <code>validate-scalars</code>. Speculoos provides a parallel group of functions to validate the properties of collections, independent of the scalar values they contain. Let's examine why and how they're separated.</p></div><div class="panel-footer"><span class="panel-number">3/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>When to validate collections versus validating scalars #1</h3><h4>Validate property of the collection</h4><p>Examples</p><ul><li>Size of a collection: <code>#(< 10 (count %))</code></li><li>Existence of an element: <code>#(contains? % :email)</code></li></ul><div class="note"></div><div class="panel-footer"><span class="panel-number">4/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>When to validate collections versus validating scalars #2</h3><h4>Validation relationship between scalars</h4><p>Examples</p><ul><li>Second element equal to first: <code>#(= (get % 0) (get % 1))</code></li><li>All elements ascending: <code>#(apply < %)</code></li></ul><div class="note"><p>Don't have to pick _just_ scalar or collection. We can do both and use the advantages of each.</p></div><div class="panel-footer"><span class="panel-number">5/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>★ Three Mottos</h3><ol class="side-by-side-by-side-container"><div class="side-by-side-by-side"><li>Validate scalars separately from validating collections.</li><div class="vspace"></div><p>scalars:<br><code>&emsp;&emsp;42, "abc", \c, 22/7, :kw, 'foo, true, nil</code></p><div class="vspace"></div><p>collections:<br><code>&emsp;&emsp;[…], {…}, (…), #{…}</code></p><div class="note"><p>Distinct functions for validating scalars and collections in HANDS. Advantages:<ol><li>Simpler. No mini-language that mixes identities and quantities. Specs Cloj data structures w/functions. Manipulate specs w/anything, e.g. <code>assoc-in</code> No macros.</li><li>Mental clarity. Validation only applies to scalar, or to collection, never both. Predicate doesn't have to know anything about the quantity or location of the element.</li><li>Only specify as much, or as little, as necessary. If only a few scalars, won't be forced to specify a property concerning a collection.</li></ol></p></div></div><div class="side-by-side-by-side"><li>Shape the specification to mimic the data.</li><div>data</div><div>↓</div><pre><code>{:x 42   :y "abc"  }</code><br><code>{:x int? :y string?}</code></pre><div>↑</div><div>specification</div><div class="note"><p>Composing specs straightforward; mimic shape of data. Arrangement of nested vectors, lists, maps, sequences, and sets that contain predicates. Pattern instruct the validation functions where to apply the predicates. Spec for a vector is a vector. Spec for a map, is a map. ~1-to-1 correspondence b/t shape of data and shape of specific. Strategy: copy-paste data, delete contents,  use as a template, replace elements with predicates. Peek at by eye — merely eval them at <span class="small-caps">repl</span> — easy alteration: any Clojure data wrangling functions to tighten, relax, or remove portions of spec. <code>assoc-in</code>, <code>update-in</code>, & <code>dissoc</code>.</p></div></div><div class="side-by-side-by-side"><li>Ignore un-paired predicates and un-paired datums.</li><div>data</div><div>↓</div><pre><code>{:x 42   <s>:y "abc"</s>}</code><br><code>{:x int? <s>:q double?</s>}</code></pre><div>↑</div><div>specification</div><div class="note"><p>Ignoring -> Flexibility, power, optionality, and re-usability. Ex #1: pipeline. Supplying predicates for subset of datums only validates those specified datums while being agnostic towards the other datums. Ex #2 Sprawling specification that describes a myriad of data about a person, postal address,  contact info, etc. B/c a spec just  data structure with regular predicates, can, on-the-fly, <code>get-in</code> portion relevant to postal addresses and apply that to our particular instances of address data. Specify exactly what elements we'd like to validate. No more, no less.</p></div></div></ol><div class="note"><p>Three Mottos speaker notes</p></div><div class="panel-footer"><span class="panel-number">6/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Motivational quick example #1: validate vector length</h3><pre><code>(require '[speculoos.core :refer [valid-collections?]])</code></pre><div class="vspace"></div><pre><code>(defn length-3? [v] (= 3 (count v)))</code></pre><div class="vspace"></div><pre><code class="form">(valid-collections? [42 "abc" 22/7]
                    [length-3?])</code><br><code class="eval">;; => true</code></pre><div class="note"><p>3 Mottos: Collection validation, see fn name. Specification mimics shape of data. Everything was paired; nothing ignored.</p><p>Note: Predicates apply to their immediate parent collections. `length-3?` targets the vector, not scalar `42`.</p></div><div class="panel-footer"><span class="panel-number">7/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Motivational quick example #2: validate key in map</h3><pre><code>(defn map-contains-keyword-y? [m] (contains? m :y))</code></pre><div class="vspace"></div><pre><code class="form">(valid-collections? {:x 42}
                    {:foo map-contains-keyword-y?})</code><br><code class="eval">;; => false</code></pre><div class="note"><p>Ignore `:foo` for the moment. Notice: specification shape mimics shape of data (but not exact copy).</p></div><div class="panel-footer"><span class="panel-number">8/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Motivational quick example #3: validate two arguments</h3><pre><code>(defn even-args-fn-call? [f] (even? (count (rest f))))</code></pre><div class="vspace"></div><pre><code class="form">(valid-collections? (list < 1 2)
                    (list even-args-fn-call?))</code><br><code class="eval">;; => true</code></pre><div class="note"><p>Validating aspects of the number of elements in a collection is only possible with the whole collection, not merely the scalars.</p></div><div class="panel-footer"><span class="panel-number">9/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Motivational quick example #4: all set members even number</h3><pre><code>(defn all-odd? [s] (every? odd? s))</code></pre><div class="vspace"></div><pre><code class="form">(valid-collections? #{1 2 3}
                    #{all-odd?})</code><br><code class="eval">;; => false</code></pre><div class="note"><p>All these examples require access to the entire collection. None could be accomplished with a scalar validation.</p></div><div class="panel-footer"><span class="panel-number">10/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Where collection predicates apply #1</h3><h4>Predicates apply to their <em>parent</em> collection.</h4><pre><code class="form">(valid-collections? [42 "abc" 22/7]
                    [vector?])</code><br><code class="eval">;; => true</code></pre><div class="note"><p>Predicate `vector?` is applied to the parent container, not the integer `42`.</p></div><div class="panel-footer"><span class="panel-number">11/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Where collection predicates apply #2</h3><h4>Predicates apply to their <em>immediate</em> parent collection.</h4><pre><code class="form">(valid-collections? [[42 "abc" 22/7]]
                    [[length-3?]])</code><br><code class="eval">;; => true</code></pre><div class="note"><p>Predicate `length-3?` is applied to the immediate parent vector, not the grand-parent. The immediate parent has three elements, so the validation returns `true`.</p><p>The outer/root collection wasn't paired, so it was ignored (Motto #3).</p></div><div class="panel-footer"><span class="panel-number">12/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Where collection predicates apply #3</h3><h4><em>Any</em> predicates apply to their immediate parent collection.</h4><pre><code class="form">(valid-collections? [42 "abc" 22/7]
                    [coll? vector? sequential?])</code><br><code class="eval">;; => true</code></pre><div class="note"><p>All three predicates are applied to the vector, not only the first one. Scalar validation: 1-to-1 predicate-to-scalar. Collection validation: many-to-1 predicate-to-coll.</p><p>Applying predicates to their parent collection allows us to write specifications whose shape mimic the shape of the data.</p><p>3 Mottos + targeting parent collection are an emergent property of the collection validation algorithm. If we understand the algorithm, we can write clear, correct, and expressive collection specifications.</p></div><div class="panel-footer"><span class="panel-number">13/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>General pattern of discussion</h3><p>A. Manual algorithm</p><p>B. Automatic algorithm</p><div class="panel-footer"><span class="panel-number">14/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>How collection validation works</h3><h4>Collection predicate</h4><pre><code>(defn len-3? [c] (= 3 (count c)))</code></pre><div class="note"><p>Imagine we wanted to specify that our data vector was exactly three elements long. We might reasonably write this predicate, whose argument is a collection.</p><p>`len-3?` is a predicate that returns `true` if the collection has three elements</p><p>Notice that this predicate tests a property of the collection itself: the number of elements it contains. <code>validate-scalars</code> has no way to do this kind of test because it deliberately only considers scalars.</p></div><div class="panel-footer"><span class="panel-number">15/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>All-paths of a Vector.</h3><p><em>A vector, containing exactly three elements.</em></p><pre><code class="form">(all-paths [42 "abc" 22/7])</code><br><code class="eval">;; => [{:path [], :value [42 "abc" 22/7]}
;;     {:path [0], :value 42}
;;     {:path [1], :value "abc"}
;;     {:path [2], :value 22/7}]</code></pre><div class="note"><p>Imagine we want to specify that our data vector was exactly three elements long. The paths of that data might look like this.</p><p>Since we're now interested in specifying collections, we'll discard the <em>scalars</em> and focus only on the <em>collections</em>. In this case, there's only one collection, the vector at path <code>[]</code>, which signifies that it's the root collection.</p></div><div class="panel-footer"><span class="panel-number">16/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Collection specification: construction strategy</h3><pre><code>[42 "abc" 22/7] ;; copy-paste data</code></pre><div class="vspace"></div><pre><code>[             ] ;; delete scalars</code></pre><div class="vspace"></div><pre><code>[len-3?       ] ;; insert predicate</code></pre><div class="note"><p>We're validating collections (Motto #1), so we're only interested in the root collection at path <code>[]</code> in the data. Let's apply Motto #2 and shape our specification to mimic the shape of the data. We'll copy-paste the data…</p><p>That will be our specification. Notice: during collection validation, we insert predicates <em>inside</em> the collection that they target.</p></div><div class="panel-footer"><span class="panel-number">17/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Collection validation algorithm</h3><ol class="collection-algorithm"><li><code>All-paths</code> data, then specification</li><li><s>scalar</s> elements from the data</li><li><s>non-predicate</s> elements from the specification</li><li>Pair via paths: <em>path</em> to <code>(drop-last <em>path</em>)</code>; discard un-paired</li><li>Apply predicates</li></ol><div class="note"><p>Validating collections uses a <em>slightly</em> adjusted version of the <a href="#scalar-algorithm">scalar validation algorithm</a>. (If you are curious <em>why</em> the collection algorithm is different, see <a href="#collection-predicate-paths">this later subsection</a>.) The algorithm for validating collections is this.</p><p>There are two main differences: We keep only the _collections_ from the data instead of the scalars (Motto #1). Predicates and their target do not share the exact same path. Instead, predicate at path pairs with collection at `(drop-last path)`.</p></div><div class="panel-footer"><span class="panel-number">18/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Manual collection validation #1: Enumerate paths</h3><div class="side-by-side-container"><div class="side-by-side"><div>data</div><div class="vspace"></div><pre><code class="form">(all-paths [42 "abc" 22/7])</code><br><code class="eval">;; => [{:path [], :value [42 "abc" 22/7]}
;;     {:path [0], :value 42}
;;     {:path [1], :value "abc"}
;;     {:path [2], :value 22/7}]</code></pre></div><div class="side-by-side"><div>specification</div><div class="vspace"></div><div class="vspace"></div><div class="vspace"></div><pre><code class="form">(all-paths [len-3?])</code><br><code class="eval">;; => [{:path [], :value [len-3?]}
;;     {:path [0], :value len-3?}]</code></pre></div></div><div class="note"><p>Let's perform that algorithm manually. We run <code>all-paths</code> on both the data……and <code>all-paths</code> on our collection specification.</p></div><div class="panel-footer"><span class="panel-number">19/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Manual collection validation #2: Keep only…</h3><div class="side-by-side-container"><div class="side-by-side"><div>…collections from data</div><pre><code>[{:path [], :value [42 "abc" 22/7]}]</code></pre></div><div class="side-by-side"><div>…predicates from specification</div><pre><code>[{:path [0], :value len-3?}]</code></pre></div></div><div class="note"><p>We discard all scalar elements of the data, keeping only the collection elements. And we keep only the predicate elements of the specification.</p></div><div class="panel-footer"><span class="panel-number">20/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Manual collection validation #3: Pair collections with predicates</h3><div class="side-by-side-container"><div class="side-by-side"><div>path of coll in data</div><pre><code>[]</code></pre></div><div class="side-by-side"><div>path of predicate in specification</div><pre><code class="form">(drop-last [0])</code><br><code class="eval">;; => ()</code></pre><div class="vspace"></div><pre><code class="form">(= [] (drop-last [0]))</code><br><code class="eval">;; => true</code></pre></div></div><div class="note"><p>The root collection's is path <code>[]</code>; <code>len-3?</code> predicate's path is <code>[0]</code>. <code>(drop-last [0])</code> evaluates to <code>()</code>, which is equivalent. So the predicate and the collection are paired.</p></div><div class="panel-footer"><span class="panel-number">21/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Manual collection validation #4: Apply predicates</h3><pre><code class="form">(len-3? [42 "abc" 22/7])</code><br><code class="eval">;; => true</code></pre><div class="note"><p> We then apply the predicate. The data vector is indeed three elements long, so predicate `len-3?` is satisfied.</p></div><div class="panel-footer"><span class="panel-number">22/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Collection validation: flat vector</h3><pre><code>(require '[speculoos.core :refer [validate-collections]])</code></pre><div class="vspace"></div><pre><code class="form">(validate-collections [42 "abc" 22/7]
                      [len-3?])</code><br><code class="eval">;; => ({:datum [42 "abc" 22/7],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate len-3?,
;;      :valid? true})</code></pre><div class="note"><p>That's familiar. <code>validate-collections</code> shows every collection+predicate pair. In this case, the data's root vector was paired with the single <code>len-3?</code>predicate. The <code>:datum</code> represents the thing being tested, the <code>:predicate</code>s indicate the predicate functions, and <code>valid?</code> reports whether that predicate was satisfied. The root vector contains three elements, so <code>len-3?</code> was satisfied.</p><p>There are now three things that involve some notion of a path. The predicate was found at <code>:path-predicate</code> in the specification. The datum was found at <code>:ordinal-path-datum</code> in the data, which is also presented in a more friendly format as the literal path <code>:path-datum</code>. (We'll explain the terms embodied by these keywords as the discussion progresses.) Notice that the path of the root vector <code>[]</code> is equivalent to running <code>drop-last</code> on the path of the <code>len-3?</code> predicate: <code>(drop-last [0])</code> evaluates to <code>()</code>.</p></div><div class="panel-footer"><span class="panel-number">23/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested vector: data, predicates, & specification</h3><table><tr><td>data</td><td><pre><code>[42 ["abc" 22/7]]</code></pre></td><div class="vspace"></div></tr><tr><td>predicates</td><td><pre><code>(defn len-2? [c] (= 2 (count c)))</code></pre><pre><code>(defn len-3? [c] (= 3 (count c)))</code></pre><div class="vspace"></div></td></tr><tr><td>specification</td><td><pre><code>[42     ["abc" 22/7]] ;; copy-paste data</code><br><code>[       [          ]] ;; delete scalars</code><br><code>[len-3? [len-2?    ]] ;; insert predicates</code></pre></td></tr></table><div class="note"><p>Let's explore validating a two-element vector nested within a two-element vector. To test whether each of those two vectors contain two elements, we could write this collection predicate.</p><p>Remember Motto #1: This predicate accepts a collection, <code>c</code>, not a scalar.</p><p>We'll invent some data, a two-element vector nested within a two-element vector by wrapping the final two elements inside an additional pair of brackets.</p><p>Note that the outer root vector contains exactly two elements: one scalar <code>42</code> and one descendant collection, the nested vector <code>["abc" 22/7]</code>.</p><p>Following Motto #2, we'll compose a collection specification whose shape mimics the shape of the data. We copy-paste the data, delete the scalars, and insert our predicates.</p><p>(I've re-used the <code>len-3?</code> predicate so that in the following examples, it'll be easier to keep track of which predicate goes where when we have multiple predicates.)</p></div><div class="panel-footer"><span class="panel-number">24/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested vector #1: Enumerate paths</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code class="form">(all-paths [42 ["abc" 22/7]])</code><br><code class="eval">;; => [{:path [], :value [42 ["abc" 22/7]]}
;;     {:path [0], :value 42}
;;     {:path [1], :value ["abc" 22/7]}
;;     {:path [1 0], :value "abc"}
;;     {:path [1 1], :value 22/7}]</code></pre></div><div class="side-by-side"><div class="vspace"></div><div class="vspace"></div><div class="vspace"></div><pre><code class="form">(all-paths [len-3? [len-2?]])</code><br><code class="eval">;; => [{:path [], :value [len-3? [len-2?]]}
;;     {:path [0], :value len-3?}
;;     {:path [1], :value [len-2?]}
;;     {:path [1 0], :value len-2?}]</code></pre></div></div><div class="panel-footer"><span class="panel-number">25/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested vector #2: Keep only…</h3><div class="side-by-side-container"><div class="side-by-side"><div>…collections from data</div><pre><code>[{:path [], :value [42 ["abc" 22/7]]}
 {:path [1], :value ["abc" 22/7]}]</code></pre></div><div class="side-by-side"><div>…predicates from specification</div><pre><code>[{:path [0], :value len-3?}
 {:path [1 0], :value len-2?}]</code></pre></div></div><div class="panel-footer"><span class="panel-number">26/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested vector #3: Pair collections with predicates</h3><div class="side-by-side-container"><div class="side-by-side"><div>paths of collections in data</div><pre><code>[]</code></pre><pre><code>[1]</code></pre></div><div class="side-by-side"><div>path of predicates in specification</div><pre><code class="form">(drop-last [0])</code><br><code class="eval">;; => ()</code></pre><pre><code class="form">(= [] (drop-last [0]))</code><br><code class="eval">;; => true</code></pre><div class="vspace"></div><pre><code class="form">(drop-last [1 0])</code><br><code class="eval">;; => (1)</code></pre><pre><code class="form">(= [1] (drop-last [1 0]))</code><br><code class="eval">;; => true</code></pre></div></div><div class="note"><p>Scalar validation: share exact paths, but collection validation: collection at `(drop-last path)`, predicate at `path`. The practical effect: the predicate applies to the immediate parent.</p></div><div class="panel-footer"><span class="panel-number">27/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested vector #4: Apply predicates</h3><pre><code class="form">(len-3? [42 ["abc" 22/7]])</code><br><code class="eval">;; => false</code></pre><div class="vspace"></div><pre><code class="form">(len-2? ["abc" 22/7])</code><br><code class="eval">;; => true</code></pre><div class="note"><p>Nested vector satisfies predicate, but root doesn't; it only has two elements: the scalar `42` and the nested vector.</p></div><div class="panel-footer"><span class="panel-number">28/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Collection validation: nested vector</h3><pre><code class="form">(validate-collections [42 ["abc" 22/7]]
                      [len-3? [len-2?]])</code><br><code class="eval">;; => ({:datum [42 ["abc" 22/7]],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate len-3?,
;;      :valid? false}
;;     {:datum ["abc" 22/7],
;;      :ordinal-path-datum [0],
;;      :path-datum [1],
;;      :path-predicate [1 0],
;;      :predicate len-2?,
;;      :valid? true})</code></pre><div class="note"><p>Perform algorithm with one invocation. Two pairs of predicates+collections, two validation entries. `len-3?` not satisfied, `len-2?` was satisfied.</p></div><div class="panel-footer"><span class="panel-number">29/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested nested vector: data, predicates, & specification</h3><table><tr><td>data</td><td><pre><code>[42 ["abc" [22/7]]]</code></pre><div class="vspace"></div></td></tr><tr><td>predicates</td><td><pre><code>(defn len-1? [c] (= 1 (count c)))</code></pre><pre><code>(defn len-2? [c] (= 2 (count c)))</code></pre><pre><code>(defn len-3? [c] (= 3 (count c)))</code></pre><div class="vspace"></div></td></tr><tr><td>specification</td><td><pre><code>[42     ["abc"  [22/7  ]]] ;; copy-paste data</code></pre><pre><code>[       [       [      ]]] ;; remove scalars</code></pre><pre><code>[len-3? [len-2? [len-1?]]] ;; insert predicates</code></pre></td></tr></table><div class="note"><p>One additional nested vector, one additional nested predicate. Three predicates, three collections. Specification properly mimics shape of data, so all three will be paired.</p></div><div class="panel-footer"><span class="panel-number">30/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested nested vector #1: Enumerate paths</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code class="form">(all-paths [42 ["abc" [22/7]]])</code><br><code class="eval">;; => [{:path [], :value [42 ["abc" [22/7]]]}
;;     {:path [0], :value 42}
;;     {:path [1], :value ["abc" [22/7]]}
;;     {:path [1 0], :value "abc"}
;;     {:path [1 1], :value [22/7]}
;;     {:path [1 1 0], :value 22/7}]</code></pre></div><div class="side-by-side"><div class="vspace"></div><div class="vspace"></div><div class="vspace"></div><pre><code class="form">(all-paths [len-3? [len-2? [len-1?]]])</code><br><code class="eval">;; => [{:path [], :value [len-3? [len-2? [len-1?]]]}
;;     {:path [0], :value len-3?}
;;     {:path [1], :value [len-2? [len-1?]]}
;;     {:path [1 0], :value len-2?}
;;     {:path [1 1], :value [len-1?]}
;;     {:path [1 1 0], :value len-1?}]</code></pre></div></div><div class="note"><p>Collection validation, so we're only interested in three collection elements of data, and predicate elements of specification.</p></div><div class="panel-footer"><span class="panel-number">31/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested nested vector #2: Keep only…</h3><div class="side-by-side-container"><div class="side-by-side"><div>…collections from the data</div><pre><code>[{:path [], :value [42 ["abc" [22/7]]]}
 {:path [1], :value ["abc" [22/7]]}
 {:path [1 1], :value [22/7]}]</code></pre></div><div class="side-by-side"><div>…predicates from the specification</div><pre><code>[{:path [0], :value len-3?}
 {:path [1 0], :value len-2?}
 {:path [1 1 0], :value len-1?}]</code></pre></div></div><div class="note"><p>Keep only collections and predicates.</p></div><div class="panel-footer"><span class="panel-number">32/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested nested vector #3: Pair collections with predicates</h3><div class="side-by-side-container"><div class="side-by-side"><div>paths of collections in data</div><pre><code>[]</code></pre><pre><code>[1]</code></pre><pre><code>[1 1]</code></pre></div><div class="side-by-side"><div>path of predicates in specification</div><pre><code class="form">(drop-last [0])</code><br><code class="eval">;; => ()</code></pre><pre><code class="form">(drop-last [1 0])</code><br><code class="eval">;; => (1)</code></pre><pre><code class="form">(drop-last [1 1 0])</code><br><code class="eval">;; => (1 1)</code></pre><div class="vspace"></div><pre><code class="form">(= [] (drop-last [0]))</code><br><code class="eval">;; => true</code></pre><pre><code class="form">(= [1] (drop-last [1 0]))</code><br><code class="eval">;; => true</code></pre><pre><code class="form">(= [1 1] (drop-last [1 1 0]))</code><br><code class="eval">;; => true</code></pre></div></div><div class="note"><p>The `drop-last` procedure has the practical result that the predicates will apply to their immediate parent. Each of the three forms a pair.</p></div><div class="panel-footer"><span class="panel-number">33/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested nested vector #4: Apply predicates</h3><pre><code class="form">(len-3? [42 ["abc" [22/7]]])</code><br><code class="eval">;; => false</code></pre><div class="vspace"></div><pre><code class="form">(len-2? ["abc" [22/7]])</code><br><code class="eval">;; => true</code></pre><div class="vspace"></div><pre><code class="form">(len-1? [22/7])</code><br><code class="eval">;; => true</code></pre><div class="panel-footer"><span class="panel-number">34/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Collection validation: nested nested vector</h3><pre><code class="form">(validate-collections [42 ["abc" [22/7]]]
                      [len-3? [len-2? [len-1?]]])</code><br><code class="eval">;; => ({:datum [42 ["abc" [22/7]]],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate len-3?,
;;      :valid? false}
;;     {:datum ["abc" [22/7]],
;;      :ordinal-path-datum [0],
;;      :path-datum [1],
;;      :path-predicate [1 0],
;;      :predicate len-2?,
;;      :valid? true}
;;     {:datum [22/7],
;;      :ordinal-path-datum [0 0],
;;      :path-datum [1 1],
;;      :path-predicate [1 1 0],
;;      :predicate len-1?,
;;      :valid? true})</code></pre><div class="note"><p>Data, upper row; specification, lower row. Same result as manual algorithm. Three predicate+collection pairs, three validation results. `len-3?` again wasn't satisfied. Other two were.</p></div><div class="panel-footer"><span class="panel-number">35/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Flat map: data, predicate, & specification</h3><table><tr><td>data</td><td><pre><code>{:x 42}</code></pre></td></tr><tr><td>predicate</td><td><pred><code>map?</code></pred></td></tr><tr><td><div class="vspace"></div></td></tr><tr><td>specification</td><td><pre><code>{:x 42    } ;; copy-paste data</code></pre><pre><code>{         } ;; remove scalars</code></pre><pre><code>{map?     } ;; => java.lang.RuntimeException...</code></pre><pre><code>{:foo map?} ;; insert predicate</code></pre></td></tr></table><div class="note"></div><div class="panel-footer"><span class="panel-number">36/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Flat map #1: Enumerate paths</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code class="form">(all-paths {:x 42})</code><br><code class="eval">;; => [{:path [], :value {:x 42}}
;;     {:path [:x], :value 42}]</code></pre></div><div class="side-by-side"><pre><code class="form">(all-paths {:foo map?})</code><br><code class="eval">;; => [{:path [], :value {:foo map?}}
;;     {:path [:foo], :value map?}]</code></pre></div></div><div class="note"></div><div class="panel-footer"><span class="panel-number">37/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Flat map #2: Keep only…</h3><div class="side-by-side-container"><div class="side-by-side"><div>…collections from the data</div><pre><code>[{:path [], :value {:x 42}}]</code></pre></div><div class="side-by-side"><div>…predicates from the specification</div><pre><code>[{:path [:foo], :value map?}]</code></pre></div></div><div class="note"></div><div class="panel-footer"><span class="panel-number">38/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Flat map #3: Pair collections with predicates</h3><div class="side-by-side-container"><div class="side-by-side"><div>paths of collections in data</div><pre><code>[]</code></pre></div><div class="side-by-side"><div>path of predicate in specification</div><pre><code class="form">(drop-last [:foo])</code><br><code class="eval">;; => ()</code></pre><div class="vspace"></div><pre><code class="form">(= [] (drop-last [:foo]))</code><br><code class="eval">;; => true</code></pre></div></div><div class="note"></div><div class="panel-footer"><span class="panel-number">39/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Flat map #4: Apply predicates</h3><pre><code class="form">(map? {:x 42})</code><br><code class="eval">;; => true</code></pre><div class="note"></div><div class="panel-footer"><span class="panel-number">40/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Collection validation: flat map</h3><pre><code class="form">(validate-collections {:x 42}
                      {:foo map?})</code><br><code class="eval">;; => ({:datum {:x 42},
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [:foo],
;;      :predicate map?,
;;      :valid? true})</code></pre><div class="note"></div><div class="panel-footer"><span class="panel-number">41/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Predicate's key itself is irrelevant (mostly)</h3><pre><code>(drop-last [:foo]) ;; => ()</code><br><code>(drop-last [:bar]) ;; => ()</code><br><code>(drop-last [:baz]) ;; => ()</code></pre><div class="vspace"></div><p>But, don't use a key that appears in the data!</p><div class="note"><p>The next example shows why not.</p></div><div class="panel-footer"><span class="panel-number">42/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested map: data, predicate, & specification (non-ideal specification)</h3><table><tr><td>data</td><td><pre><code>{:x 42 :y {:z "abc"}}</code></pre></td></tr><tr><td>predicate</td><td><pred><code>map?</code></pred></td></tr><tr><td><div class="vspace"></div></td></tr><tr><td>specification</td><td><pre><code>{:x 42 :y {:z "abc"}} ;; copy-paste data</code></pre><pre><code>{      :y           } ;; remove scalars</code></pre><pre><code>{      :y map?      } ;; insert predicate</code></pre></td></tr></table><div class="note"></div><div class="panel-footer"><span class="panel-number">43/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested map #1: Enumerate paths (non-ideal specification)</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code class="form">(all-paths {:x 42, :y {:z "abc"}})</code><br><code class="eval">;; => [{:path [], :value {:x 42, :y {:z "abc"}}}
;;     {:path [:x], :value 42}
;;     {:path [:y], :value {:z "abc"}}
;;     {:path [:y :z], :value "abc"}]</code></pre></div><div class="side-by-side"><div class="vspace"></div><div class="vspace"></div><div class="vspace"></div><pre><code class="form">(all-paths {:y map?})</code><br><code class="eval">;; => [{:path [], :value {:y map?}}
;;     {:path [:y], :value map?}]</code></pre></div></div><div class="note"></div><div class="panel-footer"><span class="panel-number">44/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested map #2: Keep only… (non-ideal specification)</h3><div class="side-by-side-container"><div class="side-by-side"><div>…collections from the data</div><pre><code>[{:path [], :value {:x 42, :y {:z "abc"}}}
 {:path [:y], :value {:z "abc"}}]</code></pre></div><div class="side-by-side"><div class="vspace"></div><div class="vspace"></div><div class="vspace"></div><div>…predicates from the specification</div><pre><code>[{:path [:y], :value map?}]</code></pre></div></div><div class="note"></div><div class="panel-footer"><span class="panel-number">45/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested map #3: Pair collections with predicates (non-ideal specification)</h3><div class="side-by-side-container"><div class="side-by-side"><div>paths of collections in data</div><pre><code>[]</code></pre><pre><code>[:y]</code></pre></div><div class="side-by-side"><div>path of predicate in specification</div><pre><code class="form">(drop-last [:y])</code><br><code class="eval">;; => ()</code></pre><div class="vspace"></div><pre><code class="form">(= [] (drop-last [:y]))</code><br><code class="eval">;; => true</code></pre></div></div><div class="vspace"></div><p>Motto #3: Ignore un-paired collections and un-paired predicates.</p><div class="note"></div><div class="panel-footer"><span class="panel-number">46/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested map #4: Apply predicates (non-ideal specification)</h3><pre><code class="form">(map? {:x 42, :y {:z "abc"}})</code><br><code class="eval">;; => true</code></pre><div class="note"></div><div class="panel-footer"><span class="panel-number">47/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Collection validation: nested map (non-ideal specification)</h3><pre><code class="form">(validate-collections {:x 42, :y {:z "abc"}}
                      {:y map?})</code><br><code class="eval">;; => ({:datum {:x 42, :y {:z "abc"}},
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [:y],
;;      :predicate map?,
;;      :valid? true})</code></pre><div class="vspace"></div><p>What if we'd wanted to validate <code>{:z "abc"}</code>?</p><p>To specify that nested map, we'd need…</p><pre><code class="form">(drop-last [:y :baz])</code><br><code class="eval">;; => (:y)</code></pre><p>…but…</p><pre><code>{:y map? :y {:baz set?}} ;; => java.lang.IllegalArgumentException; Duplicate key: :y</code></pre><div class="note"></div><div class="panel-footer"><span class="panel-number">48/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested map, better specification</h3><table><tr><td>data</td><td><pre><code>{:x 42 :y {:z "abc"}}</code></pre></td></tr><tr><td>predicate</td><td><pred><code>map?</code></pred></td></tr><tr><td><div class="vspace"></div></td></tr><tr><td>specification</td><td><pre><code>{:x 42     :y {:z "abc" }} ;; copy-paste data</code></pre><pre><code>{          :y {         }} ;; remove scalars</code></pre><pre><code>{:foo map? :y {:bar set?}} ;; insert predicates</code></pre></td></tr></table><div class="panel-footer"><span class="panel-number">49/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested map, better specification</h3><div class="side-by-side-container"><div class="side-by-side"><div>Paths of collections</div><pre><code>[]</code><br><code>[:y]</code></pre></div><div class="side-by-side"><div>Paths of predicates</div><pre><code>[:foo]</code></pre><pre><code class="form">(drop-last [:foo])</code><br><code class="eval">;; => ()</code></pre><div class="vspace"></div><pre><code>[:y :bar]</code></pre><pre><code class="form">(drop-last [:y :bar])</code><br><code class="eval">;; => (:y)</code></pre></div></div><pre><pre><code class="form">(map? {:x 42, :y {:z "abc"}})</code><br><code class="eval">;; => true</code></pre><br><pre><code class="form">(set? {:z "abc"})</code><br><code class="eval">;; => false</code></pre></pre><div class="note"></div><div class="panel-footer"><span class="panel-number">50/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating nested map, better specification</h3><pre><code class="form">(validate-collections {:x 42, :y {:z "abc"}}
                      {:foo map?, :y {:bar set?}})</code><br><code class="eval">;; => ({:datum {:x 42, :y {:z "abc"}},
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [:foo],
;;      :predicate map?,
;;      :valid? true}
;;     {:datum {:z "abc"},
;;      :ordinal-path-datum [:y],
;;      :path-datum [:y],
;;      :path-predicate [:y :bar],
;;      :predicate set?,
;;      :valid? false})</code></pre><div class="vspace"></div><p>Predicates at <code>[:foo]</code> and <code>[:y :bar]</code> don't interfere.</p><div class="note"></div><div class="panel-footer"><span class="panel-number">51/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Using informative keywords in specifications</h3><pre><code>{:foo       map? :y {:bar       set?}}</code><br><code>{:is-a-map? map? :y {:is-a-set? set?}}</code></pre><div class="vspace"></div><pre><code class="form">(validate-collections {:x 42, :y {:z "abc"}}
                      {:is-a-map? map?, :y {:is-a-set? set?}})</code><br><code class="eval">;; => ({:datum {:x 42, :y {:z "abc"}},
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [:is-a-map?],
;;      :predicate map?,
;;      :valid? true}
;;     {:datum {:z "abc"},
;;      :ordinal-path-datum [:y],
;;      :path-datum [:y],
;;      :path-predicate [:y :is-a-set?],
;;      :predicate set?,
;;      :valid? false})</code></pre><div class="note"><p>The keywords don't have any functional affect, so we might name them something informative to a human. But beware!</p></div><div class="panel-footer"><span class="panel-number">52/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Using mis-leading keywords in specifications</h3><pre><code>{:is-a-map? map?   }</code><br><code>{:is-a-map? <strong>vector?</strong>}</code></pre><div class="vspace"></div><pre><code class="form">(validate-collections {:x 42}
                      {:is-a-map? vector?})</code><br><code class="eval">;; => ({:datum {:x 42},
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [:is-a-map?],
;;      :predicate vector?,
;;      :valid? false})</code></pre><div class="note"><p>If the key purports to carry meaning to a human, it might be _mis_leading.</p><p>Speculoos makes zero effort to inspect the key. In fact, it drops the key on the floor and ignores it.</p><p>It's our responsibility to write a proper predicate.</p></div><div class="panel-footer"><span class="panel-number">53/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>What's next.</h3><ol class="de-highlight whats-next"><li>Introduction</li><li>Mechanics</li><li>Validating Scalars</li><li>Validating Collections, Basics</li><li class="highlight">Validating Collections, Advanced</li><li>Validating Collections, Extras</li><li>Validation Summaries & Thoroughness</li><li>Function Validation</li><li>Generating Random Samples & Exercising</li><li>Utilities</li><li>Predicates</li><li>Non-Terminating Sequences</li><li>Sets</li><li>Troubleshooting</li><li>Comparing spec.alpha to Speculoos</li><li>Perhaps So</li><li>Case Study</li></ol><div class="note"><p>We've just now covered the basics of collection validation. The next screencast will explore some of the nuances of how predicates apply to their parent containers, and why 'any'-and-all predicates apply.</p></div><div class="panel-footer"><span class="panel-number">54/54</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><p id="page-footer">Copyright © 2024 Brad Losavio.<br>Compiled 2024 December 02.<div class="license"><p>This program and the accompanying materials are made available under the terms of the <a href="https://opensource.org/license/MIT">MIT License</a>.</p></div><span id="uuid"><br>f7ab1ff8-766b-4e56-b47a-3aa10010a29a</span></p></body></head></html>