<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.6.0">
    <meta charset="utf-8" compile-date="2024-12-12 09:39:27" content="width=device-width, initial-scale=1" name="viewport">
    <link href="screedcast.css" rel="stylesheet" type="text/css">
    <script src="jquery-3.7.1.min.js" type="text/javascript"></script>
    <script src="screedcast.js" type="text/javascript"></script>
    <title>
      Speculoos — An experimental Clojure data validation library
    </title>
  </head>
  <body>
    <div class="panel">
      <div class="panel-header"></div>
      <h1>
        Speculoos Screencast 9 — Generating Random Samples and Exercising
      </h1>
      <p>
        Quick demo of built-ins
      </p>
      <pre><code>(require '[speculoos.utility :refer [data-from-spec]])</code></pre>
      <pre><code class="form">(data-from-spec [int? string? keyword?] :random)</code><br><code class="eval">;; =&gt; [567 "F" :_EGJ]</code></pre>
      <div class="note">
        <p>
          Before we have some fun with random samples, we must create random sample generators and put them where Speculoos can find them. Random sample
          generators are closely related to predicates.
        </p>
        <ul>
          <li>A predicate is a thing that can answer <em>Is the value you put in my hand an even, positive integer between ninety and one-hundred?</em>
          </li>
          <li>A random sample generator is a thing that says <em>I'm putting in your hand an even, positive integer between ninety and one-hundred.</em>
          </li>
        </ul>
        <p>
          Starting with a quick demonstration, Speculoos can generate valid data when given a scalar specification.
        </p>
        <p>
          When dealing with the basic <code>clojure.core</code> predicates, such as <code>int?</code>, <code>string?</code>, <code>keyword?</code>, etc.,
          Speculoos provides pre-made random sample generators that satisfy those predicates. (There are a few exceptions, due to the fact that there is not a
          one-to-one-to-one correspondence between scalar data types, <code>clojure.core</code> predicates, and <code>clojure.test.check</code> generators.)
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">1/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Samples of predicate-like things
      </h3>
      <ul>
        <li>basic predicate
        </li>
        <li>regex
        </li>
        <li>set
        </li>
      </ul>
      <div class="vspace"></div>
      <pre><code class="form">(data-from-spec {:x int?, :y #"fo{3,6}bar", :z #{:red :green :blue}} :random)</code><br><code class=
      "eval">;; =&gt; {:x 678, :y "foooooobar", :z :red}</code></pre>
      <div class="note">
        <p>
          Speculoos can also generate random scalar samples from predicate-like things, such as regular expressions and sets.
        </p>
        <p>
          When we use either a 'basic' scalar predicate, such as <code>int?</code>, a regex, or a set-as-a-predicate, Speculoos should know how to generate a
          valid random sample that satisfies that predicate-like thing. Within the context of generating samples or exercising, basic predicate
          <code>int?</code> elicits an integer, regular expression <code>#fo{3,6}</code> generates a valid string, and set-as-a-predicate <code>#{:red :green
          :blue}</code> emits a sample randomly drawn from that set.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">2/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Creating Random Sample Generators: <code>clojure.test.check</code>
      </h3>
      <pre><code>(require '[clojure.test.check.generators :as gen])</code></pre>
      <div class="vspace"></div>
      <pre><code class="form">(gen/generate (gen/large-integer* {:min 700, :max 999}))</code><br><code class="eval">;; =&gt; 707</code></pre>
      <div class="vspace"></div>
      <pre><code class="form">(gen/generate gen/keyword)</code><br><code class="eval">;; =&gt; :g!?</code></pre>
      <div class="vspace"></div>
      <pre><code class="form">(gen/generate gen/string-alphanumeric)</code><br><code class="eval">;; =&gt; "Qck"</code></pre>
      <div class="note">
        <p>
          During our screencasts, we've been using 'basic' predicates like <code>int?</code> and <code>string?</code> because they're short to type and
          straightforward to understand. In real life, we'll want to specify our data with more precision. Instead of merely <em>An integer</em>, we'll often
          want to express <em>An even positive integer between ninety and one-hundred.</em> To do that, we need to create custom generators.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">3/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Sample generator to complement a predicate
      </h3>
      <p>
        Let's make an <em>Integer in the nineties.</em>
      </p>
      <pre><code>(fn [n] (and (int? n) (&lt;= 90 n 99)))</code></pre>
      <div class="vspace"></div>
      <pre><code class="form">(gen/sample (gen/large-integer* {:min 90, :max 99}))</code><br><code class=
      "eval">;; =&gt; (91 90 91 91 91 96 90 94 96 90)</code></pre>
      <div class="vspace"></div>
      <pre><code class="form">(gen/generate (gen/large-integer* {:min 90, :max 99}))</code><br><code class="eval">;; =&gt; 96</code></pre>
      <div class="note">
        <p>
          The custom generators we discussed in the previous subsection are merely floating around in the ether. To use them for exercising, we need to put
          those generators in a spot that Speculoos knows: the predicate's metadata.
        </p>
        <p>
          Let's imagine a scenario. We want a predicate that specifies an integer between ninety (inclusive) and one-hundred (exclusive) and a corresponding
          random sample generator. First, we write the predicate, something like this.
        </p>
        <p>
          Second, we write our generator.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">4/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Making sample generator invocable
      </h3>
      <pre><code>(defn generate-nineties
  []
  (gen/generate (gen/large-integer* {:min 90, :max 99})))</code></pre>
      <div class="vspace"></div>
      <pre><code class="form">(generate-nineties)</code><br><code class="eval">;; =&gt; 95</code></pre>
      <div class="note">
        <p>
          To make the generator invocable, we'll wrap it in a function.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">5/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Associating a sample generator to a predicate, in…the metadata.
      </h3>
      <pre><code>(def nineties?
  (with-meta (fn [n] (and (int? n) (&lt;= 90 n 99)))
    {:speculoos/predicate-&gt;generator generate-nineties}))</code></pre>
      <div class="vspace"></div>
      <pre><code class="form">(nineties? 92)</code><br><code class="eval">;; =&gt; true</code></pre>
      <div class="vspace"></div>
      <pre><code class="form">(meta nineties?)</code><br><code class="eval">;; =&gt; #:speculoos{:predicate-&gt;generator generate-nineties}</code></pre>
      <div class="note">
        <p>
          Third, we need to associate that generator into the predicate's metadata. We have a couple of options. The manual option uses <code>with-meta</code>
          during binding a name to the function body. We'll associate <code>generate-nineties</code> to the predicate's <a href=
          "#recognized-metadata-keys">metadata key</a> <code>:speculoos/predicate-&gt;generator</code>.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">6/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Associating a sample generator while defining a predicate
      </h3>
      <pre><code>(require '[speculoos.utility :refer [defpred]])</code></pre>
      <div class="vspace"></div>
      <pre><code>(defpred NINEties? (fn [n] (and (int? n) (&lt;= 90 n 99))) generate-nineties)</code></pre>
      <div class="vspace"></div>
      <pre><code class="form">(NINEties? 97)</code><br><code class="eval">;; =&gt; true</code></pre>
      <div class="vspace"></div>
      <pre><code class="form">(meta NINEties?)</code><br><code class="eval">;; =&gt; #:speculoos{:canonical-sample :NINEties?-canonical-sample,
;;                :predicate-&gt;generator generate-nineties}</code></pre>
      <div class="note">
        <p>
          That gets the job done, but the manual option is kinda cluttered. The other option involves a Speculoos utility, <code>defpred</code>, that
          <strong>def</strong>ines a <strong>pred</strong>icate much the same as <code>defn</code>, but associates the generator with less keyboarding than the
          <code>with-meta</code> option. Supply a symbol, a predicate function body, and a random sample generator.
        </p>
        <p>
          <code>defpred</code> automatically puts <code>generate-nineties</code> into the predicate <code>NINEties?</code> metadata. <a href=
          "#auto-sample">Soon</a>, we'll discuss another couple of benefits to using <code>defpred</code>. Whichever way we accomplished getting the generator
          into the metadata at <code>:speculoos/predicate-&gt;generator</code>, Speculoos can now find it.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">7/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Aside: Metadata for two different purposes
      </h3>
      <ul>
        <li>
          <p>
            Store <em>function specifications</em> in the metadata for that function.
          </p>
          <p>
            Example: argument-return relationship,<code>equal-lengths?</code> for a <code>reverse</code> function
          </p>
        </li>
        <li>
          <p>
            Store <em>random sample generators</em> in the metadata for that predicate.
          </p>
          <p>
            Example: random sample generator <code>generate-nineties</code> in the metadata for predicate <code>nineties?</code>
          </p>
        </li>
      </ul>
      <div class="note">
        <p>
          Speculoos uses function metadata for two purposes, and it's important to keep clear in our minds which is which.
        </p>
        <p>
          fn spec associated to :speculoos/argument-return-relationship
        </p>
        <p>
          generator associated to :speculoos/predicate-&gt;generator
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">8/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Creating Sample Generators Automatically
      </h3>
      <pre><code>(defpred auto-nineties? (fn [n] (and (int? n) (&lt;= 90 n 99))))</code></pre>
      <div class="vspace"></div>
      <pre><code class="form">(meta auto-nineties?)</code><br><code class="eval">;; =&gt; #:speculoos{:canonical-sample :auto-nineties?-canonical-sample,
                  :predicate-&gt;generator #fn--88795}</code></pre>
      <div class="vspace"></div>
      <pre><code class="form">(binding [speculoos.utility/*such-that-max-tries* 1000]
  (let [possible-gen-90 (:speculoos/predicate-&gt;generator (meta auto-nineties?))]
    (possible-gen-90)))</code><br><code class="eval">;; =&gt; 93</code></pre>
      <div class="note">
        <p>
          <code>defpred</code> does indeed relieve us of some tedious keyboarding, but it offers another benefit. If we arrange the predicate definition
          according to <code>defpred</code>'s expectations, it can automatically create a random sample generator for that predicate. Let's see it in action
          and then we'll examine the details.
        </p>
        <p>
          Well, there's certainly <em>something</em> at <code>:speculoos/predicate-&gt;generator</code>, but is it anything useful?
        </p>
        <p>
          Yup! Since it is not-so-likely that a random integer generator would produce a value in the nineties, we bound the <code>max-tries</code> to a high
          count to give the generator lots of attempts. We then pulled out the generator from predicate <code>auto-nineties?</code>'s metadata and bound it to
          <code>possible-gen-90</code>. Then we invoked <code>possible-gen-90</code> and, in fact, it generated an integer in the nineties that satisfies the
          original predicate we defined as <code>auto-nineties</code>.<code>defpred</code> automatically created a random sample generator whose output
          satisfies the predicate.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">9/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Requirements for automatic sample generators
      </h3>
      <ul>
        <li>Access to textual representation of definition
        </li>
        <li>First symbol must be <code>and</code>, <code>or</code>, or a basic predicate
          <pre><code>(and (...)) ;; okay</code><br><code>(or (...))  ;; okay</code><br><code>(int? ...)  ;; okay</code><br><code>(let ...)   ;; not okay</code><br></pre>
        </li>
        <li>First clause after <code>and</code> and all immediate descendants of <code>or</code> must start with a basic predicate
        </li>
      </ul>
      <div class="note">
        <p>
          For <code>defpred</code> to do its magic, the predicate definition must follow a few patterns.
        </p>
        <p>
          Subsequent clauses of <code>and</code> will be used to create <code>test.check.generators/such-that</code> modifiers. Direct descendants of a
          top-level <code>or</code> will produce<code>n</code> separate random sample generators, each with <code>1/n</code> probability.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">10/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Inspecting automatic sample generator #1: basic predicate
      </h3>
      <pre><code>(require '[speculoos.utility :refer [inspect-fn]])</code></pre>
      <div class="vspace"></div>
      <pre><code class="form">(inspect-fn '(fn [i] (int? i)))</code><br><code class="eval">;; =&gt; gen/small-integer <output elided="" for="" brevity=
      ""></output></code><output elided="" for="" brevity=""></output></pre>
      <div class="note">
        <output elided="" for="" brevity=""></output>
        <p>
          <output elided="" for="" brevity="">Speculoos exposes the internal tool <code>defpred</code> uses to create a generator, so we can inspect how it
          works. (I've lightly edited the output for clarity.)</output>
        </p>
        <p>
          <output elided="" for="" brevity="">We learn that <code>inspect-fn</code> examines the textual representation of the predicate definition, extracts
          <code>int?</code> and infers that the base generator ought to be <code>gen/small-integer</code>.</output>
        </p>
      </div>
      <div class="panel-footer">
        <output elided="" for="" brevity=""><span class="panel-number">11/30</span><span class=
        "footer-link">https://github.com/blosavio/speculoos</span></output>
      </div>
    </div>
    <div class="panel">
      <output elided="" for="" brevity=""></output>
      <div class="panel-header">
        <output elided="" for="" brevity=""></output>
      </div>
      <h3>
        <output elided="" for="" brevity="">Inspecting automatic sample generator #2: <code>and</code> modifiers</output>
      </h3>
      <pre><output elided="" for="" brevity=""><code class="form">(inspect-fn '(fn [i] (and (int? i) (even? i) (pos? i))))</code><br><code class=
      "eval">;; =&gt; (gen/such-that (fn [i] (and (even? i) (pos? i)))
;;       gen/small-integer {:max-tries speculoos.utility/*such-that-max-tries*})  <output elided="" for="" brevity=""></output></code></output></pre>
      <div class="note">
        <output elided="" for="" brevity=""></output>
        <p>
          <output elided="" for="" brevity="">Next, we'll add a couple of modifiers with <code>and</code>. <code>int?</code> is in the first clause. (Again,
          lightly edited.)</output>
        </p>
        <p>
          <output elided="" for="" brevity=""><code>int?</code> elicits a small-integer generator. <code>inspect-fn</code> then uses the subsequent clauses of
          the <code>and</code> expression to create a <code>such-that</code> modifier that generates only positive, even numbers.</output>
        </p>
      </div>
      <div class="panel-footer">
        <output elided="" for="" brevity=""><span class="panel-number">12/30</span><span class=
        "footer-link">https://github.com/blosavio/speculoos</span></output>
      </div>
    </div>
    <div class="panel">
      <output elided="" for="" brevity=""></output>
      <div class="panel-header">
        <output elided="" for="" brevity=""></output>
      </div>
      <h3>
        <output elided="" for="" brevity="">Inspecting automatic sample generator #3: <code>or</code> alternatives</output>
      </h3>
      <pre><output elided="" for="" brevity=""><code class="form">(inspect-fn '(fn [x] (or (int? x) (string? x))))</code><br><code class=
      "eval">;; =&gt; (gen/one-of [gen/small-integer gen/string-alphanumeric]) <output elided="" for="" brevity=""></output></code></output></pre>
      <div class="note">
        <output elided="" for="" brevity=""></output>
        <p>
          <output elided="" for="" brevity="">Let's see what happens with an <code>or</code>.</output>
        </p>
        <p>
          <output elided="" for="" brevity="">Our predicate definition is satisfied with either an integer or a string. <code>inspect-fn</code> therefore
          creates a generator that will produce either an integer or a string with equal probability.</output>
        </p>
      </div>
      <div class="panel-footer">
        <output elided="" for="" brevity=""><span class="panel-number">13/30</span><span class=
        "footer-link">https://github.com/blosavio/speculoos</span></output>
      </div>
    </div>
    <div class="panel">
      <output elided="" for="" brevity=""></output>
      <div class="panel-header">
        <output elided="" for="" brevity=""></output>
      </div>
      <h3>
        <output elided="" for="" brevity="">Inspecting automatic sample generator #4: <code>and/or</code> combos</output>
      </h3>
      <pre><output elided="" for="" brevity=""><code>(defpred combined-pred
         #(or (and (int? %) (odd? %))
              (and (string? %) (&lt;= 3 (count %)))
              (and (ratio? %) (&lt; 1/9 %))))</code></output></pre>
      <div class="vspace">
        <output elided="" for="" brevity=""></output>
      </div>
      <pre><output elided="" for="" brevity=""><code class="form">(data-from-spec {:a combined-pred,
                 :b combined-pred,
                 :c combined-pred,
                 :d combined-pred,
                 :e combined-pred,
                 :f combined-pred,
                 :g combined-pred,
                 :h combined-pred,
                 :i combined-pred}
                :random)</code><br><code class="eval">;; =&gt; {:a -15,
;;     :b 19/14,
;;     :c -29,
;;     :d "m19z6f9d2w5uTA5",
;;     :e 8/11,
;;     :f "t224",
;;     :g 3,
;;     :h -15,
;;     :i "0fB6ka44B2f3VNP0447lV"}</code></output></pre>
      <div class="note">
        <output elided="" for="" brevity=""></output>
        <p>
          <output elided="" for="" brevity="">When automatically creating random sample generators, <code>defpred</code> handles nesting up to two levels deep.
          Let's see how we might combine both <code>or</code> and <code>and</code>. We'll define a predicate that tests for either an odd integer, a string of
          at least three characters, or a ratio greater than one-ninth.</output>
        </p>
        <p>
          <output elided="" for="" brevity="">We're kinda abusing <code>data-from-spec</code> here to generate nine samples. Inferring from
          <code>combined-pred</code>'s predicate structure, <code>defpred</code>'s automatically-created random sample generator emits one of three elements
          with equal probability: an odd integer, a string of at least three characters, or a ratio greater than one-ninth. All we had to do was write the
          predicate; <code>defpred</code> wrote all three random sample generators.</output>
        </p>
      </div>
      <div class="panel-footer">
        <output elided="" for="" brevity=""><span class="panel-number">14/30</span><span class=
        "footer-link">https://github.com/blosavio/speculoos</span></output>
      </div>
    </div>
    <div class="panel">
      <output elided="" for="" brevity=""></output>
      <div class="panel-header">
        <output elided="" for="" brevity=""></output>
      </div>
      <h3>
        <output elided="" for="" brevity="">Testing Sample Generators Residing in Metadata: Incorrect generator</output>
      </h3>
      <pre><output elided="" for="" brevity=""><code>(require '[speculoos.utility :refer [validate-predicate-&gt;generator]])</code></output></pre>
      <div class="vspace">
        <output elided="" for="" brevity=""></output>
      </div>
      <pre><output elided="" for="" brevity=""><code>(defpred pred-with-incorrect-generator
         (fn [i] (int? i))
         #(gen/generate gen/ratio))</code></output></pre>
      <div class="vspace">
        <output elided="" for="" brevity=""></output>
      </div>
      <pre><output elided="" for="" brevity=""><code class="form">(validate-predicate-&gt;generator pred-with-incorrect-generator)</code><br><code class=
      "eval">;; =&gt; ([-18/23 false]
;;     [1/2 false]
;;     [-9/8 false]
;;     [6 true]
;;     [4/15 false]
;;     [17/9 false]
;;     [1/24 false])</code></output></pre>
      <div class="note">
        <output elided="" for="" brevity=""></output>
        <p>
          <output elided="" for="" brevity="">Some scenarios block us from using <code>defpred</code>'s automatic generators. We may not have access to the
          textual representation of the predicate definition. Or, sometimes we must hand-write a generator because a naive generator would be unlikely to find
          a satisfying value (e.g., a random number that must fall within a narrow range).</output>
        </p>
        <p>
          <output elided="" for="" brevity="">The Write-generator-then-Apply-to-metadata-then-Test loop can be tedious, so the <code>utility</code> namespace
          provides a tool to help. <code>validate-predicate-&gt;generator</code> accepts a predicate function we supply, extracts the random sample generator
          residing in its metadata, generates a sample, and then feeds that sample back into the predicate to see if it satisfies.</output>
        </p>
      </div>
      <div class="panel-footer">
        <output elided="" for="" brevity=""><span class="panel-number">15/30</span><span class=
        "footer-link">https://github.com/blosavio/speculoos</span></output>
      </div>
    </div>
    <div class="panel">
      <output elided="" for="" brevity=""></output>
      <div class="panel-header">
        <output elided="" for="" brevity=""></output>
      </div>
      <h3>
        <output elided="" for="" brevity="">Testing sample generators residing in metadata: Corrected generator</output>
      </h3>
      <pre><output elided="" for="" brevity=""><code>(defpred pred-with-good-generator
         (fn [i] (int? i))
         #(gen/generate gen/small-integer))</code></output></pre>
      <div class="vspace">
        <output elided="" for="" brevity=""></output>
      </div>
      <pre><output elided="" for="" brevity=""><code class="form">(validate-predicate-&gt;generator pred-with-good-generator)</code><br><code class=
      "eval">;; =&gt; ([27 true]
;;     [-21 true]
;;     [24 true]
;;     [19 true]
;;     [-26 true]
;;     [20 true]
;;     [21 true])</code></output></pre>
      <div class="note">
        <output elided="" for="" brevity=""></output>
        <p>
          <output elided="" for="" brevity="">We defined scalar predicate <code>pred-with-incorrect-generator</code> to require an integer, but, using
          <code>defpred</code>, we manually created a generator that emits ratio values. Each of the generated samples fails to satisfy the <code>int?</code>
          predicate.</output>
        </p>
        <p>
          <output elided="" for="" brevity="">With help from <code>validate-predicate-&gt;generator</code>, we can hop back and forth to adjust the hand-made
          generator.</output>
        </p>
        <p>
          <output elided="" for="" brevity="">In this particular case, we could have relied on <code>defpred</code> to <a href="#auto-sample">create a sample
          generator</a> for us.</output>
        </p>
      </div>
      <div class="panel-footer">
        <output elided="" for="" brevity=""><span class="panel-number">16/30</span><span class=
        "footer-link">https://github.com/blosavio/speculoos</span></output>
      </div>
    </div>
    <div class="panel">
      <output elided="" for="" brevity=""></output>
      <div class="panel-header">
        <output elided="" for="" brevity=""></output>
      </div>
      <h3>
        <output elided="" for="" brevity="">Do all predicates have a generator?</output>
      </h3>
      <pre><output elided="" for="" brevity=""><code>(require '[speculoos.utility :refer [unfindable-generators]])</code></output></pre>
      <div class="vspace">
        <output elided="" for="" brevity=""></output>
      </div>
      <pre><output elided="" for="" brevity=""><code class="form">(unfindable-generators [int? #{:red :green :blue} #"fo{2,5}"])</code><br><code class=
      "eval">;; =&gt; []</code></output></pre>
      <div class="note">
        <output elided="" for="" brevity=""></output>
        <p>
          <output elided="" for="" brevity="">Pretend somebody hands us a specification. It might be useful to know if we need to write a random sample
          generator for any of the predicates it contains, or if Speculoos can find a generator for all of them, either in the collection of known
          predicates-to-generators associations, or in the predicates' metadata. <code>unfindable-generators</code> tells us this information.</output>
        </p>
        <p>
          <output elided="" for="" brevity="">Let's compose a scalar specification containing <code>int?</code>, a set-as-a-predicate <code>#{:red :green
          :blue}</code>, and a regular expression <code>#"fo{2,5}"</code>.</output>
        </p>
      </div>
      <div class="panel-footer">
        <output elided="" for="" brevity=""><span class="panel-number">17/30</span><span class=
        "footer-link">https://github.com/blosavio/speculoos</span></output>
      </div>
    </div>
    <div class="panel">
      <output elided="" for="" brevity=""></output>
      <div class="panel-header">
        <output elided="" for="" brevity=""></output>
      </div>
      <h3>
        <output elided="" for="" brevity="">Some predicates do not have a generator.</output>
      </h3>
      <pre><output elided="" for="" brevity=""><code>(def a? (fn [] 'a))</code></output></pre>
      <pre><output elided="" for="" brevity=""><code>(def b? (fn [] 'b))</code></output></pre>
      <pre><output elided="" for="" brevity=""><code>(def c? (fn [] 'c))</code></output></pre>
      <div class="vspace">
        <output elided="" for="" brevity=""></output>
      </div>
      <pre><output elided="" for="" brevity=""><code class="form">(unfindable-generators [a? b? c?])</code><br><code class=
      "eval">;; =&gt; [{:path [0], :value a?}
;;     {:path [1], :value b?}
;;     {:path [2], :value c?}]</code></output></pre>
      <div class="note">
        <output elided="" for="" brevity=""></output>
        <p>
          <output elided="" for="" brevity="">Speculoos knows how to create random samples from all three of those predicate-like things, so
          <code>unfindable-generators</code> returns an empty vector, <em>nothing unfindable</em>. Now, let's make a scalar specification with three predicates
          that intentionally lack generators.</output>
        </p>
        <p>
          <output elided="" for="" brevity=""><code>unfindable-generators</code> informs us that if we had tried to do a task that <a href="#using-gen">uses a
          sample generator</a>, we'd have failed. With this knowledge, we could go back and add random sample generators to <code>a?</code>, <code>b?</code>,
          and <code>c?</code>.</output>
        </p>
      </div>
      <div class="panel-footer">
        <output elided="" for="" brevity=""><span class="panel-number">18/30</span><span class=
        "footer-link">https://github.com/blosavio/speculoos</span></output>
      </div>
    </div>
    <div class="panel">
      <output elided="" for="" brevity=""></output>
      <div class="panel-header">
        <output elided="" for="" brevity=""></output>
      </div>
      <h3>
        <output elided="" for="" brevity="">Using Sample Generators</output>
      </h3>
      <ul>
        <li>
          <output elided="" for="" brevity="">Create a heterogeneous, arbitrarily-nested data structure when given a scalar specification.</output>
        </li>
        <li>
          <output elided="" for="" brevity="">Exercise a scalar specification.</output>
        </li>
        <li>
          <output elided="" for="" brevity="">Exercise a function with a scalar specification.</output>
        </li>
      </ul>
      <div class="note">
        <output elided="" for="" brevity=""></output>
        <p>
          <output elided="" for="" brevity="">Speculoos can do three things with random sample generators.</output>
        </p>
        <p>
          <output elided="" for="" brevity="">The first, creating a valid set of data from a given scalar specification, provides the foundation of the later
          two exercising functions, so we'll begin with <code>data-from-spec</code>.</output>
        </p>
      </div>
      <div class="panel-footer">
        <output elided="" for="" brevity=""><span class="panel-number">19/30</span><span class=
        "footer-link">https://github.com/blosavio/speculoos</span></output>
      </div>
    </div>
    <div class="panel">
      <output elided="" for="" brevity=""></output>
      <div class="panel-header">
        <output elided="" for="" brevity=""></output>
      </div>
      <h3>
        <output elided="" for="" brevity="">Generating sample data from a specification: vector</output>
      </h3>
      <pre><output elided="" for="" brevity=""><code>(require '[speculoos.utility :refer [data-from-spec]])</code></output></pre>
      <div class="vspace">
        <output elided="" for="" brevity=""></output>
      </div>
      <pre><output elided="" for="" brevity=""><code class="form">(data-from-spec [int? ratio? double?] :random)</code><br><code class=
      "eval">;; =&gt; [-133 6/7 110.03125]</code></output></pre>
      <div class="note">
        <output elided="" for="" brevity=""></output>
        <p>
          <output elided="" for="" brevity="">Imagine we'd like to specify the scalars contained within a vector to be an integer, followed by a ratio,
          followed by a double-precision floating-point number. We've seen <a href="#scalar-validation">how to compose that scalar specification</a>. Let's
          give that scalar specification to <code>data-from-spec</code>.</output>
        </p>
        <p>
          <output elided="" for="" brevity="">That scalar specification contains three predicates, and each of those predicates targets a basic Clojure numeric
          type, so Speculoos automatically refers to <code>test.check</code>'s generators to produce a random sample.</output>
        </p>
      </div>
      <div class="panel-footer">
        <output elided="" for="" brevity=""><span class="panel-number">20/30</span><span class=
        "footer-link">https://github.com/blosavio/speculoos</span></output>
      </div>
    </div>
    <div class="panel">
      <output elided="" for="" brevity=""></output>
      <div class="panel-header">
        <output elided="" for="" brevity=""></output>
      </div>
      <h3>
        <output elided="" for="" brevity="">Generating sample data from a specification: map</output>
      </h3>
      <pre><output elided="" for="" brevity=""><code class="form">(data-from-spec {:x char?,
                 :y #{:red :green :blue},
                 :z #"fo{3,5}bar"}
                :random)</code><br><code class="eval">;; =&gt; {:x \O,
;;     :y :red,
;;     :z "fooobar"}</code></output></pre>
      <div class="note">
        <output elided="" for="" brevity=""></output>
        <p>
          <output elided="" for="" brevity="">Let's try another example. The scalar specification will be a map with three keys associated with predicates for
          a character, a set-as-a-predicate, and a regex-predicate.</output>
        </p>
        <p>
          <output elided="" for="" brevity="">Again, without any further assistance, <code>data-from-spec</code> knew how to find or create a random sample
          generator for each predicate in the scalar specification. <code>char?</code> targets a basic Clojure type, so it generated a random character. Sets
          in a scalar specification, in this context, are considered a membership predicate. The random sample generator is merely a random selection of one of
          the members. Finally, Speculoos regards a regular expression as a predicate for validating strings. <code>data-from-spec</code> consults the <a href=
          "https://github.com/weavejester/re-rand"><code>re-rand</code></a> library to generate a random string from the regular expression.</output>
        </p>
      </div>
      <div class="panel-footer">
        <output elided="" for="" brevity=""><span class="panel-number">21/30</span><span class=
        "footer-link">https://github.com/blosavio/speculoos</span></output>
      </div>
    </div>
    <div class="panel">
      <output elided="" for="" brevity=""></output>
      <div class="panel-header">
        <output elided="" for="" brevity=""></output>
      </div>
      <h3>
        <output elided="" for="" brevity="">When automatically-created generators won't work: custom generators</output>
      </h3>
      <pre><output elided="" for="" brevity=""><code>(defpred pos-even-int? (fn [i] (and (int? i) (pos? i) (even? i))))</code></output></pre>
      <div class="vspace">
        <output elided="" for="" brevity=""></output>
      </div>
      <pre><output elided="" for="" brevity=""><code class="form">(inspect-fn '(fn [s] (and (string? s) (= 3 (count s)))))</code><br><code class=
      "eval">;; =&gt; (gen/such-that (fn [s] (and (= 3 (count s)))) gen/string-alphanumeric) <output elided="" for="" brevity=
      ""></output></code></output></pre>
      <div class="vspace">
        <output elided="" for="" brevity=""></output>
      </div><output elided="" for="" brevity=""><em>automatically-created generator will likely fail</em></output>
      <pre><output elided="" for="" brevity=""><code>(defpred three-char-string?
         (fn [s] (and (string? s) (= 3 (count s))))
         #(clojure.string/join (gen/sample gen/char-alphanumeric 3)))</code></output></pre>
      <div class="note">
        <output elided="" for="" brevity=""></output>
        <p>
          <output elided="" for="" brevity="">If our scalar specification contains custom predicates, we'll have to provide a little more information. We'll
          make another scalar specification containing a positive, even integer…</output>
        </p>
        <p>
          <output elided="" for="" brevity="">…relying on <code>defpred</code>'s predicate inspection machinery to infer a generator. After making our
          <code>pos-even-int?</code> predicate, we'll make a predicate satisfied by a three-character string, <code>(fn [s] (and (string? s) (= 3 (count
          s))))</code>. The generator which <code>defpred</code> would create for that predicate is kinda naive.</output>
        </p>
        <p>
          <output elided="" for="" brevity="">That naive generator would produce random strings of random lengths until it found one exactly three characters
          long. It's possible it would fail to produce a valid value before hitting the <code>max-tries</code> limit. However, we can explicitly write a
          generator and attach it with <code>defpred</code>.</output>
        </p>
      </div>
      <div class="panel-footer">
        <output elided="" for="" brevity=""><span class="panel-number">22/30</span><span class=
        "footer-link">https://github.com/blosavio/speculoos</span></output>
      </div>
    </div>
    <div class="panel">
      <output elided="" for="" brevity=""></output>
      <div class="panel-header">
        <output elided="" for="" brevity=""></output>
      </div>
      <h3>
        <output elided="" for="" brevity="">Generating samples with custom generators</output>
      </h3>
      <pre><output elided="" for="" brevity=""><code class="form">(data-from-spec [pos-even-int? three-char-string?] :random)</code><br><code class=
      "eval">;; =&gt; [8 "1eB"]</code></output></pre>
      <div class="note">
        <output elided="" for="" brevity=""></output>
        <p>
          <output elided="" for="" brevity="">Now that we have two scalar predicates with custom sample generators — one created by <code>defpred</code>, one
          created by us — we'll bring them together into a single scalar specification and invoke <code>data-from-spec</code>.</output>
        </p>
      </div>
      <div class="panel-footer">
        <output elided="" for="" brevity=""><span class="panel-number">23/30</span><span class=
        "footer-link">https://github.com/blosavio/speculoos</span></output>
      </div>
    </div>
    <div class="panel">
      <output elided="" for="" brevity=""></output>
      <div class="panel-header">
        <output elided="" for="" brevity=""></output>
      </div>
      <h3>
        <output elided="" for="" brevity="">Sanity check: Sample generators versus their predicates</output>
      </h3>
      <pre><output elided="" for="" brevity=""><code class="form">(speculoos.core/valid-scalars? (data-from-spec [int? ratio? double?])
                               [int? ratio? double?])</code><br><code class="eval">;; =&gt; true</code></output></pre>
      <div class="note">
        <output elided="" for="" brevity=""></output>
        <p>
          <output elided="" for="" brevity=""><code>data-from-spec</code> generates a valid data set whose randomly-generated scalars satisfy the scalar
          specification. In fact, we can feed the generated data back into the specification and it ought to validate <code>true</code>.</output>
        </p>
      </div>
      <div class="panel-footer">
        <output elided="" for="" brevity=""><span class="panel-number">24/30</span><span class=
        "footer-link">https://github.com/blosavio/speculoos</span></output>
      </div>
    </div>
    <div class="panel">
      <output elided="" for="" brevity=""></output>
      <div class="panel-header">
        <output elided="" for="" brevity=""></output>
      </div>
      <h3>
        <output elided="" for="" brevity="">Exercising: Sample generators versus their predicates, multiple runs</output>
      </h3>
      <pre><output elided="" for="" brevity=""><code>(require '[speculoos.utility :refer [exercise]])</code></output></pre>
      <div class="vspace">
        <output elided="" for="" brevity=""></output>
      </div>
      <pre><output elided="" for="" brevity=""><code class="form">(exercise [int? ratio? double?])</code><br><code class=
      "eval">;; =&gt; ([[208 9/5 -0.03090222366154194] true]
;;     [[-607 4/5 0.7769775390625] true]
;;     [[829 2/3 -0.4351768493652344] true]
;;     [[-892 -3/4 -0.0] true]
;;     [[888 29/18 -249.6875] true]
;;     [[74 26/7 0.0093994140625] true]
;;     [[95 -23/19 -0.019192803563782945] true]
;;     [[785 -3/11 186.75] true]
;;     [[-590 -19/29 304.04052734375] true]
;;     [[464 2/31 0.06207275390625] true])</code></output></pre>
      <div class="note">
        <output elided="" for="" brevity=""></output>
        <p>
          <output elided="" for="" brevity="">Perhaps it would be nice to do that multiple times in a row: generate some random data from a specification and
          feed it back into the specification to see if it validates. Don't go off and write your own utility. Speculoos can <em>exercise</em> a scalar
          specification.</output>
        </p>
        <p>
          <output elided="" for="" brevity="">Ten times, <code>exercise</code> generated a vector containing an integer, ratio, and double-precision numbers,
          then performed a scalar validation using those random samples as the data and the original scalar specification. In each of those ten runs, we see
          that <code>exercise</code> generated valid, <code>true</code> data.</output>
        </p>
      </div>
      <div class="panel-footer">
        <output elided="" for="" brevity=""><span class="panel-number">25/30</span><span class=
        "footer-link">https://github.com/blosavio/speculoos</span></output>
      </div>
    </div>
    <div class="panel">
      <output elided="" for="" brevity=""></output>
      <div class="panel-header">
        <output elided="" for="" brevity=""></output>
      </div>
      <h3>
        <output elided="" for="" brevity="">Exercising functions</output>
      </h3>
      <pre><output elided="" for="" brevity=""><code>(defn sum-three [x y z] (+ x y z))</code></output></pre>
      <pre><output elided="" for="" brevity=""><code class=
      "form">(inject-specs! sum-three {:speculoos/arg-scalar-spec [int? ratio? double?]})</code><br><code class="eval">;; =&gt; nil</code></output></pre>
      <div class="vspace">
        <output elided="" for="" brevity=""></output>
      </div>
      <pre><output elided="" for="" brevity=""><code>(require '[speculoos.function-specs :refer [exercise-fn]])</code></output></pre>
      <pre><output elided="" for="" brevity=""><code class="form">(exercise-fn sum-three)</code><br><code class=
      "eval">;; =&gt; ([[381 -7/4 -0.33831143379211426] 378.9116885662079]
;;     [[841 5/22 2.26171875] 843.4889914772727]
;;     [[83 -11/25 0.015625] 82.575625]
;;     [[753 -16/11 -0.026631176471710205] 751.5188233689828]
;;     [[576 -7/6 -0.099609375] 574.7337239583333]
;;     [[-373 17/5 0.029065109440125525] -369.5709348905599]
;;     [[-239 7/5 5.0] -232.6]
;;     [[267 25/7 389.19921875] 659.7706473214287]
;;     [[781 -1/7 5.833539202809334] 786.6906820599522]
;;     [[-163 -5/12 0.03301159443799406] -163.38365507222872])</code></output></pre>
      <div class="note">
        <output elided="" for="" brevity=""></output>
        <p>
          <output elided="" for="" brevity="">So now we've seen that Speculoos can repeatedly generate random valid data from a scalar specification and run a
          validation of that random data. If we have injected an argument scalar specification into a function's metadata, Speculoos can repeatedly generate
          specification-satisfying arguments and repeatedly invoke that function.</output>
        </p>
        <p>
          <output elided="" for="" brevity="">We revisit our friend, <code>sum-three</code>, a function which accepts three numbers and sums them. That scalar
          specification we've been using mimics the shape of the argument sequence, so let's inject it into <code>sum-three</code>'s metadata.</output>
        </p>
        <p>
          <output elided="" for="" brevity=""><code>sum-three</code> is certainly capable of summing any three numbers we feed it, but just for fun, we specify
          that the arguments ought to be an integer, a ratio, and a double-precision number. Now that we've defined our function and added an argument scalar
          specification, let's exercise <code>sum-three</code>.</output>
        </p>
        <p>
          <output elided="" for="" brevity=""><code>int?</code>, <code>ratio?</code>, and <code>double?</code> all have built-in generators, so we didn't have
          to create any custom generators. <code>exercise-fn</code> extracted <code>sum-three</code>'s argument scalar specification, then, ten times,
          generated a data set from random sample generators, then invoked the function with those arguments.</output>
        </p>
      </div>
      <div class="panel-footer">
        <output elided="" for="" brevity=""><span class="panel-number">26/30</span><span class=
        "footer-link">https://github.com/blosavio/speculoos</span></output>
      </div>
    </div>
    <div class="panel">
      <output elided="" for="" brevity=""></output>
      <div class="panel-header">
        <output elided="" for="" brevity=""></output>
      </div>
      <h3>
        <output elided="" for="" brevity="">Built-in canonical samples: repeatable and pretty</output>
      </h3>
      <pre><output elided="" for="" brevity=""><code class="form">(data-from-spec {:x int?,
                 :y char?,
                 :z string?,
                 :w double?,
                 :q ratio?,
                 :v keyword?}
                :canonical)</code><br><code class="eval">;; =&gt; {:q 22/7,
;;     :v :kw,
;;     :w 1.0E32,
;;     :x 42,
;;     :y \c,
;;     :z "abc"}</code></output></pre>
      <div class="note">
        <output elided="" for="" brevity=""></output>
        <p>
          <output elided="" for="" brevity="">Sometimes it might be useful that a generated value be predictable. Perhaps we're writing documentation, or
          making a presentation, and we'd like the values to be aesthetically pleasing. Or, sometimes during development, it's nice to be able to quickly
          eyeball a known value.</output>
        </p>
        <p>
          <output elided="" for="" brevity="">Speculoos provides a canonical sample for many of Clojure's fundamental scalars when the relevant functions are
          invoked with the <code>:canonical</code> option. Here we use <code>data-from-spec</code> to illustrate the built-in canonical values of six of the
          basic scalars.</output>
        </p>
      </div>
      <div class="panel-footer">
        <output elided="" for="" brevity=""><span class="panel-number">27/30</span><span class=
        "footer-link">https://github.com/blosavio/speculoos</span></output>
      </div>
    </div>
    <div class="panel">
      <output elided="" for="" brevity=""></output>
      <div class="panel-header">
        <output elided="" for="" brevity=""></output>
      </div>
      <h3>
        <output elided="" for="" brevity="">Exercisers can use canonical samples</output>
      </h3>
      <pre><output elided="" for="" brevity=""><code class="form">(exercise [int? ratio? double?] :canonical)</code><br><code class=
      "eval">;; =&gt; ([[42 22/7 1.0E32] true])</code></output></pre>
      <div class="vspace">
        <output elided="" for="" brevity=""></output>
      </div>
      <pre><output elided="" for="" brevity=""><code class="form">(exercise-fn sum-three :canonical)</code><br><code class=
      "eval">;; =&gt; ([[42 22/7 1.0E32] 1.0E32])</code></output></pre>
      <div class="note">
        <output elided="" for="" brevity=""></output>
        <p>
          <output elided="" for="" brevity="">The two exercising functions, <code>exercise</code> and <code>exercise-fn</code> both accept the
          <code>:canonical</code> option, as well.</output>
        </p>
        <p>
          <output elided="" for="" brevity="">Since the canonical values don't vary, it doesn't make much sense to exercise more than once.</output>
        </p>
      </div>
      <div class="panel-footer">
        <output elided="" for="" brevity=""><span class="panel-number">28/30</span><span class=
        "footer-link">https://github.com/blosavio/speculoos</span></output>
      </div>
    </div>
    <div class="panel">
      <output elided="" for="" brevity=""></output>
      <div class="panel-header">
        <output elided="" for="" brevity=""></output>
      </div>
      <h3>
        <output elided="" for="" brevity="">Custom canonical samples for custom predicates</output>
      </h3>
      <pre><output elided="" for="" brevity=""><code>(defpred neg-odd-int?
         (fn [i] (and (int? i) (neg? i) (odd? i)))
         (constantly :ignored)
         -33)</code></output></pre>
      <pre><output elided="" for="" brevity=""><code>(defpred happy-string?
         (fn [s] (string? s))
         (constantly :ignored)
         "Hello Clojure!")</code></output></pre>
      <pre><output elided="" for="" brevity=""><code>(defpred pretty-number? (fn [n] (number? n)) (constantly :ignored) 123.456)</code></output></pre>
      <pre><output elided="" for="" brevity=""><code class="form">(data-from-spec [neg-odd-int? happy-string? pretty-number?] :canonical)</code><br><code class=
      "eval">;; =&gt; [-33 "Hello Clojure!" 123.456]</code></output></pre>
      <div class="note">
        <output elided="" for="" brevity=""></output>
        <p>
          <output elided="" for="" brevity="">Beyond the built-in canonical values, we can supply canonical values of our own choosing when we define a
          predicate. We can manually add the canonical values via <code>with-meta</code> or we can add a canonical value using <code>defpred</code> as an
          argument following a custom generator.</output>
        </p>
        <p>
          <output elided="" for="" brevity="">We see that <code>data-from-spec</code> found the custom canonical values for each of the three predicates:
          <code>-33</code> for <code>neg-odd-int?</code>, <code>"Hello Clojure!"</code> for <code>happy-string?</code>, and <code>123.456</code> for
          <code>pretty-number?</code>. Notice that <em>exercising</em> a function does not validate the arguments or returns. Function argument and return
          validation only occurs when we explicitly invoke <code>validate-fn-with</code>, <code>validate-fn</code>, or we intentionally instrument it.</output>
        </p>
      </div>
      <div class="panel-footer">
        <output elided="" for="" brevity=""><span class="panel-number">29/30</span><span class=
        "footer-link">https://github.com/blosavio/speculoos</span></output>
      </div>
    </div>
    <div class="panel">
      <output elided="" for="" brevity=""></output>
      <div class="panel-header">
        <output elided="" for="" brevity=""></output>
      </div>
      <h3>
        <output elided="" for="" brevity="">What's next.</output>
      </h3>
      <ol class="de-highlight whats-next">
        <li>
          <output elided="" for="" brevity="">Introduction</output>
        </li>
        <li>
          <output elided="" for="" brevity="">Mechanics</output>
        </li>
        <li>
          <output elided="" for="" brevity="">Validating Scalars</output>
        </li>
        <li>
          <output elided="" for="" brevity="">Validating Collections, Basics</output>
        </li>
        <li>
          <output elided="" for="" brevity="">Validating Collections, Advanced</output>
        </li>
        <li>
          <output elided="" for="" brevity="">Validating Collections, Extras</output>
        </li>
        <li>
          <output elided="" for="" brevity="">Validation Summaries & Thoroughness</output>
        </li>
        <li>
          <output elided="" for="" brevity="">Function Validation</output>
        </li>
        <li>
          <output elided="" for="" brevity="">Generating Random Samples & Exercising</output>
        </li>
        <li class="highlight">
          <output elided="" for="" brevity="">Utilities</output>
        </li>
        <li>
          <output elided="" for="" brevity="">Predicates</output>
        </li>
        <li>
          <output elided="" for="" brevity="">Non-Terminating Sequences</output>
        </li>
        <li>
          <output elided="" for="" brevity="">Sets</output>
        </li>
        <li>
          <output elided="" for="" brevity="">Troubleshooting</output>
        </li>
        <li>
          <output elided="" for="" brevity="">Comparing spec.alpha to Speculoos</output>
        </li>
        <li>
          <output elided="" for="" brevity="">Perhaps So</output>
        </li>
        <li>
          <output elided="" for="" brevity="">Case Study</output>
        </li>
      </ol>
      <div class="note">
        <output elided="" for="" brevity="">We've just seen a handful of functions that amplify the core validation functions with exercising. During our next
        screencast, we'll discuss some more utility functions that help using Speculoos day-to-day.</output>
      </div>
      <div class="panel-footer">
        <output elided="" for="" brevity=""><span class="panel-number">30/30</span><span class=
        "footer-link">https://github.com/blosavio/speculoos</span></output>
      </div>
    </div>
    <p id="page-footer">
      <output elided="" for="" brevity="">Copyright © 2024 Brad Losavio.<br>
      Compiled by <a href="https://github.com/blosavio/screedcast">Screedcast</a> on 2024 December 12.</output>
    </p>
    <div class="license">
      <output elided="" for="" brevity=""></output>
      <p>
        <output elided="" for="" brevity="">This program and the accompanying materials are made available under the terms of the <a href=
        "https://opensource.org/license/MIT">MIT License</a>.</output>
      </p>
    </div><output elided="" for="" brevity=""><span id="uuid"><br>
    af1affe5-9d7e-4adb-9593-543309993bad</span><br>
    <br></output>
  </body>
</html>
