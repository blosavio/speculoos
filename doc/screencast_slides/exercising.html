<!DOCTYPE html>
<html lang="en"><head><link href="speculoos_screencast.css" rel="stylesheet" type="text/css"><script src="jquery-3.7.1.min.js" type="text/javascript"></script><script src="speculoos_screencast.js" type="text/javascript"></script><title>Speculoos — An experimental Clojure lib for data specification</title><meta charset="utf-8" compile-date="2024-12-02 05:43:24" content="width=device-width, initial-scale=1" name="viewport"><body><div class="panel"><div class="panel-header"></div><h1>Speculoos Screencast 9 — Generating Random Samples and Exercising</h1><p>Quick demo of built-ins</p><pre><code>(require '[speculoos.utility :refer [data-from-spec]])</code></pre><pre><code class="form">(data-from-spec [int? string? keyword?] :random)</code><br><code class="eval">;; => [616 "2y6p31Z49qIxj0bv28PxVP8" :rn]</code></pre><div class="note"><p>Before we have some fun with random samples, we must create random sample generators and put them where Speculoos can find them. Random sample generators are closely related to predicates.</p><ul><li>A predicate is a thing that can answer <em>Is the value you put in my hand an even, positive integer between ninety and one-hundred?</em></li><li>A random sample generator is a thing that says <em>I'm putting in your hand an even, positive integer between ninety and one-hundred.</em></li></ul><p>Starting with a quick demonstration, Speculoos can generate valid data when given a scalar specification.</p><p>When dealing with the basic <code>clojure.core</code> predicates, such as <code>int?</code>, <code>string?</code>, <code>keyword?</code>, etc., Speculoos provides pre-made random sample generators that satisfy those predicates. (There are a few exceptions, due to the fact that there is not a one-to-one-to-one correspondence between scalar data types, <code>clojure.core</code> predicates, and <code>clojure.test.check</code> generators.)</p></div><div class="panel-footer"><span class="panel-number">1/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Samples of predicate-like things</h3><ul><li>basic predicate</li><li>regex</li><li>set</li></ul><div class="vspace"></div><pre><code class="form">(data-from-spec {:x int?, :y #"fo{3,6}bar", :z #{:red :green :blue}} :random)</code><br><code class="eval">;; => {:x 428, :y "foooobar", :z :green}</code></pre><div class="note"><p>Speculoos can also generate random scalar samples from predicate-like things, such as regular expressions and sets.</p><p>When we use either a 'basic' scalar predicate, such as <code>int?</code>, a regex, or a set-as-a-predicate, Speculoos should know how to generate a valid random sample that satisfies that predicate-like thing. Within the context of generating samples or exercising, basic predicate <code>int?</code> elicits an integer, regular expression <code>#fo{3,6}</code> generates a valid string, and set-as-a-predicate <code>#{:red :green :blue}</code> emits a sample randomly drawn from that set.</p></div><div class="panel-footer"><span class="panel-number">2/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Creating Random Sample Generators: <code>clojure.test.check</code></h3><pre><code>(require '[clojure.test.check.generators :as gen])</code></pre><div class="vspace"></div><pre><code class="form">(gen/generate (gen/large-integer* {:min 700, :max 999}))</code><br><code class="eval">;; => 903</code></pre><div class="vspace"></div><pre><code class="form">(gen/generate gen/keyword)</code><br><code class="eval">;; => :s</code></pre><div class="vspace"></div><pre><code class="form">(gen/generate gen/string-alphanumeric)</code><br><code class="eval">;; => "ZuQ55m5tTNQHF7Pr5NBAT1In"</code></pre><div class="note"><p>During our screencasts, we've been using 'basic' predicates like <code>int?</code> and <code>string?</code> because they're short to type and straightforward to understand. In real life, we'll want to specify our data with more precision. Instead of merely <em>An integer</em>, we'll often want to express <em>An even positive integer between ninety and one-hundred.</em> To do that, we need to create custom generators.</p></div><div class="panel-footer"><span class="panel-number">3/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Sample generator to complement a predicate</h3><p>Let's make an <em>Integer in the nineties.</em></p><pre><code>(fn [n] (and (int? n) (<= 90 n 99)))</code></pre><div class="vspace"></div><pre><code class="form">(gen/sample (gen/large-integer* {:min 90, :max 99}))</code><br><code class="eval">;; => (90 91 91 91 90 98 92 95 95 94)</code></pre><div class="vspace"></div><pre><code class="form">(gen/generate (gen/large-integer* {:min 90, :max 99}))</code><br><code class="eval">;; => 97</code></pre><div class="note"><p>The custom generators we discussed in the previous subsection are merely floating around in the ether. To use them for exercising, we need to put those generators in a spot that Speculoos knows: the predicate's metadata.</p><p>Let's imagine a scenario. We want a predicate that specifies an integer between ninety (inclusive) and one-hundred (exclusive) and a corresponding random sample generator. First, we write the predicate, something like this.</p><p>Second, we write our generator.</p></div><div class="panel-footer"><span class="panel-number">4/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Making sample generator invocable</h3><pre><code>(defn generate-nineties
  []
  (gen/generate (gen/large-integer* {:min 90, :max 99})))</code></pre><div class="vspace"></div><pre><code class="form">(generate-nineties)</code><br><code class="eval">;; => 98</code></pre><div class="note"><p>To make the generator invocable, we'll wrap it in a function.</p></div><div class="panel-footer"><span class="panel-number">5/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Associating a sample generator to a predicate, in…the metadata.</h3><pre><code>(def nineties?
  (with-meta (fn [n] (and (int? n) (<= 90 n 99)))
    {:speculoos/predicate->generator generate-nineties}))</code></pre><div class="vspace"></div><pre><code class="form">(nineties? 92)</code><br><code class="eval">;; => true</code></pre><div class="vspace"></div><pre><code class="form">(meta nineties?)</code><br><code class="eval">;; => #:speculoos{:predicate->generator generate-nineties}</code></pre><div class="note"><p>Third, we need to associate that generator into the predicate's metadata. We have a couple of options. The manual option uses <code>with-meta</code> during binding a name to the function body. We'll associate <code>generate-nineties</code> to the predicate's <a href="#recognized-metadata-keys">metadata key</a> <code>:speculoos/predicate->generator</code>.</p></div><div class="panel-footer"><span class="panel-number">6/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Associating a sample generator while defining a predicate</h3><pre><code>(require '[speculoos.utility :refer [defpred]])</code></pre><div class="vspace"></div><pre><code>(defpred NINEties? (fn [n] (and (int? n) (<= 90 n 99))) generate-nineties)</code></pre><div class="vspace"></div><pre><code class="form">(NINEties? 97)</code><br><code class="eval">;; => true</code></pre><div class="vspace"></div><pre><code class="form">(meta NINEties?)</code><br><code class="eval">;; => #:speculoos{:canonical-sample :NINEties?-canonical-sample,
;;                :predicate->generator generate-nineties}</code></pre><div class="note"><p>That gets the job done, but the manual option is kinda cluttered. The other option involves a Speculoos utility, <code>defpred</code>, that <strong>def</strong>ines a <strong>pred</strong>icate much the same as <code>defn</code>, but associates the generator with less keyboarding than the <code>with-meta</code> option. Supply a symbol, a predicate function body, and a random sample generator.</p><p><code>defpred</code> automatically puts <code>generate-nineties</code> into the predicate <code>NINEties?</code> metadata. <a href="#auto-sample">Soon</a>, we'll discuss another couple of benefits to using <code>defpred</code>. Whichever way we accomplished getting the generator into the metadata at <code>:speculoos/predicate->generator</code>, Speculoos can now find it.</p></div><div class="panel-footer"><span class="panel-number">7/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Aside: Metadata for two different purposes</h3><ul><li><p>Store <em>function specifications</em> in the metadata for that function.</p><p>Example: argument-return relationship,<code>equal-lengths?</code> for a <code>reverse</code> function</p></li><li><p>Store <em>random sample generators</em> in the metadata for that predicate.</p><p>Example: random sample generator <code>generate-nineties</code> in the metadata for predicate <code>nineties?</code></p></li></ul><div class="note"><p>Speculoos uses function metadata for two purposes, and it's important to keep clear in our minds which is which.</p><p>fn spec associated to :speculoos/argument-return-relationship</p><p>generator associated to :speculoos/predicate->generator</p></div><div class="panel-footer"><span class="panel-number">8/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Creating Sample Generators Automatically</h3><pre><code>(defpred auto-nineties? (fn [n] (and (int? n) (<= 90 n 99))))</code></pre><div class="vspace"></div><pre><code class="form">(meta auto-nineties?)</code><br><code class="eval">;; => #:speculoos{:canonical-sample :auto-nineties?-canonical-sample,
                  :predicate->generator #fn--88795}</code></pre><div class="vspace"></div><pre><code class="form">(binding [speculoos.utility/*such-that-max-tries* 1000]
  (let [possible-gen-90 (:speculoos/predicate->generator (meta auto-nineties?))]
    (possible-gen-90)))</code><br><code class="eval">;; => 99</code></pre><div class="note"><p><code>defpred</code> does indeed relieve us of some tedious keyboarding, but it offers another benefit. If we arrange the predicate definition according to <code>defpred</code>'s expectations, it can automatically create a random sample generator for that predicate. Let's see it in action and then we'll examine the details.</p><p>Well, there's certainly <em>something</em> at <code>:speculoos/predicate->generator</code>, but is it anything useful?</p><p>Yup! Since it is not-so-likely that a random integer generator would produce a value in the nineties, we bound the <code>max-tries</code> to a high count to give the generator lots of attempts. We then pulled out the generator from predicate <code>auto-nineties?</code>'s metadata and bound it to <code>possible-gen-90</code>. Then we invoked <code>possible-gen-90</code> and, in fact, it generated an integer in the nineties that satisfies the original predicate we defined as <code>auto-nineties</code>.<code>defpred</code> automatically created a random sample generator whose output satisfies the predicate.</p></div><div class="panel-footer"><span class="panel-number">9/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Requirements for automatic sample generators</h3><ul><li>Access to textual representation of definition</li><li>First symbol must be <code>and</code>, <code>or</code>, or a basic predicate<pre><code>(and (...)) ;; okay</code><br><code>(or (...))  ;; okay</code><br><code>(int? ...)  ;; okay</code><br><code>(let ...)   ;; not okay</code><br></pre></li><li>First clause after <code>and</code> and all immediate descendants of <code>or</code> must start with a basic predicate</li></ul><div class="note"><p>For <code>defpred</code> to do its magic, the predicate definition must follow a few patterns.</p><p>Subsequent clauses of <code>and</code> will be used to create <code>test.check.generators/such-that</code> modifiers. Direct descendants of a top-level <code>or</code> will produce<code>n</code> separate random sample generators, each with <code>1/n</code> probability.</p></div><div class="panel-footer"><span class="panel-number">10/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Inspecting automatic sample generator #1: basic predicate</h3><pre><code>(require '[speculoos.utility :refer [inspect-fn]])</code></pre><div class="vspace"></div><pre><code class="form">(inspect-fn '(fn [i] (int? i)))</code><br><code class="eval">;; => gen/small-integer <output elided for brevity></code></pre><div class="note"><p>Speculoos exposes the internal tool <code>defpred</code> uses to create a generator, so we can inspect how it works. (I've lightly edited the output for clarity.)</p><p>We learn that <code>inspect-fn</code> examines the textual representation of the predicate definition, extracts <code>int?</code> and infers that the base generator ought to be <code>gen/small-integer</code>.</p></div><div class="panel-footer"><span class="panel-number">11/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Inspecting automatic sample generator #2: <code>and</code> modifiers</h3><pre><code class="form">(inspect-fn '(fn [i] (and (int? i) (even? i) (pos? i))))</code><br><code class="eval">;; => (gen/such-that (fn [i] (and (even? i) (pos? i)))
;;       gen/small-integer {:max-tries speculoos.utility/*such-that-max-tries*})  <output elided for brevity></code></pre><div class="note"><p>Next, we'll add a couple of modifiers with <code>and</code>. <code>int?</code> is in the first clause. (Again, lightly edited.)</p><p><code>int?</code> elicits a small-integer generator. <code>inspect-fn</code> then uses the subsequent clauses of the <code>and</code> expression to create a <code>such-that</code> modifier that generates only positive, even numbers.</p></div><div class="panel-footer"><span class="panel-number">12/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Inspecting automatic sample generator #3: <code>or</code> alternatives</h3><pre><code class="form">(inspect-fn '(fn [x] (or (int? x) (string? x))))</code><br><code class="eval">;; => (gen/one-of [gen/small-integer gen/string-alphanumeric]) <output elided for brevity></code></pre><div class="note"><p>Let's see what happens with an <code>or</code>.</p><p>Our predicate definition is satisfied with either an integer or a string. <code>inspect-fn</code> therefore creates a generator that will produce either an integer or a string with equal probability.</p></div><div class="panel-footer"><span class="panel-number">13/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Inspecting automatic sample generator #4: <code>and/or</code> combos</h3><pre><code>(defpred combined-pred
         #(or (and (int? %) (odd? %))
              (and (string? %) (<= 3 (count %)))
              (and (ratio? %) (< 1/9 %))))</code></pre><div class="vspace"></div><pre><code class="form">(data-from-spec {:a combined-pred,
                 :b combined-pred,
                 :c combined-pred,
                 :d combined-pred,
                 :e combined-pred,
                 :f combined-pred,
                 :g combined-pred,
                 :h combined-pred,
                 :i combined-pred}
                :random)</code><br><code class="eval">;; => {:a 9/14,
;;     :b 25,
;;     :c 16/15,
;;     :d -27,
;;     :e "SRyQDus4A22V",
;;     :f "C8V",
;;     :g 14/29,
;;     :h 4/3,
;;     :i 14/33}</code></pre><div class="note"><p>When automatically creating random sample generators, <code>defpred</code> handles nesting up to two levels deep. Let's see how we might combine both <code>or</code> and <code>and</code>. We'll define a predicate that tests for either an odd integer, a string of at least three characters, or a ratio greater than one-ninth.</p><p>We're kinda abusing <code>data-from-spec</code> here to generate nine samples. Inferring from <code>combined-pred</code>'s predicate structure, <code>defpred</code>'s automatically-created random sample generator emits one of three elements with equal probability: an odd integer, a string of at least three characters, or a ratio greater than one-ninth. All we had to do was write the predicate; <code>defpred</code> wrote all three random sample generators.</p></div><div class="panel-footer"><span class="panel-number">14/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Testing Sample Generators Residing in Metadata: Incorrect generator</h3><pre><code>(require '[speculoos.utility :refer [validate-predicate->generator]])</code></pre><div class="vspace"></div><pre><code>(defpred pred-with-incorrect-generator
         (fn [i] (int? i))
         #(gen/generate gen/ratio))</code></pre><div class="vspace"></div><pre><code class="form">(validate-predicate->generator pred-with-incorrect-generator)</code><br><code class="eval">;; => ([-8/9 false]
;;     [28/9 false]
;;     [-14/23 false]
;;     [5/8 false]
;;     [4/13 false]
;;     [0 true]
;;     [22/15 false])</code></pre><div class="note"><p>Some scenarios block us from using <code>defpred</code>'s automatic generators. We may not have access to the textual representation of the predicate definition. Or, sometimes we must hand-write a generator because a naive generator would be unlikely to find a satisfying value (e.g., a random number that must fall within a narrow range).</p><p>The Write-generator-then-Apply-to-metadata-then-Test loop can be tedious, so the <code>utility</code> namespace provides a tool to help. <code>validate-predicate->generator</code> accepts a predicate function we supply, extracts the random sample generator residing in its metadata, generates a sample, and then feeds that sample back into the predicate to see if it satisfies.</p></div><div class="panel-footer"><span class="panel-number">15/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Testing sample generators residing in metadata: Corrected generator</h3><pre><code>(defpred pred-with-good-generator
         (fn [i] (int? i))
         #(gen/generate gen/small-integer))</code></pre><div class="vspace"></div><pre><code class="form">(validate-predicate->generator pred-with-good-generator)</code><br><code class="eval">;; => ([-1 true]
;;     [27 true]
;;     [2 true]
;;     [29 true]
;;     [14 true]
;;     [3 true]
;;     [0 true])</code></pre><div class="note"><p>We defined scalar predicate <code>pred-with-incorrect-generator</code> to require an integer, but, using <code>defpred</code>, we manually created a generator that emits ratio values. Each of the generated samples fails to satisfy the <code>int?</code> predicate.</p><p>With help from <code>validate-predicate->generator</code>, we can hop back and forth to adjust the hand-made generator.</p><p>In this particular case, we could have relied on <code>defpred</code> to <a href="#auto-sample">create a sample generator</a> for us.</p></div><div class="panel-footer"><span class="panel-number">16/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Do all predicates have a generator?</h3><pre><code>(require '[speculoos.utility :refer [unfindable-generators]])</code></pre><div class="vspace"></div><pre><code class="form">(unfindable-generators [int? #{:red :green :blue} #"fo{2,5}"])</code><br><code class="eval">;; => []</code></pre><div class="note"><p>Pretend somebody hands us a specification. It might be useful to know if we need to write a random sample generator for any of the predicates it contains, or if Speculoos can find a generator for all of them, either in the collection of known predicates-to-generators associations, or in the predicates' metadata. <code>unfindable-generators</code> tells us this information.</p><p>Let's compose a scalar specification containing <code>int?</code>, a set-as-a-predicate <code>#{:red :green :blue}</code>, and a regular expression <code>#"fo{2,5}"</code>.</p></div><div class="panel-footer"><span class="panel-number">17/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Some predicates do not have a generator.</h3><pre><code>(def a? (fn [] 'a))</code></pre><pre><code>(def b? (fn [] 'b))</code></pre><pre><code>(def c? (fn [] 'c))</code></pre><div class="vspace"></div><pre><code class="form">(unfindable-generators [a? b? c?])</code><br><code class="eval">;; => [{:path [0], :value a?}
;;     {:path [1], :value b?}
;;     {:path [2], :value c?}]</code></pre><div class="note"><p>Speculoos knows how to create random samples from all three of those predicate-like things, so <code>unfindable-generators</code> returns an empty vector, <em>nothing unfindable</em>. Now, let's make a scalar specification with three predicates that intentionally lack generators.</p><p><code>unfindable-generators</code> informs us that if we had tried to do a task that <a href="#using-gen">uses a sample generator</a>, we'd have failed. With this knowledge, we could go back and add random sample generators to <code>a?</code>, <code>b?</code>, and <code>c?</code>.</p></div><div class="panel-footer"><span class="panel-number">18/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Using Sample Generators</h3><ul><li>Create a heterogeneous, arbitrarily-nested data structure when given a scalar specification.</li><li>Exercise a scalar specification.</li><li>Exercise a function with a scalar specification.</li></ul><div class="note"><p>Speculoos can do three things with random sample generators.</p><p>The first, creating a valid set of data from a given scalar specification, provides the foundation of the later two exercising functions, so we'll begin with <code>data-from-spec</code>.</p></div><div class="panel-footer"><span class="panel-number">19/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Generating sample data from a specification: vector</h3><pre><code>(require '[speculoos.utility :refer [data-from-spec]])</code></pre><div class="vspace"></div><pre><code class="form">(data-from-spec [int? ratio? double?] :random)</code><br><code class="eval">;; => [-341 2/9 0.03987203910946846]</code></pre><div class="note"><p>Imagine we'd like to specify the scalars contained within a vector to be an integer, followed by a ratio, followed by a double-precision floating-point number. We've seen <a href="#scalar-validation">how to compose that scalar specification</a>. Let's give that scalar specification to <code>data-from-spec</code>.</p><p>That scalar specification contains three predicates, and each of those predicates targets a basic Clojure numeric type, so Speculoos automatically refers to <code>test.check</code>'s generators to produce a random sample.</p></div><div class="panel-footer"><span class="panel-number">20/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Generating sample data from a specification: map</h3><pre><code class="form">(data-from-spec {:x char?,
                 :y #{:red :green :blue},
                 :z #"fo{3,5}bar"}
                :random)</code><br><code class="eval">;; => {:x \D,
;;     :y :green,
;;     :z "fooooobar"}</code></pre><div class="note"><p>Let's try another example. The scalar specification will be a map with three keys associated with predicates for a character, a set-as-a-predicate, and a regex-predicate.</p><p>Again, without any further assistance, <code>data-from-spec</code> knew how to find or create a random sample generator for each predicate in the scalar specification. <code>char?</code> targets a basic Clojure type, so it generated a random character. Sets in a scalar specification, in this context, are considered a membership predicate. The random sample generator is merely a random selection of one of the members. Finally, Speculoos regards a regular expression as a predicate for validating strings. <code>data-from-spec</code> consults the <a href="https://github.com/weavejester/re-rand"><code>re-rand</code></a> library to generate a random string from the regular expression.</p></div><div class="panel-footer"><span class="panel-number">21/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>When automatically-created generators won't work: custom generators</h3><pre><code>(defpred pos-even-int? (fn [i] (and (int? i) (pos? i) (even? i))))</code></pre><div class="vspace"></div><pre><code class="form">(inspect-fn '(fn [s] (and (string? s) (= 3 (count s)))))</code><br><code class="eval">;; => (gen/such-that (fn [s] (and (= 3 (count s)))) gen/string-alphanumeric) <output elided for brevity></code></pre><div class="vspace"></div><em>automatically-created generator will likely fail</em><pre><code>(defpred three-char-string?
         (fn [s] (and (string? s) (= 3 (count s))))
         #(clojure.string/join (gen/sample gen/char-alphanumeric 3)))</code></pre><div class="note"><p>If our scalar specification contains custom predicates, we'll have to provide a little more information. We'll make another scalar specification containing a positive, even integer…</p><p>…relying on <code>defpred</code>'s predicate inspection machinery to infer a generator. After making our <code>pos-even-int?</code> predicate, we'll make a predicate satisfied by a three-character string, <code>(fn [s] (and (string? s) (= 3 (count s))))</code>. The generator which <code>defpred</code> would create for that predicate is kinda naive.</p><p>That naive generator would produce random strings of random lengths until it found one exactly three characters long. It's possible it would fail to produce a valid value before hitting the <code>max-tries</code> limit. However, we can explicitly write a generator and attach it with <code>defpred</code>.</p></div><div class="panel-footer"><span class="panel-number">22/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Generating samples with custom generators</h3><pre><code class="form">(data-from-spec [pos-even-int? three-char-string?] :random)</code><br><code class="eval">;; => [2 "9qh"]</code></pre><div class="note"><p>Now that we have two scalar predicates with custom sample generators — one created by <code>defpred</code>, one created by us — we'll bring them together into a single scalar specification and invoke <code>data-from-spec</code>.</p></div><div class="panel-footer"><span class="panel-number">23/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Sanity check: Sample generators versus their predicates</h3><pre><code class="form">(speculoos.core/valid-scalars? (data-from-spec [int? ratio? double?])
                               [int? ratio? double?])</code><br><code class="eval">;; => true</code></pre><div class="note"><p><code>data-from-spec</code> generates a valid data set whose randomly-generated scalars satisfy the scalar specification. In fact, we can feed the generated data back into the specification and it ought to validate <code>true</code>.</p></div><div class="panel-footer"><span class="panel-number">24/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Exercising: Sample generators versus their predicates, multiple runs</h3><pre><code>(require '[speculoos.utility :refer [exercise]])</code></pre><div class="vspace"></div><pre><code class="form">(exercise [int? ratio? double?])</code><br><code class="eval">;; => ([[828 1/3 1.7495133876800537] true]
;;     [[395 -31/26 -58.701393127441406] true]
;;     [[-786 7/22 -6.764646530151367] true]
;;     [[-962 -7/6 ##Inf] true]
;;     [[-632 13/20 -16.0] true]
;;     [[-675 -7/3 1.583636213093996] true]
;;     [[293 5/13 0.00628662109375] true]
;;     [[407 -11/13 -0.0107421875] true]
;;     [[554 27/17 435.46100902557373] true]
;;     [[-49 3/11 3.8303709030151367] true])</code></pre><div class="note"><p>Perhaps it would be nice to do that multiple times in a row: generate some random data from a specification and feed it back into the specification to see if it validates. Don't go off and write your own utility. Speculoos can <em>exercise</em> a scalar specification.</p><p>Ten times, <code>exercise</code> generated a vector containing an integer, ratio, and double-precision numbers, then performed a scalar validation using those random samples as the data and the original scalar specification. In each of those ten runs, we see that <code>exercise</code> generated valid, <code>true</code> data.</p></div><div class="panel-footer"><span class="panel-number">25/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Exercising functions</h3><pre><code>(defn sum-three [x y z] (+ x y z))</code></pre><pre><code class="form">(inject-specs! sum-three {:speculoos/arg-scalar-spec [int? ratio? double?]})</code><br><code class="eval">;; => nil</code></pre><div class="vspace"></div><pre><code>(require '[speculoos.function-specs :refer [exercise-fn]])</code></pre><pre><code class="form">(exercise-fn sum-three)</code><br><code class="eval">;; => ([[950 25/31 -0.06390682887285948] 950.7425447840303]
;;     [[-249 -13/2 -69.103515625] -324.603515625]
;;     [[603 13/10 -0.7574310302734375] 603.5425689697265]
;;     [[-101 29/20 0.015594482421875] -99.53440551757812]
;;     [[594 13/15 422.7645311355591] 1017.6311978022258]
;;     [[696 8/9 -0.24168801307678223] 696.6472008758121]
;;     [[-360 -7/30 -0.45139822363853455] -360.6847315569718]
;;     [[583 -10/13 0.11328125] 582.3440504807692]
;;     [[-156 -25/13 106.16259765625] -51.760479266826906]
;;     [[769 20/29 0.21311795711517334] 769.902773129529])</code></pre><div class="note"><p>So now we've seen that Speculoos can repeatedly generate random valid data from a scalar specification and run a validation of that random data. If we have injected an argument scalar specification into a function's metadata, Speculoos can repeatedly generate specification-satisfying arguments and repeatedly invoke that function.</p><p>We revisit our friend, <code>sum-three</code>, a function which accepts three numbers and sums them. That scalar specification we've been using mimics the shape of the argument sequence, so let's inject it into <code>sum-three</code>'s metadata.</p><p><code>sum-three</code> is certainly capable of summing any three numbers we feed it, but just for fun, we specify that the arguments ought to be an integer, a ratio, and a double-precision number. Now that we've defined our function and added an argument scalar specification, let's exercise <code>sum-three</code>.</p><p><code>int?</code>, <code>ratio?</code>, and <code>double?</code> all have built-in generators, so we didn't have to create any custom generators. <code>exercise-fn</code> extracted <code>sum-three</code>'s argument scalar specification, then, ten times, generated a data set from random sample generators, then invoked the function with those arguments.</p></div><div class="panel-footer"><span class="panel-number">26/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Built-in canonical samples: repeatable and pretty</h3><pre><code class="form">(data-from-spec {:x int?,
                 :y char?,
                 :z string?,
                 :w double?,
                 :q ratio?,
                 :v keyword?}
                :canonical)</code><br><code class="eval">;; => {:q 22/7,
;;     :v :kw,
;;     :w 1.0E32,
;;     :x 42,
;;     :y \c,
;;     :z "abc"}</code></pre><div class="note"><p>Sometimes it might be useful that a generated value be predictable. Perhaps we're writing documentation, or making a presentation, and we'd like the values to be aesthetically pleasing. Or, sometimes during development, it's nice to be able to quickly eyeball a known value.</p><p>Speculoos provides a canonical sample for many of Clojure's fundamental scalars when the relevant functions are invoked with the <code>:canonical</code> option. Here we use <code>data-from-spec</code> to illustrate the built-in canonical values of six of the basic scalars.</p></div><div class="panel-footer"><span class="panel-number">27/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Exercisers can use canonical samples</h3><pre><code class="form">(exercise [int? ratio? double?] :canonical)</code><br><code class="eval">;; => ([[42 22/7 1.0E32] true])</code></pre><div class="vspace"></div><pre><code class="form">(exercise-fn sum-three :canonical)</code><br><code class="eval">;; => ([[42 22/7 1.0E32] 1.0E32])</code></pre><div class="note"><p>The two exercising functions, <code>exercise</code> and <code>exercise-fn</code> both accept the <code>:canonical</code> option, as well.</p><p>Since the canonical values don't vary, it doesn't make much sense to exercise more than once.</p></div><div class="panel-footer"><span class="panel-number">28/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Custom canonical samples for custom predicates</h3><pre><code>(defpred neg-odd-int?
         (fn [i] (and (int? i) (neg? i) (odd? i)))
         (constantly :ignored)
         -33)</code></pre><pre><code>(defpred happy-string?
         (fn [s] (string? s))
         (constantly :ignored)
         "Hello Clojure!")</code></pre><pre><code>(defpred pretty-number? (fn [n] (number? n)) (constantly :ignored) 123.456)</code></pre><pre><code class="form">(data-from-spec [neg-odd-int? happy-string? pretty-number?] :canonical)</code><br><code class="eval">;; => [-33 "Hello Clojure!" 123.456]</code></pre><div class="note"><p>Beyond the built-in canonical values, we can supply canonical values of our own choosing when we define a predicate. We can manually add the canonical values via <code>with-meta</code> or we can add a canonical value using <code>defpred</code> as an argument following a custom generator.</p><p>We see that <code>data-from-spec</code> found the custom canonical values for each of the three predicates: <code>-33</code> for <code>neg-odd-int?</code>, <code>"Hello Clojure!"</code> for <code>happy-string?</code>, and <code>123.456</code> for <code>pretty-number?</code>. Notice that <em>exercising</em> a function does not validate the arguments or returns. Function argument and return validation only occurs when we explicitly invoke <code>validate-fn-with</code>, <code>validate-fn</code>, or we intentionally instrument it.</p></div><div class="panel-footer"><span class="panel-number">29/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>What's next.</h3><ol class="de-highlight whats-next"><li>Introduction</li><li>Mechanics</li><li>Validating Scalars</li><li>Validating Collections, Basics</li><li>Validating Collections, Advanced</li><li>Validating Collections, Extras</li><li>Validation Summaries & Thoroughness</li><li>Function Validation</li><li>Generating Random Samples & Exercising</li><li class="highlight">Utilities</li><li>Predicates</li><li>Non-Terminating Sequences</li><li>Sets</li><li>Troubleshooting</li><li>Comparing spec.alpha to Speculoos</li><li>Perhaps So</li><li>Case Study</li></ol><div class="note">We've just seen a handful of functions that amplify the core validation functions with exercising. During our next screencast, we'll discuss some more utility functions that help using Speculoos day-to-day.</div><div class="panel-footer"><span class="panel-number">30/30</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><p id="page-footer">Copyright © 2024 Brad Losavio.<br>Compiled 2024 December 02.<span id="uuid"><br>af1affe5-9d7e-4adb-9593-543309993bad</span></p></body></head></html>