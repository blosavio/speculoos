<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.6.0">
    <meta charset="utf-8" compile-date="2024-12-11 09:38:58" content="width=device-width, initial-scale=1" name="viewport">
    <link href="screedcast.css" rel="stylesheet" type="text/css">
    <script src="jquery-3.7.1.min.js" type="text/javascript"></script>
    <script src="screedcast.js" type="text/javascript"></script>
    <title>
      Speculoos — An experimental Clojure data validation library
    </title>
  </head>
  <body>
    <div class="panel">
      <div class="panel-header"></div>
      <h1>
        Speculoos Screencast 16 — Perhaps So
      </h1>
      <h3>
        <em>How Speculoos addresses issues raised in '<a href="https://www.youtube.com/watch?v=YR5WdGrpoug">Maybe Not</a>'</em>
      </h3>
      <div class="note">
        <p>
          Rich Hickey presented <a href="https://2018.clojure-conj.org/rich-hickey/">Maybe Not</a> at the 2018 <em>Clojure conj</em>. If I correctly understand
          his presentation, he identified some flaws in <code>clojure.spec.alpha</code>, the Clojure distribution's built-in library for specifying and
          validating data. Mr Hickey highlighted three issues.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">1/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Problems raised by <em>Maybe Not</em>
      </h3>
      <ol>
        <li>
          <strong>Representing</strong> partial information in an aggregate data structure.
        </li>
        <li>
          <strong>Specifying</strong> partial information in an aggregate data structure.
        </li>
        <li>
          <strong>Validating</strong> partial information in an aggregate data structure.
        </li>
      </ol>
      <div class="note">
        <p>
          He was apparently not satisfied with the way <code>spec.alpha</code> handles these three issues.
        </p>
        <p>
          The <a href="https://github.com/blosavio/speculoos">Speculoos library</a> is an experiment to see if it is possible to perform the same tasks as
          <code>spec.alpha</code> using literal specifications. Due to some of the implementation details and policies I chose, the library has some emergent
          properties that end up neatly handling those three issues.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">2/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        ★ Three Mottos
      </h3>
      <ol class="side-by-side-by-side-container">
        <li class="div side-by-side-by-side">Validate scalars separately from validating collections.
          <div class="vspace"></div>
          <p>
            scalars:<br>
            <code>&emsp;&emsp;42, "abc", \c, 22/7, :kw, 'foo, true, nil</code>
          </p>
          <div class="vspace"></div>
          <p>
            collections:<br>
            <code>&emsp;&emsp;[…], {…}, (…), #{…}</code>
          </p>
          <div class="note">
            <p>
              Distinct functions for validating scalars and collections in HANDS. Advantages:
            </p>
            <ol>
              <li>Simpler. No mini-language that mixes identities and quantities. Specs Cloj data structures w/functions. Manipulate specs w/anything, e.g.
              <code>assoc-in</code> No macros.
              </li>
              <li>Mental clarity. Validation only applies to scalar, or to collection, never both. Predicate doesn't have to know anything about the quantity
              or location of the element.
              </li>
              <li>Only specify as much, or as little, as necessary. If only a few scalars, won't be forced to specify a property concerning a collection.
              </li>
            </ol>
            <p></p>
          </div>
        </li>
        <li class="side-by-side-by-side">Shape the specification to mimic the data.
          <div>
            data
          </div>
          <div>
            ↓
          </div>
          <pre><code>{:x 42   :y "abc"  }</code><br><code>{:x int? :y string?}</code></pre>
          <div>
            ↑
          </div>
          <div>
            specification
          </div>
          <div class="note">
            <p>
              Composing specs straightforward; mimic shape of data. Arrangement of nested vectors, lists, maps, sequences, and sets that contain predicates.
              Pattern instruct the validation functions where to apply the predicates. Spec for a vector is a vector. Spec for a map, is a map. ~1-to-1
              correspondence b/t shape of data and shape of specific. Strategy: copy-paste data, delete contents, use as a template, replace elements with
              predicates. Peek at by eye — merely eval them at <span class="small-caps">repl</span> — easy alteration: any Clojure data wrangling functions to
              tighten, relax, or remove portions of spec. <code>assoc-in</code>, <code>update-in</code>, & <code>dissoc</code>.
            </p>
          </div>
        </li>
        <li class="side-by-side-by-side">Ignore un-paired predicates and un-paired datums.
          <div>
            data
          </div>
          <div>
            ↓
          </div>
          <pre><code>{:x 42   <s>:y "abc"</s>}</code><br><code>{:x int? <s>:q double?</s>}</code></pre>
          <div>
            ↑
          </div>
          <div>
            specification
          </div>
          <div class="note">
            <p>
              Ignoring -&gt; Flexibility, power, optionality, and re-usability. Ex #1: pipeline. Supplying predicates for subset of datums only validates those
              specified datums while being agnostic towards the other datums. Ex #2 Sprawling specification that describes a myriad of data about a person,
              postal address, contact info, etc. B/c a spec just data structure with regular predicates, can, on-the-fly, <code>get-in</code> portion relevant
              to postal addresses and apply that to our particular instances of address data. Specify exactly what elements we'd like to validate. No more, no
              less.
            </p>
          </div>
        </li>
      </ol>
      <div class="note">
        <p>
          Three Mottos speaker notes
        </p>
        <div>
          <p>
            Efficiently using Speculoos requires remembering three mottos.
          </p>
          <ol>
            <li>Validate scalars separately from validating collections.
            </li>
            <li>Shape the specification to mimic the data.
            </li>
            <li>Ignore un-paired predicates and un-paired datums.
            </li>
          </ol>
          <p>
            If we follow those three mottos, handling partial information is straightforward. Briefly, Speculoos specifies and validates scalars separately
            from specifying and validating collections. A scalar specification describes the properties of the datums themselves. The presence or absence of a
            scalar is a completely separate concern and falls under the jurisdiction of specifying and validating the collection. By separating the two
            concerns, Speculoos seamlessly handles partial information while avoiding the issues that befall <code>spec.alpha</code>.
          </p>
          <p>
            Let's examine each issue in more detail.
          </p>
        </div>
      </div>
      <div class="panel-footer">
        <span class="panel-number">3/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Representing partial information
      </h3>
      <div class="side-by-side-by-side-container">
        <div class="side-by-side-by-side">
          <pre><code>{:first-name "Albert"
 :last-name "Einstein"
 :age 76}</code></pre>
        </div>
        <div class="side-by-side-by-side">
          <pre><code>{:first-name "Isaac"
 :last-name "Newton"
 :age nil}</code></pre>
        </div>
        <div class="side-by-side-by-side">
          <pre><code>{:first-name "Maria"
 :last-name "Göppert-Mayer"}</code></pre>
        </div>
      </div>
      <div class="note">
        <p>
          Representing partial data is not specifically the purview of the Speculoos library, but of Clojure itself. We'll discuss partial information only in
          order to supply us with examples for later.
        </p>
        <p>
          Mr Hickey highlights the fact that idiomatic Clojure merely excludes missing information instead of 'holding a slot' with a <code>nil</code>. Imagine
          data about a person that could include their first name, last name, and and their age. Here's an example of 'complete' data.
        </p>
        <p>
          The following example of partial data, with <code>nil</code> associated to 'missing' <code>:age</code> information, is atypical.
        </p>
        <p>
          The more idiomatic way to represent partial information about a person involves merely leaving off the person's age.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">4/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Specifying information
      </h3>
      <div class="side-by-side-container">
        <div class="side-by-side">
          <p>
            data
          </p>
          <pre><code>{:first-name "Albert"
 :last-name "Einstein"
 :age 76}</code></pre>
        </div>
        <div class="side-by-side">
          <p>
            specification
          </p>
          <pre><code>{:first-name string?
 :last-name string?
 :age int?}</code></pre>
        </div>
      </div>
      <div class="vspace"></div>
      <p>
        signature for validating
      </p>
      <pre><code>(valid-scalars? data
                specification)</code></pre>
      <div class="note">
        <p>
          A Speculoos specification is a plain Clojure data structure containing predicates. The specification's shape mimics the shape of the data (Motto #2).
          Professor Einstein's data is a map with keys <code>:first-name</code>, <code>:last-name</code>, and <code>:age</code>. The Speculoos specification
          for that data might look like this.
        </p>
        <p>
          The specification is likewise a map with those same keys, i.e., the same 'shape', with predicates <code>string?</code> and <code>int?</code>
          replacing datums. Speculoos assembles pairs of datums and predicates and reports if the datums satisfy their corresponding predicates and returns
          <code>true/false</code>.
        </p>
        <p>
          Signature for validating
        </p>
        <p>
          I'll be printing the specification on the line directly below the data to visually emphasize how the shape of the specification mimics the shape of
          the data (Motto #2).
        </p>
        <p>
          (Speculoos offers a <a href="https://github.com/blosavio/speculoos?tab=readme-ov-file#valid-thorough">verbose variant</a> if we need to see details
          of the validation.)
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">5/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Validating complete data
      </h3>
      <pre><code>(require '[speculoos.core :refer [valid-scalars?]])</code></pre>
      <div class="vspace"></div>
      <pre><code class="form">(valid-scalars? {:first-name "Albert", :last-name "Einstein", :age 76}
                {:first-name string?, :last-name string?, :age int?})</code><br><code class="eval">;; =&gt; true</code></pre>
      <div class="note">
        <p>
          <code>valid-scalars?</code> systematically walks through both the data and specification, and where it finds a datum paired with a predicate, it
          validates.
        </p>
        <ul>
          <li>
            <code>"Albert"</code> at <code>:first-name</code> in the data satisfies <code>string?</code> at <code>:first-name</code> in the specification,
          </li>
          <li>
            <code>"Einstein"</code> at <code>:last-name</code> in the data satisfies <code>string?</code> at <code>:last-name</code> in the specification, and
          </li>
          <li>
            <code>76</code> at <code>:age</code> in the data satisfies <code>int?</code> at <code>:age</code> in the specification.
          </li>
        </ul>
        <p>
          Three datums paired with three predicates. All predicates were satisfied. So <code>valid-scalars?</code> returned <code>true</code>.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">6/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Validating partial data
      </h3>
      <pre><code class="form">(valid-scalars? {:first-name "Albert", :last-name "Einstein"}
                {:first-name string?, :last-name string?, :age int?})</code><br><code class="eval">;; =&gt; true</code></pre>
      <div class="note">
        <p>
          Let's see what happens if we remove Professor Einstein's age from the data but leave the corresponding predicate in the specification.
        </p>
        <p>
          That result may be surprising. Why doesn't the missing age datum cause a <code>false</code> result? We need to consider Motto #3: Un-paired
          predicates are ignored. <code>valid-scalars?</code> was able to find two datum+predicate pairs.
        </p>
        <ul>
          <li>
            <code>Albert</code> at <code>:first-name</code> in the data satisfies predicate <code>string?</code> at <code>first-name</code> in the
            specification.
          </li>
          <li>
            <code>Einstein</code> at <code>:last-name</code> in the data satisfies predicate <code>string?</code> at <code>:last-name</code> in the
            specification.
          </li>
          <li>Predicate <code>int?</code> at <code>:age</code> in the specification was not paired with an element in the data and was therefore ignored, as
          Motto #3 informs us.
          </li>
        </ul>
        <p>
          That may seem kinda broken, but it opens up some powerful capabilities we're about to explore. Later, we'll see how to verify that the age datum
          actually exists in the data.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">7/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Validating complete data, partial specification
      </h3>
      <pre><code class="form">(valid-scalars?
  {:first-name "Albert", :last-name "Einstein", :email "al@princeton.edu"}
  {:first-name string?, :last-name string?})</code><br><code class="eval">;; =&gt; true</code></pre>
      <div class="note">
        <p>
          What about the other way around? What if our data contains a key-value that does not appear in the specification? Let's add an email entry.
        </p>
        <p>
          Again, <code>valid-scalars?</code> found two datum+predicate pairs. Both first-name and last-name datums satisfied their corresponding predicates, so
          the validation returned <code>true</code>. The email datum did not have a corresponding predicate, so, according to Motto #3, it was ignored.
        </p>
        <p>
          The general idea behind Motto #3 is <em>This element may or may not exist, but if it does exist, it must satisfy this predicate.</em> Taken to its
          logical conclusion, <code>valid?</code>, within the Speculoos library, conveys the notion <em>Zero invalid results</em>.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">8/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Validating complete data, empty specification
      </h3>
      <pre><code class="form">(valid-scalars?
  {:first-name "Albert", :last-name "Einstein", :age 76}
  {})</code><br><code class="eval">;; =&gt; true</code></pre>
      <div class="note">
        <p>
          We might imagine a scenario where we absolutely do not care about any facet of our data. In that case, our specification would contain exactly zero
          predicates.
        </p>
        <p>
          <code>valid-scalars?</code> found zero pairs of datums and predicates. Since there were zero invalids, <code>valid-scalars?</code> returns
          <code>true</code>.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">9/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Validating empty data
      </h3>
      <pre><code class="form">(valid-scalars? {}
                {:first-name string?,
                 :last-name string?,
                 :age int?,
                 :address {:street-name string?,
                           :street-number int?,
                           :zip-code int?,
                           :city string?,
                           :state keyword?},
                 :email #"\w@\w"})</code><br><code class="eval">;; =&gt; true</code></pre>
      <div class="note">
        <p>
          Perhaps over the last few months, our team has been assembling a comprehensive specification for a person's data that includes predicates for a whole
          slew of possible datums. We need to be able to handle partial data. I.e., not every instance of data we encounter will be complete. The edge case
          would be zero datums.
        </p>
        <p>
          Not a single one of those predicates was paired with a datum, so there were zero invalid results. Thus, <code>valid-scalars?</code> returns
          <code>true</code>.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">10/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Validating complete data, one invalid datum
      </h3>
      <pre><code class="form">(valid-scalars?
  {:first-name "Albert", :last-name "Einstein", :age "not an integer!"}
  {:first-name string?, :last-name string?, :age int?})</code><br><code class="eval">;; =&gt; false</code></pre>
      <div class="note">
        <p>
          In every example we've seen so far, all the datums satisfy the predicate they were paired with. Here's what happens if at least one datum does not
          satisfy its predicate.
        </p>
        <p>
          String datum <code>not an integer!</code> failed to satisfy the <code>int?</code> predicate located at <code>:age</code> in the specification.
          Therefore, <code>valid-scalars?</code> returned <code>false</code>. Speculoos provides other functions that give more detail about invalid elements,
          but for simplicity, we'll stick with the <code>true/false</code> results.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">11/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Validating presence of a datum: datum not there
      </h3>
      <pre><code>(defn has-age? [m] (contains? m :age))</code></pre>
      <pre><code>(require '[speculoos.core :refer [valid-collections?]])</code></pre>
      <div class="vspace"></div>
      <pre><code class="form">(valid-collections? {:first-name "Albert",
                     :last-name "Einstein"}
                    {:foo has-age?})</code><br><code class="eval">;; =&gt; false</code></pre>
      <div class="note">
        If we wanted to ensure that the data contains a particular key-value, we need to validate the collection itself (Motto #1). Presence of absence of a
        datum is a property of the collection. First, we'll write a <code>has-age?</code> collection predicate that tests whether the map contains an
        <code>:age</code> key.
        <p>
          Then, we insert <code>has-age?</code> into the collection specification. Collection validation operates a <a href=
          "https://github.com/blosavio/speculoos?tab=readme-ov-file#collection-validation">little differently</a> from scalar validation, but take my word that
          this is how to assemble the collection specification for this situation.
        </p>
        <p>
          Given this collection specification, <code>has-age?</code> will be paired with the root collection of the data.
        </p>
        <p>
          Finally, we invoke a completely different function to validate (Motto #1).
        </p>
        <p>
          <code>valid-collections?</code> informs us that the map fails to satisfy the <code>has-age?</code> collection predicate. It fails because the map
          does not contain <code>:age</code> as the collection specification requires.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">12/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Validating presence of a datum: datum is there
      </h3>
      <pre><code class="form">(valid-collections? {:first-name "Albert",
                     :last-name "Einstein",
                     :age 76}
                    {:foo has-age?})</code><br><code class="eval">;; =&gt; true</code></pre>
      <div class="note">
        <p>
          Now our map *does* contain :age. <code>valid-collections?</code> informs us that this map to satisfies the <code>has-age?</code> collection
          predicate.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">13/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Combo validation: scalars, then collections
      </h3>
      <pre><code>(require '[speculoos.core :refer [valid?]])</code></pre>
      <div class="vspace"></div>
      <pre><code class="form">(valid? {:first-name "Albert", :last-name "Einstein"}
        {:first-name string?, :last-name string?, :age int?}
        {:foo has-age?})</code><br><code class="eval">;; =&gt; false</code></pre>
      <div class="note">
        <p>
          We'll often want to validate some aspects of both the scalars and the collections, so Speculoos provides a combo function that does a scalar
          validation, immediately followed by a collection validation, and returns the overall result.
        </p>
        <p>
          The <code>string?</code> scalar predicates at <code>:first-name</code> and <code>:last-name</code> were both satisfied. Scalar predicate
          <code>int?</code> at <code>:age</code> was ignored. However, collection predicate <code>has-age?</code> at <code>:foo</code> was not satisfied, so
          <code>valid?</code> returns <code>false</code>.
        </p>
        <p>
          Specifying and validating scalar datums separately from specifying and validating collections completely isolates two concerns. The scalar predicates
          are entirely devoted to testing the properties of the scalars themselves. The collection predicates are devoted to properties of the collections,
          including the size of the collections, the presence/absence of elements, and relationships <em>between</em> elements. Using both, Speculoos can
          validate any facet of a heterogeneous, arbitrarily-nested data structure.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">14/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        When?!
      </h3>
      <pre><code class="form">(valid-scalars? {:first-name "Albert", :last-name "Einstein", :age 76.0}
                {:first-name string?, :last-name string?, :age int?})</code><br><code class="eval">;; =&gt; false</code></pre>
      <div class="note">
        <p>
          A portion of <em>Maybe Not</em> discusses <code>spec.alpha</code>'s issues with optionality. Mr Hickey contends it is a mistake to put optionality
          into aggregate specifications because doing so destroys a specification's re-usability. An entity that is optional in one context might not be
          optional in another context.
        </p>
        <p>
          Speculoos does not suffer from this problem. Because of Motto #3, any predicate that is not paired with a datum is ignored. Any datum that is not
          paired with predicate is also ignored. Only when a datum is paired with a predicate is the pair considered in the validation result. Separately, if a
          particular context requires the presence of a datum, we can validate that with a collection validation.
        </p>
        <p>
          Mr Hickey points out that validating arguments and return values of a function provide a built-in context: the context of the function itself.
          Speculoos validations themselves carry an inherent context: The context is the validation function with the specification at the moment of
          invocation, such as we've seen with <code>valid-scalars?</code>.
        </p>
        <p id="flexible">
          In addition to being straightforward to compose, Speculoos specifications are extremely flexible because they are plain Clojure data structures.
          Speculoos specifications can be manipulated using any Clojure tools, including the entire core library or any third-party library. Quite a lot of
          this flexibility can be demonstrated with merely <code>get</code>, <code>assoc</code>, <code>update</code>, and <code>dissoc</code>.
        </p>
        <p>
          Let's pretend that a specification someone handed us requires the age datum to be an integer. If Professor Einstein's age is instead a floating-point
          double, the validation would fail.
        </p>
        <p>
          <code>76.0</code> is not an integer.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">15/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        At that moment: Relax the requirement
      </h3>
      <pre><code class="form">(assoc {:first-name string?, :last-name string?, :age int?} :age number?)</code><br><code class=
      "eval">;; =&gt; {:age number?, :first-name string?, :last-name string?}</code></pre>
      <div class="vspace"></div>
      <pre><code class="form">(valid-scalars? {:first-name "Albert", :last-name "Einstein", :age 76.0}
                (assoc {:first-name string?, :last-name string?, :age int?} :age number?))</code><br><code class="eval">;; =&gt; true</code></pre>
      <div class="note">
        <p>
          We can easily relax our specification to accept that the age be any kind of number.
        </p>
        <p>
          With that relaxed specification in hand, that data is now valid.
        </p>
        <p>
          <code>76.0</code> satisfies scalar predicate <code>number?</code> which we <code>assoc</code>-ed into the specification on-the-fly.
        </p>
        <p>
          The original specification is immutable, as it always was. During the validation, we associated a more permissive scalar predicate so that, in this
          context (while invoking <code>valid-scalars?</code>), the data is valid.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">16/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        At that moment: Remove the requirement
      </h3>
      <div class="side-by-side-container">
        <div class="side-by-side">
          <pre><code class="form">(valid-collections?
  {:first-name "Albert",
   :last-name "Einstein"}
  {:foo has-age?})</code><br><code class="eval">;; =&gt; false</code></pre>
        </div>
        <div class="side-by-side">
          <pre><code class="form">(dissoc {:foo has-age?} :foo)</code><br><code class="eval">;; =&gt; {}</code></pre>
          <pre><code class="form">(valid-collections? {:first-name "Albert",
                     :last-name "Einstein"}
                    (dissoc {:foo has-age?}
                      :foo))</code><br><code class="eval">;; =&gt; true</code></pre>
        </div>
      </div>
      <div class="note">
        <p>
          Now, let's pretend someone handed us a collection specification that requires the presence of the age key-value, but in our little part of the world,
          our data doesn't have it, and our little machine doesn't need it. Without intervention, collection validation will fail.
        </p>
        <p>
          The data does not contain a key <code>:age</code> so the data is invalid, according to the specification we were handed.
        </p>
        <p>
          But, our little data processing machine doesn't need Professor Einstein's age, so we can straightforwardly remove that requirement in our context.
          Here's the altered collection specification.
        </p>
        <p>
          If we now use that altered collection specification in the context of our little machine, the data is valid.
        </p>
        <p>
          The collection specification no longer contains the <code>has-age?</code> predicate, so the data is declared valid in our context.
        </p>
        <p>
          Specifications made of plain Clojure data structures absorb every drop of generality, composability, and re-usability of the underlying data
          structures. They may be passed over the wire, stored in the file system, version controlled, annotated with metadata, and manipulated at will to suit
          any context.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">17/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Replicating specific scenarios from <em>Maybe Not</em>
      </h3>
      <div class="note">
        <p>
          In this section, we'll explore how Speculoos handles the specific, problematic scenarios presented by Mr Hickey.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">18/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Predicates use proper <code>or</code>
      </h3>
      <table>
        <tr>
          <td>
            Commutative:
          </td>
          <td>
            <pre><code class="form">(#(or (int? %) (string? %)) 42)</code><br><code class="eval">;; =&gt; true</code></pre>
            <pre><code class="form">(#(or (string? %) (int? %)) 42)</code><br><code class="eval">;; =&gt; true</code></pre>
          </td>
        </tr>
        <tr>
          <td>
            Associative:
          </td>
          <td>
            <pre><code class="form">(#(or (int? %) (or (string? %) (char? %))) 42)</code><br><code class="eval">;; =&gt; true</code></pre>
            <pre><code class="form">(#(or (or (int? %) (string? %)) (char? %)) 42)</code><br><code class="eval">;; =&gt; true</code></pre>
          </td>
        </tr>
        <tr>
          <td>
            Distributive:
          </td>
          <td>
            <pre><code class="form">(#(or (and (int? %) (even? %)) (string? %)) 42)</code><br><code class="eval">;; =&gt; true</code></pre>
          </td>
        </tr>
        <tr>
          <td>
            Etc.
          </td>
        </tr>
      </table>
      <div class="note">
        <p>
          Speculoos predicates are plain old Clojure functions. When we need to validate an element that may be one of multiple types, the predicates use
          <code>clojure.core/or</code>, which will inherit all the proper semantics.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">19/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        <code>nil</code>-able
      </h3>
      <p>
        Don't.
      </p>
      <div class="note">
        <p>
          This one's easy: just write Speculoos predicates without <code>nilable</code>.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">20/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Namespaced specifications
      </h3>
      <div class="side-by-side-container">
        <div class="side-by-side">
          <pre><code class="form">(valid-scalars? [42 "abc" 22/7]
                [int? string? ratio?])</code><br><code class="eval">;; =&gt; true</code></pre>
        </div>
        <div class="side-by-side">
          <pre><code>(def specification-1 [int? string? ratio?])</code></pre>
          <div class="vspace"></div>
          <pre><code class="form">(valid-scalars? [42 "abc" 22/7]
                specification-1)</code><br><code class="eval">;; =&gt; true</code></pre>
        </div>
      </div>
      <div class="note">
        <p>
          One of <code>spec.alpha</code>'s propositions is that specs are <a href=
          "https://clojure.org/about/spec#_global_namespaced_names_are_more_important">required to be namespace-qualified</a>. Speculoos takes a hands-off
          approach. Speculoos specifications are plain Clojure data structures that are referenced however we want. Specifications may be a literal, like
          <code>[int? string? ratio?]</code>.
        </p>
        <p>
          Or, we may bind them to a symbol in our current namespace.
        </p>
        <p>
          (We could also bind them to a symbol in a different namespace; not shown.)
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">21/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Specification registry
      </h3>
      <div class="no-display">
        #'speculoos.core/speculoos-registry
      </div>
      <pre><code>(defonce speculoos-registry (atom {:speculoos/specification-2 [int? string? ratio?]
                                   :speculoos/specification-3 {:first-name string?
                                                               :last-name  string?
                                                               :age        int?}})</code></pre>
      <div class="vspace"></div>
      <pre><code class="form">(valid-scalars? [42 "abc" 22/7]
                (@speculoos-registry :speculoos/specification-2))</code><br><code class="eval">;; =&gt; true</code></pre>
      <div class="note">
        <p>
          Or, we may gather them into our own bespoke registry.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">22/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Car specification
      </h3>
      <pre><code>(def car-scalar-specification
  {:make string?, :model string?, :year #(and (int? %) (&gt;= % 1885))})</code></pre>
      <div class="vspace"></div>
      <pre><code>(def car-collection-specification {:foo #(contains? % :make)})</code></pre>
      <div class="note">
        <p>
          To follow along precisely, we could split out the <em>make</em>, <em>model</em>, and <em>year</em> concepts into their own named predicate functions,
          but for brevity, I'll stuff them directly into our <code>car</code> scalar specification.
        </p>
        <p>
          At this point, we're not stating anything definitive about presence or absence of an element. A scalar specification says, for each scalar predicate,
          <em>This element may or may not exist, but if it does, the element must satisfy this predicate</em>. Declaring that <code>:make</code> is a string is
          completely separate from declaring that our car data must contain a <code>:make</code> value.
        </p>
        <p>
          If we want to require that our car data contains a <code>:make</code> entry, we declare that requirement in a collection specification.
        </p>
        <p>
          Unless explicitly required in a collection specification, Speculoos treats all scalars as optional. So we don't have to say anything about
          <code>:model</code> or <code>:year</code>.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">23/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Car validation: complete data
      </h3>
      <pre><code class="form">(valid? {:make "Acme Motor Cars", :model "Type 1", :year 1905}
        car-scalar-specification
        car-collection-specification)</code><br><code class="eval">;; =&gt; true</code></pre>
      <div class="note">
        <p>
          Let's validate with all the specified values.
        </p>
        <p>
          The values we supplied for <code>:make</code>, <code>:model</code>, and <code>year</code> all satisfied their respective scalar predicates.
          Furthermore, the <code>car</code> map itself satisfied the collection specification's requirement that the map contain a key <code>:make</code>.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">24/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Car validation: partial data
      </h3>
      <pre><code class="form">(valid? {:make "Acme Motor Cars"}
        car-scalar-specification
        car-collection-specification)</code><br><code class="eval">;; =&gt; true</code></pre>
      <div class="note">
        <p>
          Now, let's validate some car data with partial information: <code>:model</code> and <code>:year</code> values are missing.
        </p>
        <p>
          <code>{:make "Acme Motor Cars"}</code> is valid car data because <code>:make</code> satisfies its scalar predicate and the map itself contains the
          only key we required in the collection specification. <code>:model</code> and <code>:year</code> are implicitly optional because we did not require
          their existence in the collection specification.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">25/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Car validation: extra data
      </h3>
      <pre><code class="form">(valid? {:make "Acme Motor Cars", :year 1905, :cpu "Intel Pentium"}
        car-scalar-specification
        car-collection-specification)</code><br><code class="eval">;; =&gt; true</code></pre>
      <div class="note">
        <p>
          What if we have extra information? Let's validate data about an early 1900s car with a completely anachronistic computer chip.
        </p>
        <p>
          Again, this car data is valid, because we did not specify any property relating to <code>:cpu</code>, so the validation ignored that datum. All the
          other existing datums satisfied their corresponding predicates.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">26/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Car validation: missing required data
      </h3>
      <pre><code class="form">(valid? {:model "Type 1", :year 1905}
        car-scalar-specification
        car-collection-specification)</code><br><code class="eval">;; =&gt; false</code></pre>
      <div class="note">
        <p>
          What if we neglect to include the <code>:make</code> element?
        </p>
        <p>
          Finally, we run afoul of our collection specification: Our car data lacks a <code>:make</code> element, which our collection specification explicitly
          requires.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">27/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Car validation: different context, increasing requirements
      </h3>
      <pre><code class="form">(assoc car-collection-specification :b #(contains? % :year))</code><code class="eval">
;; =&gt; {:foo #(contains? % :make), :b #(contains? % :year)}</code></pre>
      <div class="vspace"></div>
      <pre><code class="form">(valid? {:make "Acme Motor Cars", :model "Type 1"}
        car-scalar-specification
        (assoc car-collection-specification :b #(contains? % :year)))</code><br><code class="eval">;; =&gt; false</code></pre>
      <div class="note">
        <p>
          What if we're in a different context, and suddenly we absolutely must have a <code>:year</code> element, too? Right then and there, we can augment
          the collection specification, because it's a plain Clojure data structure. And we know how to associate items on-the-fly into a map.
        </p>
        <p>
          So in this new context, we use that new collection specification with tighter requirements.
        </p>
        <p>
          Now, the absence of <code>:year</code> element of our car data is no longer ignored. This car data fails to satisfy one of its collection predicates
          that require the presence of a <code>:year</code> entry.
        </p>
        <p>
          Note that specifying the values of the scalars themselves (in a Speculoos scalar specification), is completely orthogonal to requiring their presence
          (which we declare in a Speculoos collection specification). By splitting the two concerns, the specifications become straightforwardly re-usable. We
          are free to specify any number of properties of the car data that may or may not exist. Then, in a particular context, we adjust our collection
          specification to require the particular group of elements that we need for that particular context.
        </p>
        <p>
          Speculoos specifications shouldn't proliferate uncontrollably because, as plain Clojure data structures, they're readily manipulable, on-the-fly,
          with <code>assoc</code> and friends.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">28/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Symmetric request/response schemas
      </h3>
      <p>
        <em>Give me a partially filled-in form, and I will give you back a more filled-in form</em>
      </p>
      <pre><code>(def one-spec {:ID int?, :name string?, :phone int?})</code></pre>
      <div class="vspace"></div>
      <div class="side-by-side-container">
        <div class="side-by-side">
          <pre><code class="form">(valid-scalars? {:ID 99}
                one-spec)</code><br><code class="eval">;; =&gt; true</code></pre>
        </div>
        <div class="side-by-side">
          <pre><code class="form">(valid-scalars? {:ID 99, :name "Sherlock Holmes", :phone 12345678}
                one-spec)</code><br><code class="eval">;; =&gt; true</code></pre>
        </div>
      </div>
      <div class="note">
        <p>
          No problem for Speculoos to validate that scenario with a single scalar specification. Because un-paired predicates are ignored, we can simply use
          the same scalar specification to validate both the <em>before</em> data and the <em>after</em> data.
        </p>
        <p>
          Let's pretend we query a service with an ID, and the service returns that ID and the associated name and phone number. That would be a
          straightforward scalar specification.
        </p>
        <p>
          Before we submit our request to the service, let's validate the partially filled-in form.
        </p>
        <p>
          <code>valid-scalars?</code> only considers pairs of datum+predicates. Our partially filled-in request only has one datum that is paired with a
          predicate: <code>99</code> at <code>:ID</code> is paired with <code>int?</code> at <code>:ID</code> in the scalar specification. <code>99</code>
          satisfies its paired scalar predicate <code>int?</code>, so <code>valid-scalars?</code> returns <code>true</code>.
        </p>
        <p>
          Now that we've validated our request, we send it off to the service, which returns <code>{:ID 99 :name "Sherlock Holmes" :phone 123456789}</code>. We
          can validate the response with the exact same scalar specification.
        </p>
        <p>
          During this invocation, <code>valid-scalars?</code> encountered three datum+predicate pairs, and each datum satisfied its corresponding scalar
          predicate, so the validation returns <code>true</code>.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">29/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Symmetric request/response: invalid data
      </h3>
      <pre><code>(def one-spec {:ID int?, :name string?, :phone int?})</code></pre>
      <div class="vspace"></div>
      <pre><code class="form">(valid-scalars? {:ID 99, :name \z, :phone \q}
                one-spec)</code><br><code class="eval">;; =&gt; false</code></pre>
      <div class="note">
        <p>
          What if we submit a query that causes the service to emit garbage data like <code>{:ID 0 :name \z :phone \q}</code>? Let's validate that.
        </p>
        <p>
          Same scalar specification, but since the datums do not satisfy their scalar predicates, the service's response does not satisfy the specification.
        </p>
        <p>
          One specification is sufficient to validate the data at each step. The specification is re-used, and there's one central location of what an
          <em>ID/name/phone</em> aggregate looks like.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">30/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Information-building pipelines
      </h3>
      <p>
        Cupcakes!
      </p>
      <pre><code class=
      "form"><br><strong>flour</strong> → 150 grams<br><strong>eggs</strong> → 2<br><strong>sugar</strong> → 130 grams<br><strong>butter</strong> → 60 grams<br><strong>milk</strong> → 1/8 liter<br><br></code><code class="eval"><br>{}<br>{:flour 150.0}<br>{:flour 150.0 :eggs 2}<br>{:flour 150.0 :eggs 2 :sugar 130.0}<br>{:flour 150.0 :eggs 2 :sugar 130.0 :butter 60.0}<br>{:flour 150.0 :eggs 2 :sugar 130.0 :butter 60.0 :milk 1/8}<br><br></code></pre>
      <div class="note">
        <p>
          An information-building pipeline is merely repeated application of the principles embodied in the <em>request/response</em> pattern we discussed
          earlier. A singular scalar specification can describe all the steps of a serially aggregating data structure.
        </p>
        <p>
          Let's pretend our cupcake processing pipeline accepts an accumulating map, and adds a new quantity based on an ingredient we pass alongside. It might
          look something like this.
        </p>
        <p>
          Our pipeline constructs the accumulating map in six steps like this.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">31/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        One specification for entire pipeline
      </h3>
      <pre><code>(def cupcake-spec {:flour double? :eggs int? :sugar double? :butter double? :milk ratio?})</code></pre>
      <div class="vspace"></div>
      <pre><code>(valid-scalars? {}                                                         cupcake-spec) ;; =&gt; true</code><br><code>(valid-scalars? {:flour 150.0}                                             cupcake-spec) ;; =&gt; true</code><br><code>(valid-scalars? {:flour 150.0 :eggs 2}                                     cupcake-spec) ;; =&gt; true</code><br><code>(valid-scalars? {:flour 150.0 :eggs 2 :sugar 130.0}                        cupcake-spec) ;; =&gt; true</code><br><code>(valid-scalars? {:flour 150.0 :eggs 2 :sugar 130.0 :butter 60.0}           cupcake-spec) ;; =&gt; true</code><br><code>(valid-scalars? {:flour 150.0 :eggs 2 :sugar 130.0 :butter 60.0 :milk 1/8} cupcake-spec) ;; =&gt; true</code></pre>
      <div class="note">
        <p>
          We can write one single scalar specification that validates each of those six steps.
        </p>
        <p>
          Now, we can validate the data at each step.
        </p>
        <p>
          Notice: <code>cupcake-spec</code> remained the same for each of the six validations as the pipeline added more and more elements. Speculoos' policy
          of ignoring un-paired predicates offers us the ability to specify the final shape at the outset, and the validation only considers the elements
          present at the moment of invocation.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">32/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Nested schemas
      </h3>
      <table>
        <tr>
          <td>
            data
          </td>
          <td>
            <pre><code>{:a 42 :b "abc" :c [\x \y \z] :d ['foo 'bar 'baz]}</code></pre>
          </td>
        </tr>
        <tr>
          <td>
            remove scalars
          </td>
          <td>
            <pre><code>{:a    :b     :c [       ] :d [        ]}</code></pre>
          </td>
        </tr>
        <tr>
          <td>
            specification
          </td>
          <td>
            <pre><code>{:a int? :b string? :c [char? char? char?] :d [symbol? symbol? symbol?]}</code></pre>
          </td>
        </tr>
        <tr>
          <td>
            validate
          </td>
          <td>
            <pre><code class="form">(valid-scalars?
  {:a 42, :b "abc", :c [\x \y \z], :d ['foo 'bar 'baz]}
  {:a int?, :b string?, :c [char? char? char?], :d [symbol? symbol? symbol?]})</code><br><code class="eval">;; =&gt; true</code></pre>
          </td>
        </tr>
      </table>
      <div class="note">
        <p>
          Speculoos was designed from the outset to validate any heterogeneous, arbitrarily-nested data structure. Mr Hickey imagines a data structure
          something like this.
        </p>
        <p>
          We can immediately compose a specification for that data. One trick is to take advantage of the fact that Speculoos specifications mimic the shape of
          the data. So first, we copy-paste the data, and delete the scalars.
        </p>
        <p>
          Then, we insert our predicates, one predicate for each scalar.
        </p>
        <p>
          Finally, we validate.
        </p>
        <p>
          <code>valid-scalars?</code> systematically marches through the data and specification, searching for pairs of scalars and predicates. In this case,
          it finds pairs at keys <code>:a</code> and <code>:b</code>, and dives down into the nested vectors at keys <code>:c</code> and <code>:d</code>. So
          scalar <code>\x</code> is paired with predicate <code>char?</code>, scalar <code>'foo</code> is paired with predicate <code>symbol?</code>, etc. All
          the scalars satisfy their corresponding predicates, so the validation returns <code>true</code>.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">33/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Nested schemas: composing with named sub-components
      </h3>
      <pre><code>(def three-chars? [char? char? char?])</code></pre>
      <div class="vspace"></div>
      <pre><code>(def three-syms? [symbol? symbol? symbol?])</code></pre>
      <div class="vspace"></div>
      <pre><code class="form">(valid-scalars? {:a 42, :b "abc", :c [\x \y \z], :d ['foo 'bar 'baz]}
                {:a int?, :b string?, :c three-chars?, :d three-syms?})</code><br><code class="eval">;; =&gt; true</code></pre>
      <div class="note">
        <p>
          We could also compose an equivalent scalar specification from pre-defined sub-components. Consider this.
        </p>
        <p>
          Regular old Clojure composition in action. The scalar specification refers to <code>three-chars?</code> at its key <code>:c</code> and refers to
          <code>three-syms?</code> at its key <code>:d</code>. We can thus mix and match with impunity to compose our specifications.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">34/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Nested schemas: extracting slices
      </h3>
      <pre><code class="form">(get {:a 42, :b "abc", :c [\x \y \z], :d ['foo 'bar 'baz]} :c)</code><br><code class="eval">;; =&gt; [\x \y \z]</code></pre>
      <div class="vspace"></div>
      <pre><code class="form">(valid-scalars? (get {:a 42, :b "abc", :c [\x \y \z], :d ['foo 'bar 'baz]} :c)
                three-chars?)</code><br><code class="eval">;; =&gt; true</code></pre>
      <div class="note">
        <p>
          A riff on that tune is to extract some selection of our data and validate it against a smaller specification. Pretend we only care about validating
          the three-element vector at <code>:c</code>. We've got tools that can pull that vector out.
        </p>
        <p>
          And we've already written a specification for that extracted vector, <code>three-chars?</code>, so we can immediately validate.
        </p>
        <p>
          This invocation used <code>get</code> to extract the vector at <code>:c</code> and validated it against predicate <code>three-chars?</code>.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">35/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Nested schemas: validating slices in place
      </h3>
      <pre><code class="form">(valid-scalars? {:a 42, :b "abc", :c [\x \y \z], :d ['foo 'bar 'baz]}
                {:c three-chars?})</code><br><code class="eval">;; =&gt; true</code></pre>
      <div class="note">
        <p>
          Alternatively, we could leverage the fact that un-paired datums are ignored, and specify only that nested vector.
        </p>
        <p>
          We performed a validation on only a selection because <code>valid-scalars?</code> applied only the three <code>char?</code> scalar predicates to the
          contents of the nested vector at <code>:c</code>.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">36/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h4>
        Movie times & placing orders: assembling specifications
      </h4>
      <div class="side-by-side-container">
        <div class="side-by-side">
          <pre><code>(def street string?)</code></pre>
          <pre><code>(def city string?)</code></pre>
          <pre><code>(def state keyword?)</code></pre>
          <pre><code>(def zip int?)</code></pre>
          <pre><code>(def address {:street street, :city city, :state state, :zip zip})</code></pre>
        </div>
        <div class="side-by-side">
          <pre><code>(def id int?)</code></pre>
          <pre><code>(def first-name string?)</code></pre>
          <pre><code>(def last-name string?)</code></pre>
        </div>
      </div>
      <div class="vspace"></div>
      <pre><code>(def user
  {:id id, :first-name first-name, :last-name last-name, :address address})</code></pre>
      <div class="note">
        <p>
          Mr Hickey's next example extends the discussion of validating Professor Einstein's data from earlier. First, we'll write some bottom-level
          specifications.
        </p>
        <p>
          Then, we aggregate them into a specification for an address.
        </p>
        <p>
          Next, we write some more bottom-level specifications.
        </p>
        <p>
          Finally, we aggregate those specifications into a user specification, including the <code>address</code> aggregate from before.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">37/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Validating in <code>get-movie-times</code> context
      </h3>
      <pre><code class="form">(valid-scalars?
  {:id 101, :address {:zip 90210}}
  {:id id, :first-name first-name, :last-name last-name, :address address})</code><br><code class="eval">;; =&gt; true</code></pre>
      <div class="note">
        <p>
          Speculoos provides several utilities for <a href="https://github.com/blosavio/speculoos?tab=readme-ov-file#function-validation">validating function
          arguments and return values</a>, but to avoid introducing a new utility, we'll stick with <code>valid-scalars?</code> and I'll ask that you trust me
          that the function validation operates substantially the same way.
        </p>
        <p>
          If we imagine that a function <code>get-movie-times</code> expects an ID and a zip, we could validate that slice of data.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">38/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Validating in <code>place-order</code> context
      </h3>
      <pre><code class="form">(valid-scalars? {:first-name "Helen",
                 :last-name "tis Troías",
                 :address {:street "Equine Avenue",
                           :city "Sparta",
                           :state :LCNIA,
                           :zip 54321}}
                {:id id,
                 :first-name first-name,
                 :last-name last-name,
                 :address address})</code><br><code class="eval">;; =&gt; true</code></pre>
      <div class="note">
        <p>
          In the context of a different function, <code>place-order</code>, we might want to validate a first name, last name, and the full address. Validating
          that slice of data would look like this.
        </p>
        <p>
          Exact same specification in both cases, <code>user</code>, but this time, a different slice of data was compared to specification. Because Speculoos
          only validates using predicates that are paired with scalars, the extra, un-paired predicates (in this example, <code>:id</code>) in scalar
          specification <code>user</code> have no effect.
        </p>
        <p>
          Also note that the data is a heterogeneous, nested data structure (Mr Hickey calls it a 'tree'), and because Speculoos specifications mimic the shape
          of the data, the <code>user</code> scalar specification is also a tree. Speculoos can handle any depth of nesting, with any of Clojure's data
          structures (vectors, lists, sequences, maps, and sets).
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">39/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        No requirements
      </h3>
      <pre><code class="form">(valid-scalars? {:sheep #{"Fred" "Ethel"}, :helicopters 1}
                {})</code><br><code class="eval">;; =&gt; true</code></pre>
      <div class="note">
        <p>
          Speculoos will happily validate data with an empty specification.
        </p>
        <p>
          Validating with an empty specification will always return <code>true</code>. That behavior is governed by ignoring un-paired scalars (i.e., there are
          no predicates to pair with), and zero un-satisfied predicates is considered <em>valid</em>. Speculoos is 'open' in the sense that Mr Hickey
          discusses: Extra information is okay. Speculoos merely ignores it if it isn't paired with a predicate.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">40/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Generating random samples
      </h3>
      <pre><code>(require '[speculoos.utility :refer [exercise]])</code></pre>
      <div class="vspace"></div>
      <pre><code class="form">(exercise {:sheep #{"Fred" "Ethel" "Lucy" "Ricky" "Little Ricky"},
           :helicopters pos-int?}
          5)</code><br><code class="eval">;; =&gt; ([{:helicopters 18, :sheep "Little Ricky"} true]
;;     [{:helicopters 14, :sheep "Ricky"} true]
;;     [{:helicopters 19, :sheep "Little Ricky"} true]
;;     [{:helicopters 26, :sheep "Ricky"} true]
;;     [{:helicopters 20, :sheep "Fred"} true])</code></pre>
      <div class="note">
        <p>
          Speculoos can generate valid test data if we supply it with a scalar specification.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">41/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Programmatically manipulating specifications: extracting the address
      </h3>
      <pre><code class="form">(get {:id int?,
      :first-name string?,
      :last-name string?,
      :address {:street string?,
                :city string?,
                :zip int?,
                :state keyword?}}
     :address)</code><br><code class="eval">;; =&gt; {:city string?,
;;     :state keyword?,
;;     :street string?,
;;     :zip int?}</code></pre>
      <div class="note">
        <p>
          We <a href="#flexible">discussed</a> this earlier. Speculoos specifications are plain Clojure data structures containing plain predicate functions.
          Slice and dice them however we want.
        </p>
        <p>
          Extract a slice of a specification, perhaps just the address.
        </p>
        <p>
          You can quickly make your own *ad hoc* specification registry.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">42/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Programmatically manipulating specifications: tightening ID requirements
      </h3>
      <pre><code class="form">(assoc {:id int?,
        :first-name string?,
        :last-name string?,
        :address {:street string?,
                  :city string?,
                  :zip int?,
                  :state keyword?}}
  :id even?)</code><br><code class="eval">;; =&gt; {:address {:city string?,
;;               :state keyword?,
;;               :street string?,
;;               :zip int?},
;;     :first-name string?,
;;     :id even?,
;;     :last-name string?}</code></pre>
      <div class="note">
        <p>
          Alter a portion of a specification, perhaps by tightening the requirements of the ID.
        </p>
        <p>
          We could, on-the-fly, require <code>:id</code> to be a positive integer by invoking <code>valid-scalars?</code> with that <code>assoc</code>-ed
          specification. The original specification is immutable as always, and remains unchanged. But at that moment of validation, the requirements were
          tightened.
        </p>
        <p>
          No need to write a macro. Just manipulate Clojure data with our favorite utilities.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">43/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        Function validation, nailing down everything, & final thoughts
      </h3>
      <div class="note">
        <p>
          Speculoos has an <a href="https://blosavio.github.io/speculoos/speculoos.function-specs.html">entire namespace</a> dedicated to validating function
          arguments and return values. Function validation follows all the same principles we've been discussing about validating data. It's a lengthy topic,
          so I'll refer to the <a href="https://github.com/blosavio/speculoos?tab=readme-ov-file#function-validation">documentation on the subject</a>.
        </p>
        <p>
          Nail down everything!
        </p>
        <p>
          I hope at this point I've made a convincing case that Speculoos is open and permissive: Only specify what we're interested in, and Speculoos will
          ignore the rest. There is no requirement that we describe every possible facet of our data. Whatever small amount we <em>do</em> specify, can be used
          to validate our data, and generate test samples, etc.
        </p>
        <p>
          It's fortunate that Speculoos' implementation details combined with a few policy decisions resulted in being able to address most all of <em>Maybe
          Not</em>'s concerns. I don't claim that Speculoos is the only solution to these issues, but that the principles under which Speculoos operates
          provides one possible solution.
        </p>
        <p>
          <a href="https://github.com/blosavio">Let me know</a> what you think.
        </p>
      </div>
      <div class="panel-footer">
        <span class="panel-number">44/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"></div>
      <h3>
        What's next.
      </h3>
      <ol class="de-highlight whats-next">
        <li>Introduction
        </li>
        <li>Mechanics
        </li>
        <li>Validating Scalars
        </li>
        <li>Validating Collections, Basics
        </li>
        <li>Validating Collections, Advanced
        </li>
        <li>Validating Collections, Extras
        </li>
        <li>Validation Summaries & Thoroughness
        </li>
        <li>Function Validation
        </li>
        <li>Generating Random Samples & Exercising
        </li>
        <li>Utilities
        </li>
        <li>Predicates
        </li>
        <li>Non-Terminating Sequences
        </li>
        <li>Sets
        </li>
        <li>Troubleshooting
        </li>
        <li>Comparing spec.alpha to Speculoos
        </li>
        <li>Perhaps So
        </li>
        <li class="highlight">Case Study
        </li>
      </ol>
      <div class="note">
        What's next speaker note within 'Perhaps So' screencast...
      </div>
      <div class="panel-footer">
        <span class="panel-number">45/45</span><span class="footer-link">https://github.com/blosavio/speculoos</span>
      </div>
    </div>
    <p id="page-footer">
      Copyright © 2024 Brad Losavio.<br>
      Compiled by <a href="https://github.com/blosavio/screedcast">Screedcast</a> on 2024 December 11.
    </p>
    <div class="license">
      <p>
        This program and the accompanying materials are made available under the terms of the <a href="https://opensource.org/license/MIT">MIT License</a>.
      </p>
    </div><span id="uuid"><br>
    7060304f-2f6e-4453-ab1c-7797821e7edf</span>
    <p></p>
  </body>
</html>
