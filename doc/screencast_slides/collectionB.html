<!DOCTYPE html>
<html lang="en"><head><link href="screedcast.css" rel="stylesheet" type="text/css"><script src="jquery-3.7.1.min.js" type="text/javascript"></script><script src="screedcast.js" type="text/javascript"></script><title>Speculoos — An experimental Clojure data validation library</title><meta charset="utf-8" compile-date="2024-12-03 08:38:52" content="width=device-width, initial-scale=1" name="viewport"><body><div class="panel"><div class="panel-header"></div><h1>Speculoos Screencast 5 — Collection Validation, Advanced</h1><div class="note"><p>In the previous screencast, we discussed the collection validation using some basic examples. Vectors --- both flat and nested, and maps --- both flat and nested. Each of the examples used one predicate targeting one collection.</p><p>Because of the way the algorithm works, Speculoos collection validation can optionally involve multiple predicates targeting one collection. This never violates any of the three mottos, but it may be occasionally useful. So to know when and how to use that pattern --- and to possibly diagnose a confusing result is we mis-construct a specification --- let's start by reviewing some principles.</p></div><div class="panel-footer"><span class="panel-number">1/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Scalars versus Collections</h3><table><tr><td>scalars</td><td><code><span class="de-highlight">[</span><span class="highlight">42</span><span class="de-highlight"> {:x </span><span class="highlight">"abc"</span><span class="de-highlight"> :y </span><span class="highlight">22/7</span><span class="de-highlight">}]</span></code></td></tr><tr><td>collections</td><td><code><span class="highlight">[</span><span class="de-highlight">42</span><span class="highlight"> {:x </span><span class="de-highlight">"abc"</span><span class="highlight"> :y </span><span class="de-highlight">22/7</span><span class="highlight">}]</span></code></td></tr></table><div class="note"><p>This is one way to visualize the difference. Scalar validation targets only the scalars: numbers, strings, characters, etc.. Collection validation only validates the collections themselves: vectors, maps, sequences, lists, sets. We could kinda think about it as validating the brackets, parens, braces, etc.</p></div><div class="panel-footer"><span class="panel-number">2/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>★ Three Mottos</h3><ol class="side-by-side-by-side-container"><div class="side-by-side-by-side"><li>Validate scalars separately from validating collections.</li><div class="vspace"></div><p>scalars:<br><code>&emsp;&emsp;42, "abc", \c, 22/7, :kw, 'foo, true, nil</code></p><div class="vspace"></div><p>collections:<br><code>&emsp;&emsp;[…], {…}, (…), #{…}</code></p><div class="note"><p>Distinct functions for validating scalars and collections in HANDS. Advantages:<ol><li>Simpler. No mini-language that mixes identities and quantities. Specs Cloj data structures w/functions. Manipulate specs w/anything, e.g. <code>assoc-in</code> No macros.</li><li>Mental clarity. Validation only applies to scalar, or to collection, never both. Predicate doesn't have to know anything about the quantity or location of the element.</li><li>Only specify as much, or as little, as necessary. If only a few scalars, won't be forced to specify a property concerning a collection.</li></ol></p></div></div><div class="side-by-side-by-side"><li>Shape the specification to mimic the data.</li><div>data</div><div>↓</div><pre><code>{:x 42   :y "abc"  }</code><br><code>{:x int? :y string?}</code></pre><div>↑</div><div>specification</div><div class="note"><p>Composing specs straightforward; mimic shape of data. Arrangement of nested vectors, lists, maps, sequences, and sets that contain predicates. Pattern instruct the validation functions where to apply the predicates. Spec for a vector is a vector. Spec for a map, is a map. ~1-to-1 correspondence b/t shape of data and shape of specific. Strategy: copy-paste data, delete contents,  use as a template, replace elements with predicates. Peek at by eye — merely eval them at <span class="small-caps">repl</span> — easy alteration: any Clojure data wrangling functions to tighten, relax, or remove portions of spec. <code>assoc-in</code>, <code>update-in</code>, & <code>dissoc</code>.</p></div></div><div class="side-by-side-by-side"><li>Ignore un-paired predicates and un-paired datums.</li><div>data</div><div>↓</div><pre><code>{:x 42   <s>:y "abc"</s>}</code><br><code>{:x int? <s>:q double?</s>}</code></pre><div>↑</div><div>specification</div><div class="note"><p>Ignoring -> Flexibility, power, optionality, and re-usability. Ex #1: pipeline. Supplying predicates for subset of datums only validates those specified datums while being agnostic towards the other datums. Ex #2 Sprawling specification that describes a myriad of data about a person, postal address,  contact info, etc. B/c a spec just  data structure with regular predicates, can, on-the-fly, <code>get-in</code> portion relevant to postal addresses and apply that to our particular instances of address data. Specify exactly what elements we'd like to validate. No more, no less.</p></div></div></ol><div class="note"><p>Three Mottos speaker notes</p></div><div class="panel-footer"><span class="panel-number">3/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>When to validate collections versus validating scalars</h3><div class="side-by-side-container"><div class="side-by-side"><h4>Validate properties of the collection</h4><ul><li>Size of a collection</li><li>Existence of an element</li></ul></div><div class="side-by-side"><h4>Validate <em>relationships between</em> scalars</h4><ul><li>Second element equal to first</li><li>All elements ascending</li></ul></div></div><div class="note"><p>Ex: count of a vector; map contains an `:email` key?</p><p>Ex: 1st and 2nd both 42?; 2nd is bigger than 1st, 3rd bigger than 2nd, etc?</p></div><div class="panel-footer"><span class="panel-number">4/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Where collection predicates apply</h3><h4>Any predicates apply to their immediate parent collection.</h4><p>Important terms</p><ul><li>Parent</li><li>Immediate</li><li>Any</li></ul><div class="note"><p>Unlike scalar validation, wherein predicates apply to scalars that share their exact paths, collection predicates apply to the collection that corresponds to their parent container.</p><p>Importantly, it's the *immediate* parent only, it does not bubble up to a higher layer.</p><p>*Any* is the crux of this screencast: A Clojure collection may contain an arbitrary number of elements, including predicates. So a Speculoos specification may contain an arbitrary number of predicates.</p><p>3 Mottos + targeting parent collection are an emergent property of the collection validation algorithm. If we understand the algorithm, we can write clear, correct, and expressive collection specifications.</p></div><div class="panel-footer"><span class="panel-number">5/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Quick review: Manually validate a flat vector</h3><table><tr><td>data</td><td><code>[42 "abc" 22/7]</code></td></tr><tr><td>predicate</td><td><pre><code>(defn len-3? [c] (= 3 (count c)))</code></pre></td></tr><tr><td>specification</td><td><pre><pre><code>[42 "abc" 22/7] ;; copy-paste data</code></pre><pre><code>[             ] ;; delete scalars</code></pre><pre><code>[len-3?       ] ;; insert predicate</code></pre></pre></td></tr><tr><td>enumerate paths</td><td><div class="side-by-side-container"><div class="side-by-side"><pre><code class="form">(all-paths [42 "abc" 22/7])</code><br><code class="eval">;; => [{:path [], :value [42 "abc" 22/7]}
;;     {:path [0], :value 42}
;;     {:path [1], :value "abc"}
;;     {:path [2], :value 22/7}]</code></pre></div><div class="side-by-side"><pre><code class="form">(all-paths [len-3?])</code><br><code class="eval">;; => [{:path [], :value [len-3?]}
;;     {:path [0], :value len-3?}]</code></pre></div></div></td></tr><tr><td>keep only…</td><td><div class="side-by-side-container"><div class="side-by-side"><code>[{:path [], :value [42 "abc" 22/7]}]</code></div><div class="side-by-side"><code>[{:path [0], :value len-3?}]</code></div></div></td></tr><tr><td>apply predicate</td><td><pre><code class="form">(len-3? [42 "abc" 22/7])</code><br><code class="eval">;; => true</code></pre></td></tr></table><div class="note"></div><div class="panel-footer"><span class="panel-number">6/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Quick review: Validating flat vector with Speculoos</h3><pre><code>(require '[speculoos.core :refer [validate-collections]])</code></pre><div class="vspace"></div><pre><code class="form">(validate-collections [42 "abc" 22/7]
                      [len-3?])</code><br><code class="eval">;; => ({:datum [42 "abc" 22/7],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate len-3?,
;;      :valid? true})</code></pre><div class="note"></div><div class="panel-footer"><span class="panel-number">7/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating flat vector with two predicates</h3><pre><code class="form">(validate-collections [42]
                      [vector? map?])</code><br><code class="eval">;; => ({:datum [42],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate vector?,
;;      :valid? true}
;;     {:datum [42],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [1],
;;      :predicate map?,
;;      :valid? false})</code></pre><div class="note"><p>Only one collection, but TWO predicates and two validations?</p></div><div class="panel-footer"><span class="panel-number">8/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Flat vector, two predicates</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code class="form">(all-paths [42])</code><br><code class="eval">;; => [{:path [], :value [42]}
;;     {:path [0], :value 42}]</code></pre></div><div class="side-by-side"><pre><code class="form">(all-paths [vector? map?])</code><br><code class="eval">;; => [{:path [], :value [vector? map?]}
;;     {:path [0], :value vector?}
;;     {:path [1], :value map?}]</code></pre><div class="vspace"></div><pre><code class="form">(drop-last [0])</code><br><code class="eval">;; => ()</code></pre><pre><code class="form">(drop-last [1])</code><br><code class="eval">;; => ()</code></pre><div class="vspace"></div><pre><code class="form">(drop-last [99999])</code><br><code class="eval">;; => ()</code></pre></div></div><div class="note"><p>Remember: `vector?` and `map?` are merely short stand-ins for more interesting/powerful predicates that actually validate something interesting.</p><p>The `drop-last` step of the algorithm means, functionally, that any and all predicates will be applied to the parent container. This is relevant to *all* collection types: vectors, maps, sets, lists, sequences, etc.</p></div><div class="panel-footer"><span class="panel-number">9/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Flat vector, five predicates</h3><pre><code class="form">(validate-collections [42]
                      [vector? map? list? set? coll?])</code><br><code class="eval">;; => ({:datum [42],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate vector?,
;;      :valid? true}
;;     {:datum [42],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [1],
;;      :predicate map?,
;;      :valid? false}
;;     {:datum [42],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [2],
;;      :predicate list?,
;;      :valid? false}
;;     {:datum [42],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [3],
;;      :predicate set?,
;;      :valid? false}
;;     {:datum [42],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [4],
;;      :predicate coll?,
;;      :valid? true})</code></pre><div class="note"><p>The `drop-last` paths of all five predicates all evaluated to root, so the validation made five predicate+collection pairs (Motto #3). Every predicate is paired with at most one collection, but any collection may be paired with any number of predicates (zero or more).</p></div><div class="panel-footer"><span class="panel-number">10/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Possible problem: nested collection following multiple predicates</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code>[42 {:y "abc"}]</code></pre><div class="vspace"></div><pre><code class="form">(all-paths [42 {:y "abc"}])</code><br><code class="eval">;; => [{:path [], :value [42 {:y "abc"}]}
;;     {:path [0], :value 42}
;;     {:path [1], :value {:y "abc"}}
;;     {:path [1 :y], :value "abc"}]</code></pre><div class="vspace"></div><pre><code class="form">(drop-last [0])</code><br><code class="eval">;; => ()</code></pre><pre><code class="form">(drop-last [1])</code><br><code class="eval">;; => ()</code></pre></div><div class="side-by-side"><pre><code>[coll? vector? {:foo map?}]</code></pre><div class="vspace"></div><pre><code class="form">(all-paths [coll? vector? {:foo map?}])</code><br><code class="eval">;; => [{:path [], :value [coll? vector? {:foo map?}]}
;;     {:path [0], :value coll?}
;;     {:path [1], :value vector?}
;;     {:path [2], :value {:foo map?}}
;;     {:path [2 :foo], :value map?}]</code></pre><div class="vspace"></div><pre><code class="form">(drop-last [2 :foo])</code><br><code class="eval">;; => (2)</code></pre></div></div><div class="note"><p>How do we match path `[2 :foo]` to `[1]`? A simple `drop-last` won't work.</p></div><div class="panel-footer"><span class="panel-number">11/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Additional rule for sequentials</h3><h4>For collections nested within a sequential collection, apply nested collection predicates in the order which they appear, ignoring scalars.</h4><div class="panel-footer"><span class="panel-number">12/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>How: <em>Prune the intervening scalars</em></h3><table><tr><td>originals</td><td><code>[42 {:y "abc"}]</code></td><td><code>[coll? vector? {:foo map?}]</code></td></tr><tr><td><div class="vspace"></div></td></tr><tr><td>prune scalars</td><td><code>[{:y "abc"}]</code></td><td><code>[{:foo map?}]</code></td></tr><tr><td><div class="vspace"></div></td></tr><tr><td>enumerate paths</td><td><pre><code class="form">(all-paths [{:y "abc"}])</code><br><code class="eval">;; => [{:path [], :value [{:y "abc"}]}
;;     {:path [0], :value {:y "abc"}}
;;     {:path [0 :y], :value "abc"}]</code></pre></td><td><pre><code class="form">(all-paths [{:foo map?}])</code><br><code class="eval">;; => [{:path [], :value [{:foo map?}]}
;;     {:path [0], :value {:foo map?}}
;;     {:path [0 :foo], :value map?}]</code></pre></td></tr></table><pre><code class="form">(drop-last [0 :foo])</code><br><code class="eval">;; => (0)</code></pre><div class="vspace"></div><pre><code class="form">(map? {:y "abc"})</code><br><code class="eval">;; => true</code></pre><div class="note"><p>With the intervening scalars pruned, the `drop-last` procedure pairs the predicate with the nested `map?` predicate.</p></div><div class="panel-footer"><span class="panel-number">13/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating collections nested within a sequential</h3><pre><code class="form">(validate-collections [42 {:y "abc"}]
                      [coll? vector? {:foo map?}])</code><br><code class="eval">;; => ({:datum [42 {:y "abc"}],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate coll?,
;;      :valid? true}
;;     {:datum [42 {:y "abc"}],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [1],
;;      :predicate vector?,
;;      :valid? true}
;;     {:datum {:y "abc"},
;;      :ordinal-path-datum [0],
;;      :path-datum [1],
;;      :path-predicate [2 :foo],
;;      :predicate map?,
;;      :valid? true})</code></pre><div class="note"><p>`coll?` and `vector?` predicates apply to their immediate parent container. The map is nested within a sequential, and the those two predicates intervene, messing up the `drop-last` procedure. So we must appeal to the new rule: prune the predicates.</p><p>`validate-collections` does all the pruning for us. When it looked at the map in the sequential, it removed all the preceding scalars: 42 and `coll?`, and `vector?`. Now, `(drop-last [])` works. That's what the 'ordinal-path-datum' tells us: the paths as if the scalars were removed from both.</p></div><div class="panel-footer"><span class="panel-number">14/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Stretching the principle: Exemplar sequential data</h3><pre><code class="form">[{:a 11} 22 (list 33) 44 #{55}]</code><br><code class="eval"> 0       1  2         3  4     <--- indexes</code><br><code class="eval"> 1st        2nd          3rd   <--- nested collections</code></pre><div class="note"><p>For the next few demonstrations, we'll be re-using this exemplar data. So let's get comfortable with it. All the double-digit scalars are merely there to get in our way. To validate the collections, we'll have to carefully apply the principles.</p><p>Four collections: one root, three nested (one each of map, list, set). Motto #1 reminds us to be in mindset.</p><p>Most critically, the root collection --- a vector --- is a sequential, so the order of its contents matter. Therefore, the ordering of its specification will also matter, because the shape mimics the data.</p></div><div class="panel-footer"><span class="panel-number">15/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Stretching the principle: Prune the sequential data</h3><pre><code>[{:a 11} 22 (list 33) 44 #{55}]</code></pre><pre><code>[{     }    (       )    #{  }]</code></pre><div class="panel-footer"><span class="panel-number">16/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Stretching the principle: Enumerate paths of pruned data</h3><pre><pre><code class="form">(all-paths [{} () #{}])</code><br><code class="eval">;; => [{:path [], :value [{} () #{}]}
;;     {:path [0], :value {}}
;;     {:path [1], :value ()}
;;     {:path [2], :value #{}}]</code></pre></pre><div class="vspace"></div><p>original data: <code>[{<span class="de-highlight">:a 11</span>} <span class="de-highlight">22</span> (<span class="de-highlight">list 33</span>) <span class="de-highlight">44</span> #{<span class="de-highlight">55</span>}]</code></p><div class="note"><p>Note: Nested map, nested list, and nested set remain in the same relative order. The root collection is, as always, at path <code>[]</code>. The nested collections are zero-indexed: nested map <code>0</code>,nested list at <code>1</code>,  nested set at <code>2</code>. These indexes are what <code>validate-collections</code> reports as <code>:ordinal-path-datum</code>, the prefix <em>ordinal</em> indicating a position within a sequence, 'first', 'second', 'third', etc.</p></div><div class="panel-footer"><span class="panel-number">17/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Stretching the principle: Composing specification by deleting scalars</h3><pre><code>[{:a 11} 22 (list 33) 44 #{55}] ;; <--- data</code><br><code>[{     }    (       )    #{  }] ;; <--- collection specification</code><br><code> ^--- 1st   ^--- 2nd     ^--- 3rd nested collection</code></pre><div class="note"><p>Note: collection specification looks a lot like our data with all the scalars removed.</p><p>The ordering is important: 1st nested collection, 2nd nested collection, etc.</p><p>Note: Even though it contains zero predicates, that empty structure in the lower row is a legitimate collection specification which <code>validate-collections</code> can consume.</p></div><div class="panel-footer"><span class="panel-number">18/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Stretching the principle: Validating with zero predicates</h3><pre><code class="form">(validate-collections [{:a 11} 22 (list 33) 44 #{55}]
                      [{} () #{}])</code><br><code class="eval">;; => ()</code></pre><div class="note"><p>Motto #3: Validation ignores collections in the data that are not paired with a predicate in the specification. Zero predicates, zero pairs.</p><p>The idea is that if we don't add any predicates, we're declaring that we don't care. Speculoos proceeds without complaint.</p></div><div class="panel-footer"><span class="panel-number">19/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Stretching the principle: Validating with one predicate targeting second nested collection</h3><pre><code class="form">(validate-collections [{:a 11} 22 (list 33) 44 #{55}]
                      [{} (list list?) #{}])</code><br><code class="eval">;; => ({:datum (33),
;;      :ordinal-path-datum [1],
;;      :path-datum [2],
;;      :path-predicate [1 0],
;;      :predicate list?,
;;      :valid? true})</code></pre><div class="note"><p>One predicate+collection pair, one validation result. Nested collection is indeed a list, so <code>:valid?</code> is <code>true</code>. The <code>list?</code> predicate at path <code>[1 0]</code> in the specification was applied to the collection located at path <code>[2]</code> in the data.</p><p>Notice how <code>validate-collections</code> did some tedious and boring calculations to achieve the general effect of <em>The predicate in the second nested collection of the specification applies to the second nested collection of the data.</em> It kinda skipped over that <code>22</code> because it ignores scalars, and we're validating collections.</p><p>Basically, <code>validate-collections</code> performed that 'skip' by pruning the scalars from the data…</p></div><div class="panel-footer"><span class="panel-number">20/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Q: How did that happen? A: Pruning.</h3><table><tr><td>originals</td><td><code>[{:a 11} 22 (list 33) 44 #{55}]</code></td><td><code>[{} (list list?) #{}]</code></td></tr><tr><td>prune</td><td><pre><code>[{     }    (       )    #{  }]</code></pre></td><td><code>[{} (list list?) #{}]</code></td></tr><tr><td>paths</td><td><pre><code class="form">(all-paths [{} () #{}])</code><br><code class="eval">;; => [{:path [], :value [{} () #{}]}
;;     {:path [0], :value {}}
;;     {:path [1], :value ()}
;;     {:path [2], :value #{}}]</code></pre></td><td><pre><code class="form">(all-paths [{} (list list?) #{}])</code><br><code class="eval">;; => [{:path [], :value [{} (list?) #{}]}
;;     {:path [0], :value {}}
;;     {:path [1], :value (list?)}
;;     {:path [1 0], :value list?}
;;     {:path [2], :value #{}}]</code></pre></td></tr><tr><td>keep only</td><td>everything</td><td>{:path [1 0], :value list?}</td></tr></table><pre><code class="form">(drop-last [1 0])</code><br><code class="eval">;; => (1)</code></pre><pre><code class="form">(list? (list 33))</code><br><code class="eval">;; => true</code></pre><div class="note"><p>Notice that the specification mimics, but does not exactly copy, the shape of the data (Motto #2). May have to squint a bit, but the shape _is_ similar.</p><p>We prune all the integers away from the data, which has the effect of collapsing all the nested collections to the front of the sequential. Since the specification doesn't have any intervening predicates in its corresponding sequential, nothing changes.</p><p>We can create one pair: predicate `list?` has a 'drop-last' path that evaluates to the nested list. We can therefore apply the predicate to the one collection. Motto #3 tells us that the other collections are ignores.</p></div><div class="panel-footer"><span class="panel-number">21/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Stretching principle: Re-visiting the validation</h3><pre><code class="form">(validate-collections [{:a 11} 22 (list 33) 44 #{55}]
                      [{} (list list?) #{}])</code><br><code class="eval">;; => ({:datum (33),
;;      :ordinal-path-datum [1],
;;      :path-datum [2],
;;      :path-predicate [1 0],
;;      :predicate list?,
;;      :valid? true})</code></pre><div class="panel-footer"><span class="panel-number">22/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>More colls nested in a sequential: specification</h3><table><tr><td>data</td><td><pre><code>[{:a 11} 22 (list 33) 44 #{55 }]</code></pre></td></tr><tr><td>delete all non-scalars</td><td><pre><code>[{     }    (       )    #{   }]</code></pre></td></tr><tr><td>insert predicate</td><td><pre><code>[{     }    (       )    #{set?}]</code></pre></td></tr><tr><td>insert markers</td><td><pre><code>[{     } :skip-1 :skip-2 (       ) :skip-3 :skip-4 #{set?}]</code></pre></td></tr></table><div class="note"><p>Make the specification using familiar recipe.</p><p>Normally, wouldn't insert a non-predicate in a specification (Speculoos doesn't care, and won't stop us).</p></div><div class="panel-footer"><span class="panel-number">23/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>More colls nested in a sequential: pruning intervening scalars</h3><table><tr><th></th><th>data</th><th>specification</th></tr><tr><td>originals</td><td><code>[{:a 11} 22 (list 33) 44 #{55}]</code></td><td><code>[{} :skip-1 :skip-2 () :skip-3 :skip-4 #{set?}]</code></td></tr><tr><td>prune</td><td><pre><code>[{     }    (       )    #{  }]</code></pre></td><td><pre><code>[{}                 ()                 #{set?}]</code></pre></td></tr><tr><td>paths</td><td><pre><code class="form">(all-paths [{} () #{}])</code><br><code class="eval">;; => [{:path [], :value [{} () #{}]}
;;     {:path [0], :value {}}
;;     {:path [1], :value ()}
;;     {:path [2], :value #{}}]</code></pre></td><td><pre><code class="form">(all-paths [{} () #{set?}])</code><br><code class="eval">;; => [{:path [], :value [{} () #{set?}]}
;;     {:path [0], :value {}}
;;     {:path [1], :value ()}
;;     {:path [2], :value #{set?}}
;;     {:path [2 set?], :value set?}]</code></pre></td></tr><tr><td>keep only</td><td></td><td><code>{:path [2 set?], :value set?}</code></td></tr><tr><td>form pairs</td><td></td><td><pre><code class="form">(drop-last [2 set?])</code><br><code class="eval">;; => (2)</code></pre></td></tr><tr><td>apply predicate</td><td><pre><code class="form">(set? #{55})</code><br><code class="eval">;; => true</code></pre></td></tr></table><div class="panel-footer"><span class="panel-number">24/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>More colls nested in a sequential: validating with intervening scalars</h3><pre><code class="form">(validate-collections [{:a 11} 22 (list 33) 44 #{55}]
                      [{} :skip-1 :skip-2 () :skip-3 :skip-4 #{set?}])</code><br><code class="eval">;; => ({:datum #{55},
;;      :ordinal-path-datum [2],
;;      :path-datum [4],
;;      :path-predicate [6 set?],
;;      :predicate set?,
;;      :valid? true})</code></pre><div class="note"><p>One predicate, one collection, one validation result. Validation skipped right over the intervening scalars, <code>22</code> and <code>44</code>, in the data, and over the intervening non-predicates, <code>:skip-1</code> and <code>:skip-2</code>, etc., in the specification. <code>validate-collections</code> applied <code>set?</code> in the third nested collection to the data's third nested collection <code>#{55}</code>, both at ordinal path <code>[2]</code> (i.e., the third non-scalar elements).</p></div><div class="panel-footer"><span class="panel-number">25/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Skipping markers: data & specification</h3><table><tr><td>data</td><td><pre><code>[{:a 11    } 22 (list 33) 44 #{55}]</code></pre></td></tr><tr><td>delete all non-scalars</td><td><pre><code>[{         }    (        )   #{  }]</code></pre></td></tr><tr><td>insert predicate</td><td><pre><code>[{:foo map?}    (       )    #{  }]</code></pre></td></tr><tr><td>insert markers</td><td><pre><code>[:skip-5 :skip-6 {:foo map?}    (       )    #{  }]</code></pre></td></tr></table><div class="panel-footer"><span class="panel-number">26/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Skipping markers: manual algorithm</h3><table><tr><th></th><th>data</th><th>specification</th></tr><tr><td>originals</td><td><code>[{:a 11} 22 (list 33) 44 #{55}]</code></td><td><code>[:skip-5 :skip-6 {:foo map?} () #{}]</code></td></tr><tr><td>prune</td><td><pre><code>[{     }    (       )    #{  }]</code></pre></td><td><pre><code>[                {:foo map?} () #{}]</code></pre></td></tr><tr><td>paths</td><td><pre><code class="form">(all-paths [{} () #{}])</code><br><code class="eval">;; => [{:path [], :value [{} () #{}]}
;;     {:path [0], :value {}}
;;     {:path [1], :value ()}
;;     {:path [2], :value #{}}]</code></pre></td><td><pre><code class="form">(all-paths [{:foo map?} () #{}])</code><br><code class="eval">;; => [{:path [], :value [{:foo map?} () #{}]}
;;     {:path [0], :value {:foo map?}}
;;     {:path [0 :foo], :value map?}
;;     {:path [1], :value ()}
;;     {:path [2], :value #{}}]</code></pre></td></tr><tr><td>keep only</td><td></td><td><code>{:path [0 :foo], :value map?}</code></td></tr><tr><td>form pairs</td><td></td><td><pre><code class="form">(drop-last [0 :foo])</code><br><code class="eval">;; => (0)</code></pre></td></tr><tr><td>apply predicate</td><td><pre><code class="form">(map? {:a 11})</code><br><code class="eval">;; => true</code></pre></td></tr></table><div class="panel-footer"><span class="panel-number">27/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Skipping markers: validation</h3><pre><code class="form">(validate-collections [{:a 11} 22 (list 33) 44 #{55}]
                      [:skip-5 :skip-6 {:foo map?} () #{}])</code><br><code class="eval">;; => ({:datum {:a 11},
;;      :ordinal-path-datum [0],
;;      :path-datum [0],
;;      :path-predicate [2 :foo],
;;      :predicate map?,
;;      :valid? true})</code></pre><div class="panel-footer"><span class="panel-number">28/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating the root collection: data & specification</h3><table><tr><td>data</td><td><pre><code>[        {:a 11} 22 (list 33) 44 #{55}]</code></pre></td></tr><tr><td>delete all non-scalars</td><td><pre><code>[        {     }    (       )    #{  }]</code></pre></td></tr><tr><td>insert predicate</td><td><pre><code>[vector? {     }    (       )    #{  }]</code></pre></td></tr></table><div class="panel-footer"><span class="panel-number">29/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating the root collection: manual algorithm</h3><table><tr><th></th><th>data</th><th>specification</th></tr><tr><td>originals</td><td><code>[{:a 11} 22 (list 33) 44 #{55}]</code></td><td><code>[vector? {} () #{}]</code></td></tr><tr><td>prune</td><td><pre><code>[{     }    (       )    #{  }]</code></pre></td><td><pre><code>[vector? {} () #{}]</code></pre></td></tr><tr><td>paths</td><td><pre><code class="form">(all-paths [{} () #{}])</code><br><code class="eval">;; => [{:path [], :value [{} () #{}]}
;;     {:path [0], :value {}}
;;     {:path [1], :value ()}
;;     {:path [2], :value #{}}]</code></pre></td><td><pre><code class="form">(all-paths [vector? {} () #{}])</code><br><code class="eval">;; => [{:path [], :value [vector? {} () #{}]}
;;     {:path [0], :value vector?}
;;     {:path [1], :value {}}
;;     {:path [2], :value ()}
;;     {:path [3], :value #{}}]</code></pre></td></tr><tr><td>keep only</td><td></td><td><code>{:path [0], :value vector?}</code></td></tr><tr><td>form pairs</td><td></td><td><pre><code class="form">(drop-last [0])</code><br><code class="eval">;; => ()</code></pre></td></tr><tr><td>apply predicate</td><td><pre><code class="form">(vector? [{:a 11} 22 (list 33) 44 #{55}])</code><br><code class="eval">;; => true</code></pre></td></tr></table><div class="panel-footer"><span class="panel-number">30/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating the root collection</h3><pre><code class="form">(validate-collections [{:a 11} 22 (list 33) 44 #{55}]
                      [vector? {} () #{}])</code><br><code class="eval">;; => ({:datum [{:a 11} 22 (33) 44 #{55}],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate vector?,
;;      :valid? true})</code></pre><div class="panel-footer"><span class="panel-number">31/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Any predicate applies to its immediate parent</h3><pre><code>(validate-collections [{:a 11} 22 (list 33) 44 #{55}] [<strong>vector?</strong> {} () #{}])</code><br><code>(validate-collections [{:a 11} 22 (list 33) 44 #{55}] [{} <strong>vector?</strong> () #{}])</code><br><code>(validate-collections [{:a 11} 22 (list 33) 44 #{55}] [{} () <strong>vector?</strong> #{}])</code><br><code>(validate-collections [{:a 11} 22 (list 33) 44 #{55}] [{} () #{} <strong>vector?</strong>])</code></pre><div class="vspace"></div><pre><code>(drop-last [0]) ;; => ()</code><br><code>(drop-last [1]) ;; => ()</code><br><code>(drop-last [2]) ;; => ()</code><br><code>(drop-last [3]) ;; => ()</code></pre><div class="note"><p>Could put predicate anywhere within sequential. Substantially the same validation result.</p><p>Maybe you feel like me and find it better at the front.</p></div><div class="panel-footer"><span class="panel-number">32/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Finally, validating all collections at once: data & specification</h3><table><tr><td>data</td><td><pre><code>[        {:a 11    }  22         (list 33   ) 44   #{55  }]</code></pre></td></tr><tr><td>delete all non-scalars</td><td><pre><code>[        {         }             (          )      #{    }]</code></pre></td></tr><tr><td>insert predicates</td><td><pre><code>[vector? {:foo map?} sequential? (list list?) coll? #{set?} any?]</code></pre></td></tr></table><div class="panel-footer"><span class="panel-number">33/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating two levels: two 'phases'</h3><ol><li>root level</li><li>nested level</li></ol><div class="panel-footer"><span class="panel-number">34/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Phase 1: Validating the root level</h3><table><tr><th></th><th>data</th><th>specification</th></tr><tr><td>originals</td><td><pre><code>[{:a 11} 22 (list 33) 44 #{55}]</code></pre></td><td><pre><code>[vector? {:foo map?} sequential? (list list?) coll? #{set?} any?]</code></pre></td></tr><tr><td>prune</td><td><pre><code>[{     }    (       )    #{  }]</code></pre></td><td><pre><code>[vector? {:foo map?} sequential? (list list?) coll? #{set?} any?]</code></pre></td></tr><tr><td>paths</td><td><code>...</code></td><td><code>...</code></td></tr><tr><td>keep only</td><td><pre><code>[{:path [], :value [{:a 11} 22 (33) 44 #{55}]}
 {:path [0], :value {:a 11}}
 {:path [2], :value (33)}
 {:path [4], :value #{55}} ]</code></pre></td><td><pre><code>[{:path [0], :value vector?}
 {:path [2], :value sequential?}
 {:path [4], :value coll?}
 {:path [6], :value any?}]</code></pre></td></tr><tr><td>form pairs</td><td></td><td><pre><code>(drop-last [0]) ;; => ()</code><br><code>(drop-last [2]) ;; => ()</code><br><code>(drop-last [4]) ;; => ()</code><br><code>(drop-last [6]) ;; => ()</code></pre></td></tr><tr><td>apply predicates</td><td><pre><code>(vector? [{:a 11} 22 (list 33) 44 #{55}]) ;; => true</code><br><code>(sequential? [{:a 11} 22 (list 33) 44 #{55}]) ;; => true</code><br><code>(coll? [{:a 11} 22 (list 33) 44 #{55}]) ;; => true</code><br><code>(any? [{:a 11} 22 (list 33) 44 #{55}]) ;; => true</code></pre></td><td></td></tr></table><div class="panel-footer"><span class="panel-number">35/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Phase 2: Validating the nested level</h3><table><tr><th></th><th>data</th><th>specification</th></tr><tr><td>originals</td><td><pre><code>[{:a 11} 22 (list 33) 44 #{55}]</code></pre></td><td><pre><code>[vector? {:foo map?} sequential? (list list?) coll? #{set?} any?]</code></pre></td></tr><tr><td>prune</td><td><pre><code>[{     }    (       )    #{  }]</code></pre></td><td><pre><code>[{:foo map?} (list list?) #{set?}]</code></pre></td></tr><tr><td>paths</td><td><code>...</code></td><td><code>...</code></td></tr><tr><td>keep only</td><td><pre><code>[{:path [], :value [{:a 11} 22 (33) 44 #{55}]}
 {:path [0], :value {:a 11}}
 {:path [2], :value (33)}
 {:path [4], :value #{55}} ]</code></pre></td><td><pre><code>[{:path [0 :foo], :value map?}
 {:path [1 0], :value list?}
 {:path [2 set?], :value set?}}]</code></pre></td></tr><tr><td>form pairs</td><td></td><td><pre><code>(drop-last [0 :foo]) ;; => (0)</code><br><code>(drop-last [1 0]) ;; => (1)</code><br><code>(drop-last [2 set?]) ;; => (2)</code></pre></td></tr><tr><td>apply predicates</td><td><pre><code>(map? {:a 11}) ;; => true</code><br><code>(list? (list 33)) ;; => true</code><br><code>(set? #{55}) ;; => true</code></pre></td><td></td></tr></table><div class="panel-footer"><span class="panel-number">36/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating both levels at once</h3><pre><code class="form">(validate-collections [{:a 11} 22 (list 33) 44 #{55}]
                      [vector? {:foo? map?} sequential? (list list?) coll? #{set?} any?])</code><br><code class="eval">;; => ({:datum [{:a 11} 22 (33) 44 #{55}],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate vector?,
;;      :valid? true}
;;     {:datum {:a 11},
;;      :ordinal-path-datum [0],
;;      :path-datum [0],
;;      :path-predicate [1 :foo?],
;;      :predicate map?,
;;      :valid? true}
;;     {:datum [{:a 11} 22 (33) 44 #{55}],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [2],
;;      :predicate sequential?,
;;      :valid? true}
;;     {:datum (33),
;;      :ordinal-path-datum [1],
;;      :path-datum [2],
;;      :path-predicate [3 0],
;;      :predicate list?,
;;      :valid? true}
;;     {:datum [{:a 11} 22 (33) 44 #{55}],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [4],
;;      :predicate coll?,
;;      :valid? true}
;;     {:datum #{55},
;;      :ordinal-path-datum [2],
;;      :path-datum [4],
;;      :path-predicate [5 set?],
;;      :predicate set?,
;;      :valid? true}
;;     {:datum [{:a 11} 22 (33) 44 #{55}],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [6],
;;      :predicate any?,
;;      :valid? true})</code></pre><div class="panel-footer"><span class="panel-number">37/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><div class="panel-footer"><span class="panel-number">38/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nesting within non-sequentials: no skipping nor pruning</h3><table><tr><td>data</td><td><pre><code>{:a [99] :b (list 77)}</code></pre></td></tr><tr><td>delete scalars</td><td><pre><code>{:a [  ] :b (list   )</code></pre></td></tr><tr><td>insert predicates</td><td><pre><code>{:a [vector?] :b (list list?)} ;; collection specification</code></pre></td></tr></table><div class="note"><p>Maps aren't sequential, so no skipping or pruning. Here, we create a specification based upon this data.</p><p>Predicates `vector?` and `list?` apply to their _immediate_ parents, i.e., the map at `:a` and the list at `:b`. For now, we haven't declared any requirement of the root map itself.</p></div><div class="panel-footer"><span class="panel-number">39/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating collections nested within a non-sequential</h3><pre><code class="form">(validate-collections {:a [99], :b (list 77)}
                      {:a [vector?], :b (list list?)})</code><br><code class="eval">;; => ({:datum [99],
;;      :ordinal-path-datum [:a],
;;      :path-datum [:a],
;;      :path-predicate [:a 0],
;;      :predicate vector?,
;;      :valid? true}
;;     {:datum (77),
;;      :ordinal-path-datum [:b],
;;      :path-datum [:b],
;;      :path-predicate [:b 0],
;;      :predicate list?,
;;      :valid? true})</code></pre><div class="vspace"></div><div class="side-by-side-container"><div class="side-by-side"><pre><code class="form">(drop-last [:b 0])</code><br><code class="eval">;; => (:b)</code></pre></div><div class="side-by-side"><pre><code class="form">(drop-last [:a 0])</code><br><code class="eval">;; => (:a)</code></pre></div></div><div class="note"><p>Checklist...Mottos #1-3: _collection validation_; specification shape mimics the data (b/c we copy-pasted); un-paired datums ignored (we didn't specify the root collection)</p><p>Predicate `vector?` at path [:a 0] targets the collection at (drop-last [:a 0]). That evals to [:a], the nested vector. `[99]` is a vector, so the predicate is satisfied.</p><p>Predicate `list?` at path [:b 0] targets the collection at (drop-last [:b 0]), which evals to [:b], the nested list. `(77) is in fact a list, so the predicate is satisfied.</p><p>Since maps are *not* sequential, it doesn't matter what order the nested predicate appear, unlike the vector we studied earlier. Just like how it doesn't matter whether I eval these two `drop-last` expression 'out-of-order'.</p></div><div class="panel-footer"><span class="panel-number">40/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Specifying collections nested within a non-sequential, plus the root</h3><table><tr><td>data</td><td><pre><code>{:a [99] :b (list 77)}</code></pre></td></tr><tr><td>additional predicate</td><td><pre><code>{:a [vector?] :b (list list?) :howdy map?} ;; collection specification</code></pre></td></tr></table><div class="note"><p>Let's re-use that specification an add a sham key, `:howdy`, associated with a `map?` predicate which targets the root.</p><p>Now we have three predicates. Let's see if we can make a pair with each.</p></div><div class="panel-footer"><span class="panel-number">41/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating collections nested within a non-sequential, plus the root</h3><pre><code class="form">(validate-collections {:a [99], :b (list 77)}
                      {:a [vector?], :b (list list?), :howdy map?})</code><br><code class="eval">;; => ({:datum [99],
;;      :ordinal-path-datum [:a],
;;      :path-datum [:a],
;;      :path-predicate [:a 0],
;;      :predicate vector?,
;;      :valid? true}
;;     {:datum (77),
;;      :ordinal-path-datum [:b],
;;      :path-datum [:b],
;;      :path-predicate [:b 0],
;;      :predicate list?,
;;      :valid? true}
;;     {:datum {:a [99], :b (77)},
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [:howdy],
;;      :predicate map?,
;;      :valid? true})</code></pre><div class="vspace"></div><pre><code>(drop-last [:a 0]) ;; => (:a)</code><br><code>(drop-last [:b 0]) ;; => (:b)</code><br><code>(drop-last [:howdy]) ;; => ()</code></pre><div class="note"><p>Same two results as before due to the same predicate+collection pairs (Motto #3). Plus an additional pairing.</p><p>The `map?' predicate at `:howdy` targets the root collection because `(drop-last [:howdy])` evals to [], which locates the root collection. It's a map, so the predicate is satisfied. Three predicates paired with three collections.</p></div><div class="panel-footer"><span class="panel-number">42/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Specifying collections nested within a non-sequential, un-paired predicate</h3><table><tr><td>data</td><td><pre><code>{:a [99] :b (list 77)}</code></pre></td></tr><tr><td>delete scalars</td><td><pre><code>{:a [  ] :b (list   )}</code></pre></td></tr><tr><td>delete one key-val</td><td><pre><code>{:a [  ]             }</code></pre></td></tr><tr><td>insert one paired, one un-paired predicate</td><td><pre><code>{:a [vector?] :flamingo [coll?]} ;; collection specification</code></pre></td></tr></table><div class="vspace"></div><p><em>Fact:</em> Two predicates.</p><p><em>Quiz:</em> How many validation pairs?</p><p><em>Hint:</em> Run <code>drop-last</code> on predicates' paths.</p><div class="panel-footer"><span class="panel-number">43/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating collections nested within a non-sequential, un-paired predicate</h3><pre><code class="form">(validate-collections {:a [99], :b (list 77)}
                      {:a [vector?], :flamingo [coll?]})</code><br><code class="eval">;; => ({:datum [99],
;;      :ordinal-path-datum [:a],
;;      :path-datum [:a],
;;      :path-predicate [:a 0],
;;      :predicate vector?,
;;      :valid? true})</code></pre><div class="vspace"></div><pre><pre><code class="form">(drop-last [:a 0])</code><br><code class="eval">;; => (:a)</code></pre><pre><code class="form">(drop-last [:flamingo 0])</code><br><code class="eval">;; => (:flamingo)</code></pre></pre><div class="note"><p>Motto #3: Ignore un-paired data elements and un-paired predicates. Okay, then. How many pairs can we make?</p><p>Two predicates. Predicate `vector?` has a `drop-last` path of [], which we've seen before targets its immediate parent. So that's one pair.</p><p>Predicate `coll?` is at path [:flamingo 0]. `(drop-last [:flamingo 0])` evals to path [:flamingo]. The data does not contain *any* element there, much less a collection. So `coll?` is ignored.</p><p>One paired collection+predicate. One validation result.</p></div><div class="panel-footer"><span class="panel-number">44/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Specifying a nested collection in a non-sequential, plus the root</h3><table><tr><td>data</td><td><pre><code>{:a [99] :b (list 77)}</code></pre></td></tr><tr><td>delete scalars</td><td><pre><code>{:a [  ] :b (list   )}</code></pre></td></tr><tr><td>delete one key-val</td><td><pre><code>{:a [  ]             }</code></pre></td></tr><tr><td>insert two paired predicates</td><td><pre><code>{:a [vector?] :emu coll?} ;; collection specification</code></pre></td></tr></table><div class="note"><p>Perhaps we intended to specify and validate the root map. How would we actually do that. Similar procedure. Cut-paste data, delete scalars.</p><p>Insert the `vector?` predicate so that it will validate its immediate parent. That's the critical point. We need to insert the predicate that will target the root map so that the root map is the immediate parent of that predicate. That's when we use a sham key. `:foo` works fine, but `:emu` is fun, too. And it doesn't matter what the key is as long as it doesn't block validating a nested collection. The data contains only `:a` and `:b`, so `:emu` doesn't interfere.</p><p>No judgment on flamingos vs emus. I merely thought they were fun.</p></div><div class="panel-footer"><span class="panel-number">45/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating a nested collection in a non-sequential, plus the root</h3><pre><code class="form">(validate-collections {:a [99], :b (list 77)}
                      {:a [vector?], :emu coll?})</code><br><code class="eval">;; => ({:datum [99],
;;      :ordinal-path-datum [:a],
;;      :path-datum [:a],
;;      :path-predicate [:a 0],
;;      :predicate vector?,
;;      :valid? true}
;;     {:datum {:a [99], :b (77)},
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [:emu],
;;      :predicate coll?,
;;      :valid? true})</code></pre><div class="vspace"></div><pre><pre><code class="form">(drop-last [:a 0])</code><br><code class="eval">;; => (:a)</code></pre><pre><code class="form">(drop-last [:emu])</code><br><code class="eval">;; => ()</code></pre></pre><div class="note"><p>*Now* we have two pairs of collections+predicates. Both predicates apply to their immediate parent container. `vector?` targets the nested [99], and `coll?` targets the root collection, the outer map.</p><p>Right-trimming the predicate's path with `drop-last` produces the empty path, which properly targets the root map as we intended.</p></div><div class="panel-footer"><span class="panel-number">46/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Remember these principles when validating collections</h3><ol><li>Specification shape mimics the data (Motto #2).</li><li><em>All</em> predicates apply to the <em>immediate</em> collections that <em>contain</em> them.</li><li>Maps: predicates at keys that not in  data.</li><li>Collections nested in sequentials: predicates apply to immediate parent, ignoring intervening scalars. </li><li>Collections nested in maps not affected by order.</li></ol><div class="note"><p>Don't get dazzled by the details. We just need to remember these operating principles.</p></div><div class="panel-footer"><span class="panel-number">47/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>More than one level of nesting</h3><p>Validate any heterogeneous, arbitrarily-nested data structure</p><pre><code class="form">(validate-collections [99 88 77 {:x (list 66 55 {:y [44 33 22 11 #{42}]})}]
                      [{:x (list {:y [#{set?}]})}])</code><br><code class="eval">;; => ({:datum #{42},
;;      :ordinal-path-datum [0 :x 0 :y 0],
;;      :path-datum [3 :x 2 :y 4],
;;      :path-predicate [0 :x 0 :y 0 set?],
;;      :predicate set?,
;;      :valid? true})</code></pre><div class="note"><p>Even though all the examples we covered in this discussion were 'one level deep' --- e.g., a map nested in a vector --- Speculoos can validate any collection nested to any arbitrary depth, of any mixture of Clojure collection types.</p><p>For example, here we have a set, nested in a vector, nested in a list, nested in a map, nested in a vector. Five levels deep. No problem!</p><p>Notice how the principles apply: The `set?` predicate applies to its immediate parent collection, the set `#{42}` in the data. The specification is shaped to mimic the data. And we only made one collection+predicate pair, so there is only one validation result.</p></div><div class="panel-footer"><span class="panel-number">48/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>What's next.</h3><ol class="de-highlight whats-next"><li>Introduction</li><li>Mechanics</li><li>Validating Scalars</li><li>Validating Collections, Basics</li><li>Validating Collections, Advanced</li><li class="highlight">Validating Collections, Extras</li><li>Validation Summaries & Thoroughness</li><li>Function Validation</li><li>Generating Random Samples & Exercising</li><li>Utilities</li><li>Predicates</li><li>Non-Terminating Sequences</li><li>Sets</li><li>Troubleshooting</li><li>Comparing spec.alpha to Speculoos</li><li>Perhaps So</li><li>Case Study</li></ol><div class="note"><p>Now that we've discussed both basic and advanced collection validations, if you're interested, we have a third, short screencast discussing some odd-and-ends of collection validation.</p><p>Otherwise, feel free to continue with the screencast covering validation summaries and 'thorough' validations, utilities that augment Motto #3 concerning ignored data elements.</p></div><div class="panel-footer"><span class="panel-number">49/49</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><p id="page-footer">Copyright © 2024 Brad Losavio.<br>Compiled 2024 December 03.<div class="license"><p>This program and the accompanying materials are made available under the terms of the <a href="https://opensource.org/license/MIT">MIT License</a>.</p></div><span id="uuid"><br>a1b90c85-fc65-4065-a21a-8f5baba2e05d</span></p></body></head></html>