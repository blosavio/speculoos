<!DOCTYPE html>
<html lang="en"><head><link href="speculoos_screencast.css" rel="stylesheet" type="text/css"><script src="jquery-3.7.1.min.js" type="text/javascript"></script><script src="speculoos_screencast.js" type="text/javascript"></script><title>Speculoos — An experimental Clojure lib for data specification</title><meta charset="utf-8" compile-date="2024-10-25 07:09:14" content="width=device-width, initial-scale=1" name="viewport"><body><div class="panel"><div class="panel-header"></div><h1>Speculoos Screencast 4 — Collection Validation</h1><p>So far…</p><pre><code class="form">(valid-scalars? [42 "abc" 22/7]
                [int? string? ratio?])</code><br><code class="eval">;; => true</code></pre><div class="note"><p>You may have been bothered about something while going through the 'scalar validation' screencast. Every example we've seen so far shows Speculoos validating individual scalars, such as integers, strings, booleans, etc.</p><p>However, we might need to specify some property of a collection itself, such as a vector's length, the presence of a key in a map, relationships <em>between</em> datums, etc. That is <em>collection validation</em>.</p></div><div class="panel-footer"><span class="panel-number">1/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Scalars versus Collections</h3><table><tr><td>scalars</td><td><code><span class="de-highlight">[</span><span class="highlight">42</span><span class="de-highlight"> {:x </span><span class="highlight">"abc"</span><span class="de-highlight"> :y </span><span class="highlight">22/7</span><span class="de-highlight">}]</span></code></td></tr><tr><td>collections</td><td><code><span class="highlight">[</span><span class="de-highlight">42</span><span class="highlight"> {:x </span><span class="de-highlight">"abc"</span><span class="highlight"> :y </span><span class="de-highlight">22/7</span><span class="highlight">}]</span></code></td></tr></table><div class="note"><p>This is one way to visualize the difference. Scalar validation targets only the scalars: numbers, strings, characters, etc.. Collection validation only validates the collections themselves: vectors, maps, sequences, lists, sets. We could kinda think about it as validating the brackets, parens, braces, etc.</p></div><div class="panel-footer"><span class="panel-number">2/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3><em>Validating</em> scalars versus <em>validating</em> collections</h3><code>speculoos.core/validate-scalars</code><div class="vspace"></div><code>speculoos.core/validate-collections</code><div class="note"><p>One of Speculoos' main concepts is that scalars are specified and validated explicitly separately from collections. You perhaps noticed that the function name we have been using wasn't <code>validate</code> but instead <code>validate-scalars</code>. Speculoos provides a parallel group of functions to validate the properties of collections, independent of the scalar values they contain. Let's examine why and how they're separated.</p></div><div class="panel-footer"><span class="panel-number">3/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>When to validate collections versus validating scalars #1</h3><h4>Validate property of the collection</h4><p>Examples</p><ul><li>Size of a collection: <code>#(< 10 (count %))</code></li><li>Existence of an element: <code>#(contains? % :email)</code></li></ul><div class="note"></div><div class="panel-footer"><span class="panel-number">4/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>When to validate collections versus validating scalars #2</h3><h4>Validation relationship between scalars</h4><p>Examples</p><ul><li>Second element equal to first: <code>#(= (get % 0) (get % 1))</code></li><li>All elements ascending: <code>#(apply < %)</code></li></ul><div class="note"><p>Don't have to pick _just_ scalar or collection. We can do both and use the advantages of each.</p></div><div class="panel-footer"><span class="panel-number">5/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>★ Three Mottos</h3><ol class="side-by-side-by-side-container"><div class="side-by-side-by-side"><li>Validate scalars separately from validating collections.</li><div class="vspace"></div><p>scalars:<br><code>&emsp;&emsp;42, "abc", \c, 22/7, :kw, 'foo, true, nil</code></p><div class="vspace"></div><p>collections:<br><code>&emsp;&emsp;[…], {…}, (…), #{…}</code></p><div class="note"><p>Distinct functions for validating scalars and collections in HANDS. Advantages:<ol><li>Simpler. No mini-language that mixes identities and quantities. Specs Cloj data structures w/functions. Manipulate specs w/anything, e.g. <code>assoc-in</code> No macros.</li><li>Mental clarity. Validation only applies to scalar, or to collection, never both. Predicate doesn't have to know anything about the quantity or location of the element.</li><li>Only specify as much, or as little, as necessary. If only a few scalars, won't be forced to specify a property concerning a collection.</li></ol></p></div></div><div class="side-by-side-by-side"><li>Shape the specification to mimic the data.</li><div>data</div><div>↓</div><pre><code>{:x 42   :y "abc"  }</code><br><code>{:x int? :y string?}</code></pre><div>↑</div><div>specification</div><div class="note"><p>Composing specs straightforward; mimic shape of data. Arrangement of nested vectors, lists, maps, sequences, and sets that contain predicates. Pattern instruct the validation functions where to apply the predicates. Spec for a vector is a vector. Spec for a map, is a map. ~1-to-1 correspondence b/t shape of data and shape of specific. Strategy: copy-paste data, delete contents,  use as a template, replace elements with predicates. Peek at by eye — merely eval them at <span class="small-caps">repl</span> — easy alteration: any Clojure data wrangling functions to tighten, relax, or remove portions of spec. <code>assoc-in</code>, <code>update-in</code>, & <code>dissoc</code>.</p></div></div><div class="side-by-side-by-side"><li>Ignore un-paired predicates and un-paired datums.</li><div>data</div><div>↓</div><pre><code>{:x 42   <s>:y "abc"</s>}</code><br><code>{:x int? <s>:q double?</s>}</code></pre><div>↑</div><div>specification</div><div class="note"><p>Ignoring -> Flexibility, power, optionality, and re-usability. Ex #1: pipeline. Supplying predicates for subset of datums only validates those specified datums while being agnostic towards the other datums. Ex #2 Sprawling specification that describes a myriad of data about a person, postal address,  contact info, etc. B/c a spec just  data structure with regular predicates, can, on-the-fly, <code>get-in</code> portion relevant to postal addresses and apply that to our particular instances of address data. Specify exactly what elements we'd like to validate. No more, no less.</p></div></div></ol><div class="note"><p>Three Mottos speaker notes</p></div><div class="panel-footer"><span class="panel-number">6/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Motivational quick example #1: validate vector length</h3><pre><code>(require '[speculoos.core :refer [valid-collections?]])</code></pre><div class="vspace"></div><pre><code>(defn length-3? [v] (= 3 (count v)))</code></pre><div class="vspace"></div><pre><code class="form">(valid-collections? [42 "abc" 22/7]
                    [length-3?])</code><br><code class="eval">;; => true</code></pre><div class="note"><p>3 Mottos: Collection validation, see fn name. Specification mimics shape of data. Everything was paired; nothing ignored.</p><p>Note: Predicates apply to their immediate parent collections. `length-3?` targets the vector, not scalar `42`.</p></div><div class="panel-footer"><span class="panel-number">7/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Motivational quick example #2: validate key in map</h3><pre><code>(defn map-contains-keyword-y? [m] (contains? m :y))</code></pre><div class="vspace"></div><pre><code class="form">(valid-collections? {:x 42}
                    {:foo map-contains-keyword-y?})</code><br><code class="eval">;; => false</code></pre><div class="note"><p>Ignore `:foo` for the moment. Notice: specification shape mimics shape of data (but not exact copy).</p></div><div class="panel-footer"><span class="panel-number">8/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Motivational quick example #3: validate two arguments</h3><pre><code>(defn even-args-fn-call? [f] (even? (count (rest f))))</code></pre><div class="vspace"></div><pre><code class="form">(valid-collections? (list < 1 2)
                    (list even-args-fn-call?))</code><br><code class="eval">;; => true</code></pre><div class="note"><p>Validating aspects of the number of elements in a collection is only possible with the whole collection, not merely the scalars.</p></div><div class="panel-footer"><span class="panel-number">9/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Motivational quick example #4: all set members even number</h3><pre><code>(defn all-odd? [s] (every? odd? s))</code></pre><div class="vspace"></div><pre><code class="form">(valid-collections? #{1 2 3}
                    #{all-odd?})</code><br><code class="eval">;; => false</code></pre><div class="note"><p>All these examples require access to the entire collection. None could be accomplished with a scalar validation.</p></div><div class="panel-footer"><span class="panel-number">10/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Where collection predicates apply #1</h3><h4>Predicates apply to their <em>parent</em> collection.</h4><pre><code class="form">(valid-collections? [42 "abc" 22/7]
                    [vector?])</code><br><code class="eval">;; => true</code></pre><div class="note"><p>Predicate `vector?` is applied to the parent container, not the integer `42`.</p></div><div class="panel-footer"><span class="panel-number">11/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Where collection predicates apply #2</h3><h4>Predicates apply to their <em>immediate</em> parent collection.</h4><pre><code class="form">(valid-collections? [[42 "abc" 22/7]]
                    [[length-3?]])</code><br><code class="eval">;; => true</code></pre><div class="note"><p>Predicate `length-3?` is applied to the immediate parent vector, not the grand-parent. The immediate parent has three elements, so the validation returns `true`.</p><p>The outer/root collection wasn't paired, so it was ignored (Motto #3).</p></div><div class="panel-footer"><span class="panel-number">12/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Where collection predicates apply #3</h3><h4><em>Any</em> predicates apply to their immedicate parent collection.</h4><pre><code class="form">(valid-collections? [42 "abc" 22/7]
                    [coll? vector? sequential?])</code><br><code class="eval">;; => true</code></pre><div class="note"><p>All three predicates are applied to the vector, not only the first one. Scalar validation: 1-to-1 predicate-to-scalar. Collection validation: many-to-1 predicate-to-coll.</p><p>Applying predicates to their parent collection allows us to write specifications whose shape mimic the shape of the data.</p><p>3 Mottos + targeting parent collection are an emergent property of the collection validation algorithm. If we understand the algorithm, we can write clear, correct, and expressive collection specifications.</p></div><div class="panel-footer"><span class="panel-number">13/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>How collection validation works</h3><h4>Collection predicate</h4><pre><code>(defn len-3? [c] (= 3 (count c)))</code></pre><div class="note"><p>Imagine we wanted to specify that our data vector was exactly three elements long. We might reasonably write this predicate, whose argument is a collection.</p><p>`len-3?` is a predicate that returns `true` if the collection has three elements</p><p>Notice that this predicate tests a property of the collection itself: the number of elements it contains. <code>validate-scalars</code> has no way to do this kind of test because it deliberately only considers scalars.</p></div><div class="panel-footer"><span class="panel-number">14/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>All-paths of a Vector.</h3><p><em>A vector, containing exactly three elements.</em></p><pre><code class="form">(all-paths [42 "abc" 22/7])</code><br><code class="eval">;; => [{:path [], :value [42 "abc" 22/7]}
;;     {:path [0], :value 42}
;;     {:path [1], :value "abc"}
;;     {:path [2], :value 22/7}]</code></pre><div class="note"><p>Imagine we want to specify that our data vector was exactly three elements long. The paths of that data might look like this.</p><p>Since we're now interested in specifying collections, we'll discard the <em>scalars</em> and focus only on the <em>collections</em>. In this case, there's only one collection, the vector at path <code>[]</code>, which signifies that it's the root collection.</p></div><div class="panel-footer"><span class="panel-number">15/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Collection specification: construction strategy</h3><pre><code>[42 "abc" 22/7] ;; copy-paste data</code></pre><div class="vspace"></div><pre><code>[             ] ;; delete scalars</code></pre><div class="vspace"></div><pre><code>[len-3?       ] ;; insert predicate</code></pre><div class="note"><p>We're validating collections (Motto #1), so we're only interested in the root collection at path <code>[]</code> in the data. Let's apply Motto #2 and shape our specification to mimic the shape of the data. We'll copy-paste the data…</p><p>That will be our specification. Notice: during collection validation, we insert predicates <em>inside</em> the collection that they target.</p></div><div class="panel-footer"><span class="panel-number">16/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Collection validation algorithm</h3><ol class="collection-algorithm"><li><code>All-paths</code> data, then specification</li><li><s>scalar</s> elements from the data</li><li><s>non-predicate</s> elements from the specification</li><li>Pair via paths: <em>path</em> to <code>(drop-last <em>path</em>)</code>; discard un-paired</li><li>Apply predicates</li></ol><div class="note"><p>Validating collections uses a <em>slightly</em> adjusted version of the <a href="#scalar-algorithm">scalar validation algorithm</a>. (If you are curious <em>why</em> the collection algorithm is different, see <a href="#collection-predicate-paths">this later subsection</a>.) The algorithm for validating collections is this.</p><p>There are two main differences: We keep only the _collections_ from the data instead of the scalars (Motto #1). Predicates and their target do not share the exact same path. Instead, predicate at path pairs with collection at `(drop-last path)`.</p></div><div class="panel-footer"><span class="panel-number">17/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Manual collection validation #1: Enumerate paths</h3><div class="side-by-side-container"><div class="side-by-side"><div>data</div><div class="vspace"></div><pre><code class="form">(all-paths [42 "abc" 22/7])</code><br><code class="eval">;; => [{:path [], :value [42 "abc" 22/7]}
;;     {:path [0], :value 42}
;;     {:path [1], :value "abc"}
;;     {:path [2], :value 22/7}]</code></pre></div><div class="side-by-side"><div>specification</div><div class="vspace"></div><div class="vspace"></div><div class="vspace"></div><pre><code class="form">(all-paths [len-3?])</code><br><code class="eval">;; => [{:path [], :value [len-3?]}
;;     {:path [0], :value len-3?}]</code></pre></div></div><div class="note"><p>Let's perform that algorithm manually. We run <code>all-paths</code> on both the data……and <code>all-paths</code> on our collection specification.</p></div><div class="panel-footer"><span class="panel-number">18/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Manual collection validation #2: Keep only…</h3><div class="side-by-side-container"><div class="side-by-side"><div>…collections from data</div><pre><code>[{:path [], :value [42 "abc" 22/7]}]</code></pre></div><div class="side-by-side"><div>…predicates from specification</div><pre><code>[{:path [0], :value len-3?}]</code></pre></div></div><div class="note"><p>We discard all scalar elements of the data, keeping only the collection elements. And we keep only the predicate elements of the specification.</p></div><div class="panel-footer"><span class="panel-number">19/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Manual collection validation #3: Pair collections with predicates</h3><div class="side-by-side-container"><div class="side-by-side"><div>path of coll in data</div><pre><code>[]</code></pre></div><div class="side-by-side"><div>path of predicate in specification</div><pre><code class="form">(drop-last [0])</code><br><code class="eval">;; => ()</code></pre><div class="vspace"></div><pre><code class="form">(= [] (drop-last [0]))</code><br><code class="eval">;; => true</code></pre></div></div><div class="note"><p>The root collection's is path <code>[]</code>; <code>len-3?</code> predicate's path is <code>[0]</code>. <code>(drop-last [0])</code> evaluates to <code>()</code>, which is equivalent. So the predicate and the collection are paired.</p></div><div class="panel-footer"><span class="panel-number">20/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Manual collection validation #4: Apply predicates</h3><pre><code class="form">(len-3? [42 "abc" 22/7])</code><br><code class="eval">;; => true</code></pre><div class="note"><p> We then apply the predicate. The data vector is indeed three elements long, so predicate `len-3?` is satisfied.</p></div><div class="panel-footer"><span class="panel-number">21/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Collection validation: flat vector</h3><pre><code>(require '[speculoos.core :refer [validate-collections]])</code></pre><div class="vspace"></div><pre><code class="form">(validate-collections [42 "abc" 22/7]
                      [len-3?])</code><br><code class="eval">;; => ({:datum [42 "abc" 22/7],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate len-3?,
;;      :valid? true})</code></pre><div class="note"><p>That's familiar. <code>validate-collections</code> shows every collection+predicate pair. In this case, the data's root vector was paired with the single <code>len-3?</code>predicate. The <code>:datum</code> represents the thing being tested, the <code>:predicate</code>s indicate the predicate functions, and <code>valid?</code> reports whether that predicate was satisfied. The root vector contains three elements, so <code>len-3?</code> was satisfied.</p><p>There are now three things that involve some notion of a path. The predicate was found at <code>:path-predicate</code> in the specification. The datum was found at <code>:ordinal-path-datum</code> in the data, which is also presented in a more friendly format as the literal path <code>:path-datum</code>. (We'll explain the terms embodied by these keywords as the discussion progresses.) Notice that the path of the root vector <code>[]</code> is equivalent to running <code>drop-last</code> on the path of the <code>len-3?</code> predicate: <code>(drop-last [0])</code> evaluates to <code>()</code>.</p></div><div class="panel-footer"><span class="panel-number">22/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested vector: data, predicates, & specification</h3><table><tr><td>data</td><td><pre><code>[42 ["abc" 22/7]]</code></pre></td><div class="vspace"></div></tr><tr><td>predicates</td><td><pre><code>(defn len-2? [c] (= 2 (count c)))</code></pre><pre><code>(defn len-3? [c] (= 3 (count c)))</code></pre><div class="vspace"></div></td></tr><tr><td>specification</td><td><pre><code>[42     ["abc" 22/7]] ;; copy-paste data</code><br><code>[       [          ]] ;; delete scalars</code><br><code>[len-3? [len-2?    ]] ;; insert predicates</code></pre></td></tr></table><div class="note"><p>Let's explore validating a two-element vector nested within a two-element vector. To test whether each of those two vectors contain two elements, we could write this collection predicate.</p><p>Remember Motto #1: This predicate accepts a collection, <code>c</code>, not a scalar.</p><p>We'll invent some data, a two-element vector nested within a two-element vector by wrapping the final two elements inside an additional pair of brackets.</p><p>Note that the outer root vector contains exactly two elements: one scalar <code>42</code> and one descendant collection, the nested vector <code>["abc" 22/7]</code>.</p><p>Following Motto #2, we'll compose a collection specification whose shape mimics the shape of the data. We copy-paste the data, delete the scalars, and insert our predicates.</p><p>(I've re-used the <code>len-3?</code> predicate so that in the following examples, it'll be easier to keep track of which predicate goes where when we have multiple predicates.)</p></div><div class="panel-footer"><span class="panel-number">23/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested vector #1: Enumerate paths</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code class="form">(all-paths [42 ["abc" 22/7]])</code><br><code class="eval">;; => [{:path [], :value [42 ["abc" 22/7]]}
;;     {:path [0], :value 42}
;;     {:path [1], :value ["abc" 22/7]}
;;     {:path [1 0], :value "abc"}
;;     {:path [1 1], :value 22/7}]</code></pre></div><div class="side-by-side"><div class="vspace"></div><div class="vspace"></div><div class="vspace"></div><pre><code class="form">(all-paths [len-3? [len-2?]])</code><br><code class="eval">;; => [{:path [], :value [len-3? [len-2?]]}
;;     {:path [0], :value len-3?}
;;     {:path [1], :value [len-2?]}
;;     {:path [1 0], :value len-2?}]</code></pre></div></div><div class="panel-footer"><span class="panel-number">24/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested vector #2: Keep only…</h3><div class="side-by-side-container"><div class="side-by-side"><div>…collections from data</div><pre><code>[{:path [], :value [42 ["abc" 22/7]]}
 {:path [1], :value ["abc" 22/7]}]</code></pre></div><div class="side-by-side"><div>…predicates from specification</div><pre><code>[{:path [0], :value len-3?}
 {:path [1 0], :value len-2?}]</code></pre></div></div><div class="panel-footer"><span class="panel-number">25/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested vector #3: Pair collections with predicates</h3><div class="side-by-side-container"><div class="side-by-side"><div>paths of collections in data</div><pre><code>[]</code></pre><pre><code>[1]</code></pre></div><div class="side-by-side"><div>path of predicates in specification</div><pre><code class="form">(drop-last [0])</code><br><code class="eval">;; => ()</code></pre><pre><code class="form">(= [] (drop-last [0]))</code><br><code class="eval">;; => true</code></pre><div class="vspace"></div><pre><code class="form">(drop-last [1 0])</code><br><code class="eval">;; => (1)</code></pre><pre><code class="form">(= [1] (drop-last [1 0]))</code><br><code class="eval">;; => true</code></pre></div></div><div class="note"><p>Scalar validation: share exact paths, but collection validation: collection at `(drop-last path)`, predicate at `path`. The practical effect: the predicate applies to the immediate parent.</p></div><div class="panel-footer"><span class="panel-number">26/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested vector #4: Apply predicates</h3><pre><code class="form">(len-3? [42 ["abc" 22/7]])</code><br><code class="eval">;; => false</code></pre><div class="vspace"></div><pre><code class="form">(len-2? ["abc" 22/7])</code><br><code class="eval">;; => true</code></pre><div class="note"><p>Nested vector satisfies predicate, but root doesn't; it only has two elements: the scalar `42` and the nested vector.</p></div><div class="panel-footer"><span class="panel-number">27/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Collection validation: nested vector</h3><pre><code class="form">(validate-collections [42 ["abc" 22/7]]
                      [len-3? [len-2?]])</code><br><code class="eval">;; => ({:datum [42 ["abc" 22/7]],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate len-3?,
;;      :valid? false}
;;     {:datum ["abc" 22/7],
;;      :ordinal-path-datum [0],
;;      :path-datum [1],
;;      :path-predicate [1 0],
;;      :predicate len-2?,
;;      :valid? true})</code></pre><div class="note"><p>Perform algorithm with one invovacation. Two pairs of predicates+collections, two validation entries. `len-3?` not satisfied, `len-2?` was satisfied.</p></div><div class="panel-footer"><span class="panel-number">28/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested nested vector: data, predicates, & specification</h3><table><tr><td>data</td><td><pre><code>[42 ["abc" [22/7]]]</code></pre><div class="vspace"></div></td></tr><tr><td>predicates</td><td><pre><code>(defn len-1? [c] (= 1 (count c)))</code></pre><pre><code>(defn len-2? [c] (= 2 (count c)))</code></pre><pre><code>(defn len-3? [c] (= 3 (count c)))</code></pre><div class="vspace"></div></td></tr><tr><td>specification</td><td><pre><code>[42     ["abc"  [22/7  ]]] ;; copy-paste data</code></pre><pre><code>[       [       [      ]]] ;; remove scalars</code></pre><pre><code>[len-3? [len-2? [len-1?]]] ;; insert predicates</code></pre></td></tr></table><div class="note"><p>One additional nested vector, one additional nested predicate. Three predicates, three collections. Specification properly mimics shape of data, so all three will be paired.</p></div><div class="panel-footer"><span class="panel-number">29/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested nested vector #1: Enumerate paths</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code class="form">(all-paths [42 ["abc" [22/7]]])</code><br><code class="eval">;; => [{:path [], :value [42 ["abc" [22/7]]]}
;;     {:path [0], :value 42}
;;     {:path [1], :value ["abc" [22/7]]}
;;     {:path [1 0], :value "abc"}
;;     {:path [1 1], :value [22/7]}
;;     {:path [1 1 0], :value 22/7}]</code></pre></div><div class="side-by-side"><div class="vspace"></div><div class="vspace"></div><div class="vspace"></div><pre><code class="form">(all-paths [len-3? [len-2? [len-1?]]])</code><br><code class="eval">;; => [{:path [], :value [len-3? [len-2? [len-1?]]]}
;;     {:path [0], :value len-3?}
;;     {:path [1], :value [len-2? [len-1?]]}
;;     {:path [1 0], :value len-2?}
;;     {:path [1 1], :value [len-1?]}
;;     {:path [1 1 0], :value len-1?}]</code></pre></div></div><div class="note"><p>Collection validation, so we're only interested in three collection elements of data, and predicate elements of specification.</p></div><div class="panel-footer"><span class="panel-number">30/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested nested vector #2: Keep only…</h3><div class="side-by-side-container"><div class="side-by-side"><div>…collections from the data</div><pre><code>[{:path [], :value [42 ["abc" [22/7]]]}
 {:path [1], :value ["abc" [22/7]]}
 {:path [1 1], :value [22/7]}]</code></pre></div><div class="side-by-side"><div>…predicates from the specification</div><pre><code>[{:path [0], :value len-3?}
 {:path [1 0], :value len-2?}
 {:path [1 1 0], :value len-1?}]</code></pre></div></div><div class="note"><p>Keep only collections and predicates.</p></div><div class="panel-footer"><span class="panel-number">31/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested nested vector #3: Pair collections with predicates</h3><div class="side-by-side-container"><div class="side-by-side"><div>paths of collections in data</div><pre><code>[]</code></pre><pre><code>[1]</code></pre><pre><code>[1 1</code></pre></div><div class="side-by-side"><div>path of predicates in specification</div><pre><code class="form">(drop-last [0])</code><br><code class="eval">;; => ()</code></pre><pre><code class="form">(drop-last [1 0])</code><br><code class="eval">;; => (1)</code></pre><pre><code class="form">(drop-last [1 1 0])</code><br><code class="eval">;; => (1 1)</code></pre><div class="vspace"></div><pre><code class="form">(= [] (drop-last [0]))</code><br><code class="eval">;; => true</code></pre><pre><code class="form">(= [1] (drop-last [1 0]))</code><br><code class="eval">;; => true</code></pre><pre><code class="form">(= [1] (drop-last [1 1 0]))</code><br><code class="eval">;; => false</code></pre></div></div><div class="note"><p>The `drop-last` procedure has the practical result that the predicates will apply to their immediate parent. Each of the three forms a pair.</p></div><div class="panel-footer"><span class="panel-number">32/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested nested vector #4: Apply predicates</h3><pre><code class="form">(len-3? [42 ["abc" [22/7]]])</code><br><code class="eval">;; => false</code></pre><div class="vspace"></div><pre><code class="form">(len-2? ["abc" [22/7]])</code><br><code class="eval">;; => true</code></pre><div class="vspace"></div><pre><code class="form">(len-1? [22/7])</code><br><code class="eval">;; => true</code></pre><div class="panel-footer"><span class="panel-number">33/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Collection validation: nested nested vector</h3><pre><code class="form">(validate-collections [42 ["abc" [22/7]]]
                      [len-3? [len-2? [len-1?]]])</code><br><code class="eval">;; => ({:datum [42 ["abc" [22/7]]],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate len-3?,
;;      :valid? false}
;;     {:datum ["abc" [22/7]],
;;      :ordinal-path-datum [0],
;;      :path-datum [1],
;;      :path-predicate [1 0],
;;      :predicate len-2?,
;;      :valid? true}
;;     {:datum [22/7],
;;      :ordinal-path-datum [0 0],
;;      :path-datum [1 1],
;;      :path-predicate [1 1 0],
;;      :predicate len-1?,
;;      :valid? true})</code></pre><div class="note"><p>Data, upper row; specification, lower row. Same result as manual algorithm. Three predicate+collection pairs, three validation results. `len-3?` again wasn't satisfied. Other two were.</p></div><div class="panel-footer"><span class="panel-number">34/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Flat map: data, predicate, & specification</h3><table><tr><td>data</td><td><pre><code>{:x 42}</code></pre></td></tr><tr><td>predicate</td><td><pred><code>map?</code></pred></td></tr><tr><td><div class="vspace"></div></td></tr><tr><td>specification</td><td><pre><code>{:x 42    } ;; copy-paste data</code></pre><pre><code>{         } ;; remove scalars</code></pre><pre><code>{map?     } ;; => java.lang.RuntimeException...</code></pre><pre><code>{:foo map?} ;; insert predicate</code></pre></td></tr></table><div class="note"></div><div class="panel-footer"><span class="panel-number">35/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Flat map #1: Enumerate paths</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code class="form">(all-paths {:x 42})</code><br><code class="eval">;; => [{:path [], :value {:x 42}}
;;     {:path [:x], :value 42}]</code></pre></div><div class="side-by-side"><pre><code class="form">(all-paths {:foo map?})</code><br><code class="eval">;; => [{:path [], :value {:foo map?}}
;;     {:path [:foo], :value map?}]</code></pre></div></div><div class="note"></div><div class="panel-footer"><span class="panel-number">36/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Flat map #2: Keep only…</h3><div class="side-by-side-container"><div class="side-by-side"><div>…collections from the data</div><pre><code>[{:path [], :value {:x 42}}]</code></pre></div><div class="side-by-side"><div>…predicates from the specification</div><pre><code>[{:path [:foo], :value map?}]</code></pre></div></div><div class="note"></div><div class="panel-footer"><span class="panel-number">37/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Flat map #3: Pair collections with predicates</h3><div class="side-by-side-container"><div class="side-by-side"><div>paths of collections in data</div><pre><code>[]</code></pre></div><div class="side-by-side"><div>path of predicate in specification</div><pre><code class="form">(drop-last [:foo])</code><br><code class="eval">;; => ()</code></pre><div class="vspace"></div><pre><code class="form">(= [] (drop-last [:foo]))</code><br><code class="eval">;; => true</code></pre></div></div><div class="note"></div><div class="panel-footer"><span class="panel-number">38/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Flat map #4: Apply predicates</h3><pre><code class="form">(map? {:x 42})</code><br><code class="eval">;; => true</code></pre><div class="note"></div><div class="panel-footer"><span class="panel-number">39/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Collection validation: flat map</h3><pre><code class="form">(validate-collections {:x 42}
                      {:foo map?})</code><br><code class="eval">;; => ({:datum {:x 42},
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [:foo],
;;      :predicate map?,
;;      :valid? true})</code></pre><div class="note"></div><div class="panel-footer"><span class="panel-number">40/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Predicate's key itself is irrelevant (mostly)</h3><pre><code>(drop-last [:foo]) ;; => ()</code><br><code>(drop-last [:bar]) ;; => ()</code><br><code>(drop-last [:baz]) ;; => ()</code></pre><div class="vspace"></div><p>But, don't use a key that appears in the data!</p><div class="note"><p>The next example shows why not.</p></div><div class="panel-footer"><span class="panel-number">41/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested map: data, predicate, & specification (non-ideal specification)</h3><table><tr><td>data</td><td><pre><code>{:x 42 :y {:z "abc"}}</code></pre></td></tr><tr><td>predicate</td><td><pred><code>map?</code></pred></td></tr><tr><td><div class="vspace"></div></td></tr><tr><td>specification</td><td><pre><code>{:x 42 :y {:z "abc"}} ;; copy-paste data</code></pre><pre><code>{      :y           } ;; remove scalars</code></pre><pre><code>{      :y map?      } ;; insert predicate</code></pre></td></tr></table><div class="note"></div><div class="panel-footer"><span class="panel-number">42/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested map #1: Enumerate paths (non-ideal specification)</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code class="form">(all-paths {:x 42, :y {:z "abc"}})</code><br><code class="eval">;; => [{:path [], :value {:x 42, :y {:z "abc"}}}
;;     {:path [:x], :value 42}
;;     {:path [:y], :value {:z "abc"}}
;;     {:path [:y :z], :value "abc"}]</code></pre></div><div class="side-by-side"><div class="vspace"></div><div class="vspace"></div><div class="vspace"></div><pre><code class="form">(all-paths {:y map?})</code><br><code class="eval">;; => [{:path [], :value {:y map?}}
;;     {:path [:y], :value map?}]</code></pre></div></div><div class="note"></div><div class="panel-footer"><span class="panel-number">43/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested map #2: Keep only… (non-ideal specification)</h3><div class="side-by-side-container"><div class="side-by-side"><div>…collections from the data</div><pre><code>[{:path [], :value {:x 42, :y {:z "abc"}}}
 {:path [:y], :value {:z "abc"}}]</code></pre></div><div class="side-by-side"><div class="vspace"></div><div class="vspace"></div><div class="vspace"></div><div>…predicates from the specification</div><pre><code>[{:path [:y], :value map?}]</code></pre></div></div><div class="note"></div><div class="panel-footer"><span class="panel-number">44/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested map #3: Pair collections with predicates (non-ideal specification)</h3><div class="side-by-side-container"><div class="side-by-side"><div>paths of collections in data</div><pre><code>[]</code></pre><pre><code>[:y]</code></pre></div><div class="side-by-side"><div>path of predicate in specification</div><pre><code class="form">(drop-last [:y])</code><br><code class="eval">;; => ()</code></pre><div class="vspace"></div><pre><code class="form">(= [] (drop-last [:y]))</code><br><code class="eval">;; => true</code></pre></div></div><div class="vspace"></div><p>Motto #3: Ignore un-paired collections and un-paired predicates.</p><div class="note"></div><div class="panel-footer"><span class="panel-number">45/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested map #4: Apply predicates (non-ideal specification)</h3><pre><code class="form">(map? {:x 42, :y {:z "abc"}})</code><br><code class="eval">;; => true</code></pre><div class="note"></div><div class="panel-footer"><span class="panel-number">46/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Collection validation: nested map (non-ideal specification)</h3><pre><code class="form">(validate-collections {:x 42, :y {:z "abc"}}
                      {:y map?})</code><br><code class="eval">;; => ({:datum {:x 42, :y {:z "abc"}},
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [:y],
;;      :predicate map?,
;;      :valid? true})</code></pre><div class="vspace"></div><p>What if we'd wanted to validate <code>{:z "abc"}</code>?</p><div class="note"></div><div class="panel-footer"><span class="panel-number">47/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested map, better specification</h3><table><tr><td>data</td><td><pre><code>{:x 42 :y {:z "abc"}}</code></pre></td></tr><tr><td>predicate</td><td><pred><code>map?</code></pred></td></tr><tr><td><div class="vspace"></div></td></tr><tr><td>specification</td><td><pre><code>{:x 42 :y     {:z "abc" }} ;; copy-paste data</code></pre><pre><code>{             {         }} ;; remove scalars</code></pre><pre><code>{:foo map? :y {:bar set?}} ;; insert predicate</code></pre></td></tr></table><div class="panel-footer"><span class="panel-number">48/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested map, better specification</h3><div class="side-by-side-container"><div class="side-by-side"><div>Paths of collections</div><pre><code>[]</code><br><code>[:y]</code></pre></div><div class="side-by-side"><div>Paths of predicates</div><pre><code>[:foo]</code></pre><pre><code class="form">(drop-last [:foo])</code><br><code class="eval">;; => ()</code></pre><div class="vspace"></div><pre><code>[:y :bar]</code></pre><pre><code class="form">(drop-last [:y :bar])</code><br><code class="eval">;; => (:y)</code></pre></div></div><pre><pre><code class="form">(map? {:x 42, :y {:z "abc"}})</code><br><code class="eval">;; => true</code></pre><br><pre><code class="form">(set? {:z "abc"})</code><br><code class="eval">;; => false</code></pre></pre><div class="note"></div><div class="panel-footer"><span class="panel-number">49/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating nested map, better specification</h3><pre><code class="form">(validate-collections {:x 42, :y {:z "abc"}}
                      {:foo map?, :y {:bar set?}})</code><br><code class="eval">;; => ({:datum {:x 42, :y {:z "abc"}},
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [:foo],
;;      :predicate map?,
;;      :valid? true}
;;     {:datum {:z "abc"},
;;      :ordinal-path-datum [:y],
;;      :path-datum [:y],
;;      :path-predicate [:y :bar],
;;      :predicate set?,
;;      :valid? false})</code></pre><div class="note"></div><div class="panel-footer"><span class="panel-number">50/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Using informative keywords in specifications</h3><pre><code>{:foo       map? :y {:bar       set?}}</code><br><code>{:is-a-map? map? :y {:is-a-set? set?}}</code></pre><div class="vspace"></div><pre><code class="form">(validate-collections {:x 42, :y {:z "abc"}}
                      {:is-a-map? map?, :y {:is-a-set? set?}})</code><br><code class="eval">;; => ({:datum {:x 42, :y {:z "abc"}},
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [:is-a-map?],
;;      :predicate map?,
;;      :valid? true}
;;     {:datum {:z "abc"},
;;      :ordinal-path-datum [:y],
;;      :path-datum [:y],
;;      :path-predicate [:y :is-a-set?],
;;      :predicate set?,
;;      :valid? false})</code></pre><div class="panel-footer"><span class="panel-number">51/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Using mis-leading keywords in specifications</h3><pre><code>{:is-a-map? map?   }</code><br><code>{:is-a-map? <strong>vector?</strong>}</code></pre><div class="vspace"></div><pre><code class="form">(validate-collections {:x 42}
                      {:is-a-map? vector?})</code><br><code class="eval">;; => ({:datum {:x 42},
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [:is-a-map?],
;;      :predicate vector?,
;;      :valid? false})</code></pre><div class="note"></div><div class="panel-footer"><span class="panel-number">52/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><hr><hr><hr><div class="panel-footer"><span class="panel-number">53/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Collection validation, first attempt.</h3><pre><code>(def len-3? #(= 3 (count %)))</code></pre><div class="vspace"></div><pre><code class="form">(len-3? [42 "abc" 22/7])</code><br><code class="eval">;; => true</code></pre><div class="note"><p>We could try to write a specification like this: our `len-3?` predicate returns `true` if the collection has exactly three elements. Validation merely applies the predicate to the whole collection.</p><p>Okay, that scenario maybe kinda could work. But what about this scenario?</p></div><div class="panel-footer"><span class="panel-number">54/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Collection Validation, first attempt.</h3><p><em>This fn doesn't actually exist</em></p><pre><code>(imaginary-validate-collection [42 'foo \z]
                               len-3?)
;; => okay</code></pre><div class="note"><p>Then we could imagine some function might do this.</p></div><div class="panel-footer"><span class="panel-number">55/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Collection validation, first attempt problem.</h3><pre><code class="form">(all-paths [11 [22 33 44]])</code><br><code class="eval">;; => [{:path [], :value [11 [22 33 44]]}
;;     {:path [0], :value 11}
;;     {:path [1], :value [22 33 44]}
;;     {:path [1 0], :value 22}
;;     {:path [1 1], :value 33}
;;     {:path [1 2], :value 44}]</code></pre><div class="vspace"></div><pre><code>(imaginary-validate-collection [42 'foo \z]
                               ???)</code></pre><div class="note"><p><em>A three-element vector nested within a two-element vector</em>. The paths would look like this.</p><p>Oh. Still ignoring the scalars, there are now two vectors which would be targets for our predicate, one at the root, and one at path <code>[1]</code>. We can't merely supply a pair of bare predicates to our <code>imaginary-validate-collection</code> function and have it magically know how to apply the predicates to the correct vector.</p></div><div class="panel-footer"><span class="panel-number">56/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Collection Validation, solving the problem with the Mottos.</h3><table><tr><td>data</td><td><pre><code>[11 [22 33 44]]</code></pre></td></tr><tr><td>template</td><td><pre><code>[   [        ]]</code></pre></td></tr><tr><td>specification</td><td><pre><code>[len-3? [len-3?]]</code></pre></td></tr></table><div class="note"><p>It quickly becomes apparent that we need to somehow arrange our collection predicates inside some kind of structure that will instruct the validation function where to apply the predicates. One of Speculoos' principles is <em>Make the specification shaped like the data</em>. Let me propose this structure.</p></div><div class="panel-footer"><span class="panel-number">57/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>All-paths of the collection specification.</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code class="form">(all-paths [11 [22 33 44]])</code><br><code class="eval">;; => [{:path [], :value [11 [22 33 44]]}
;;     {:path [0], :value 11}
;;     {:path [1], :value [22 33 44]}
;;     {:path [1 0], :value 22}
;;     {:path [1 1], :value 33}
;;     {:path [1 2], :value 44}]</code></pre><div class="vspace"></div><pre><code class="form">(all-paths [len-3? [len-3?]])</code><br><code class="eval">;; => [{:path [], :value [len-3? [len-3?]]}
;;     {:path [0], :value len-3?}
;;     {:path [1], :value [len-3?]}
;;     {:path [1 0], :value len-3?}]</code></pre></div><div class="side-by-side"><pre><code class="form">(drop-last [1 0])</code><br><code class="eval">;; => (1)</code></pre><div class="vspace"></div><pre><code class="form">(drop-last [0])</code><br><code class="eval">;; => ()</code></pre></div></div><div class="note"><p>What do the paths of that thing look like?Hmm. In the previous scalar-validation screencast, when we were validating scalars, we followed the principle that validation only proceeds when a predicate in the specification shares the exact path as the scalar in the data. However, we can now see an issue if we try to apply that principle here. The nested vector of the data is located at path <code>[1]</code>. The nested predicate in the specification is located at path <code>[1 0]</code>, nearly same except for the trailing <code>0</code>. The root vector of the data is located at path <code>[]</code> while the predicate is located at path <code>[0]</code> of the specification, again, nearly the same except for the trailing zero. Clojure has a nice core function, `drop-last`, that performs that transformation.</p></div><div class="panel-footer"><span class="panel-number">58/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Algorithm for validating collections.</h3><ol><li>Run <code>all-paths</code> on the data, then the specification.</li><li>Remove <em>scalar</em> elements from the data, keeping only the collection elements.</li><li>Remove <em>non-predicate</em> elements from the collection specification.</li><li>Pair predicates at path <code>pth</code> in the specification with collections at path <code>(drop-last pth)</code> in the data. Discard all other un-paired collections and un-paired predicates.</li><li>For each remaining collection+predicate pair, apply the predicate to the collection.</li></ol><div class="note"><p>The slightly modified rule for validating collections is <em>Collection predicates in the specification are applied to the collection in the data that correspond to their parent.</em> In other words, the predicate at path <code>pth</code> in the collection specification is applied to the collection at path <code>(drop-last pth)</code> in the data.</p></div><div class="panel-footer"><span class="panel-number">59/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Manually validating nested collections.</h3><div class="side-by-side-container"><div class="side-by-side">from data: only collections<pre><code>[{:path [], :value [11 [22 33 44]]}
 {:path [1], :value [22 33 44]}]</code></pre></div><div class="side-by-side">from specification: only predicates<pre><code>[{:path [0], :value len-3?}
 {:path [1 0], :value len-3?}]</code></pre><div class="vspace"></div><pre><code class="form">(drop-last [0])</code><br><code class="eval">;; => ()</code></pre><pre><code class="form">(drop-last [1 0])</code><br><code class="eval">;; => (1)</code></pre></div></div><div class="vspace"></div><pre><code class="form">(len-3? [11 [22 33 44]])</code><br><code class="eval">;; => false</code></pre><div class="vspace"></div><pre><code class="form">(len-3? [22 33 44])</code><br><code class="eval">;; => true</code></pre><div class="note"><p>We've already run `all-paths` on the data (left) and the collection specification (right), now we filter each to keep only the collections and predicats, respectively. We form pairs by doing a `drop-last` on each of the predicates' paths.</p><p>The root vector `[11 [22 33 44]]` does not satisfy `len-3?`, but the nested vector `[22 33 44]` does.</p></div><div class="panel-footer"><span class="panel-number">60/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validate collections: simple vector</h3><pre><code>(require '[speculoos.core :refer [validate-collections]])</code></pre><div class="vspace"></div><pre><code class="form">(validate-collections [11 22 33] [len-3?])</code><br><code class="eval">;; => ({:datum [11 22 33],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate len-3?,
;;      :valid? true})</code></pre><div class="note"><p>Speculoos provides a function, <code>validate-collections</code>, that does that for us. Let's see.Much of that looks familiar. <code>validate-collections</code> returns a validation entry for each to the two collections+predicate pairs. The <code>:datum</code> stuff represent the things being tested and the <code>:predicate</code>s report the predicate functions, and similarly, <code>valid?</code> reports whether that predicate was satisfied.</p><p>There are now three things that involve the concept of a path: the `len-3?` collection predicate was found at <code>:path-predicate</code> in the specification and the datum was found at <code>:path-datum</code> in the data. Notice that the value associated to :path-datum is the same as the `drop-last` of :path-predicate. That means that `validate-collections` paired the root collection to the `len-3?` predicate. (We'll explain the term :ordinal-path-datum keyword as the discussion progresses.) In this example, the the root vector contains only three elements, and thus satisfies its collection predicate `len-3?`.</p><p></p></div><div class="panel-footer"><span class="panel-number">61/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validate collections: nested vector</h3><pre><code class="form">(validate-collections [11 [22 33 44]]
                      [len-3? [len-3?]])</code><br><code class="eval">;; => ({:datum [11 [22 33 44]],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate len-3?,
;;      :valid? false}
;;     {:datum [22 33 44],
;;      :ordinal-path-datum [0],
;;      :path-datum [1],
;;      :path-predicate [1 0],
;;      :predicate len-3?,
;;      :valid? true})</code></pre><div class="note"><p>In this example we've nested a vector within the outer root vector. Two collections, two predicates. The nested vector [22 33] contains three elements, so its predicate was satisfied, while the root vector contains only two elements, and thus failed to satisfy its predicate.</p></div><div class="panel-footer"><span class="panel-number">62/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating collections: maps.</h3><pre><code class="form">(all-paths {:x 11, :y {:z 22}})</code><br><code class="eval">;; => [{:path [], :value {:x 11, :y {:z 22}}}
;;     {:path [:x], :value 11}
;;     {:path [:y], :value {:z 22}}
;;     {:path [:y :z], :value 22}]</code></pre><div class="note"><p>Let's take a look at validating nested maps. Here are the paths of some example data, a map nested in another map, along with a couple of scalars.</p><p>Two scalars, which <code>validate-collections</code> ignores, and two collections. Let's apply our rule: the predicate in the specification applies to the collection in the data whose path is one element shorter. The two collections are located at paths <code>[]</code> and <code>[:y]</code>.</p></div><div class="panel-footer"><span class="panel-number">63/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating maps: naive collection specification.</h3><code>{map? {map?}}</code><div class="note"><p>To write a collection specification, we'd mimic the shape of the data, inserting predicates that apply to the parent. We can't simply write {map?} because maps must contain an even number of forms. So we're going to need to add some keys in there. Technically, you could key your collection predicates however you want, but I strongly recommend choosing a key that doesn't appear in the data. This example shows why. We could put a predicate at key <code>:y</code> of the specification, and <code>validate-collections</code> will merrily chug along.</p></div><div class="panel-footer"><span class="panel-number">64/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating maps: somewhat better collection specification.</h3><code>{:y map?}</code><div class="vspace"></div><pre><code class="form">(validate-collections {:x 11, :y {:z 22}}
                      {:y map?})</code><br><code class="eval">;; => ({:datum {:x 11, :y {:z 22}},
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [:y],
;;      :predicate map?,
;;      :valid? true})</code></pre><div class="note"><p>We can see that the singular <code>map?</code> predicate located at specification path <code>[:y]</code> was indeed applied to the root container at data path <code>(drop-last [:y])</code> which evaluates to path <code>[]</code>. But now we've consumed that key, and it cannot be used to target the nested map <code>{:z 22}</code> at <code>[:y]</code> in the data.</p></div><div class="panel-footer"><span class="panel-number">65/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating maps: even better collection specification with a sham key.</h3><pre><code class="form">(validate-collections {:x 11, :y {:z 22}}
                      {:is-a-map? map?, :y {:is-a-set? set?}})</code><br><code class="eval">;; => ({:datum {:x 11, :y {:z 22}},
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [:is-a-map?],
;;      :predicate map?,
;;      :valid? true}
;;     {:datum {:z 22},
;;      :ordinal-path-datum [:y],
;;      :path-datum [:y],
;;      :path-predicate [:y :is-a-set?],
;;      :predicate set?,
;;      :valid? false})</code></pre><div class="note"><p>If we had instead invented a synthetic key, <code>drop-last</code> would trim it off the right end and the predicate would still be applied to the root container, while key <code>:y</code> remains available to target the nested map. In practice, I like to invent keys that are descriptive of the predicate so the validation results are easier to scan by eye.</p><p>Notice that <code>validate-collections</code> completely ignored the scalars <code>11</code> and <code>22</code> at data keys <code>:x</code> and <code>:z</code>. It only applied predicate <code>map?</code> to the root of data and predicate <code>set?</code> to the nested map at key <code>:y</code>, which failed to satisfy.</p></div><div class="panel-footer"><span class="panel-number">66/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating maps: irrelevance of <strong>collection predicate's</strong> sham key.</h3><p><code>:is-a-map?</code> keyword gives the wrong impression</p><pre><code class="form">(validate-collections {:x 11}
                      {:is-a-map? vector?})</code><br><code class="eval">;; => ({:datum {:x 11},
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [:is-a-map?],
;;      :predicate vector?,
;;      :valid? false})</code></pre><div class="note"><p>Let me emphasize: within a collection specification, the name of the predicate keys targeting a nested map have <em>absolutely no bearing on the operation of the validation</em>. They get truncated by the <code>drop-last</code> operation. We could have used something misleading like this. Despite the key suggesting that we're testing for a map, the actual predicate tests for a vector, and returns <code>false</code>.</p></div><div class="panel-footer"><span class="panel-number">67/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Multiple collection predicates for a sequential.</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code class="form">(validate-collections [42]
                      [vector? map?])</code><br><code class="eval">;; => ({:datum [42],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate vector?,
;;      :valid? true}
;;     {:datum [42],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [1],
;;      :predicate map?,
;;      :valid? false})</code></pre></div><div class="side-by-side"><pre><code class="form">(drop-last [0])</code><br><code class="eval">;; => ()</code></pre><div class="vspace"></div><pre><code class="form">(drop-last [1])</code><br><code class="eval">;; => ()</code></pre></div></div><div class="note"><p>Here's something curious. If we focus on the paths of the two predicates in the specification, we see that both <code>vector?</code> and <code>map?</code> target the root container because <code>(drop-last [0])</code> and <code>(drop-last [1])</code> both evaluate to the same path in the data. So we have another consideration: <em>Every</em> predicate in a specification's collection applies to the parent collection in the data. This means that we can apply an unlimited number of predicates to each collection.</p></div><div class="panel-footer"><span class="panel-number">68/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Many collection predicates for a sequential.</h3><div class="note"><p>Any number of collection predicates may apply to the parent collection, because their paths all `drop-last` evaluate to the parent's path. Here, we see all five collection predicates apply to the parent vector.</p><p>If <strong>any</strong> number of predicates apply to the parent collection, there might be zero to infinity predicates before we encounter a nested collection in that sequence. How, then, does <code>validate-collections</code> determine where to apply the predicate inside a nested collection?</p></div><pre><code class="form">(validate-collections [42]
                      [vector? map? list? set? coll?])</code><br><code class="eval">;; => ({:datum [42],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate vector?,
;;      :valid? true}
;;     {:datum [42],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [1],
;;      :predicate map?,
;;      :valid? false}
;;     {:datum [42],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [2],
;;      :predicate list?,
;;      :valid? false}
;;     {:datum [42],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [3],
;;      :predicate set?,
;;      :valid? false}
;;     {:datum [42],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [4],
;;      :predicate coll?,
;;      :valid? true})</code></pre><div class="panel-footer"><span class="panel-number">69/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Collection predicates to nested collections.</h3><pre><code>[{:a 11} 22 (list 33) 44 #{55}]</code></pre><pre><code>[{     }    (       )    #{  }]</code></pre><div class="note"><p>The rule <code>validate-collections</code> follows is <em>Apply nested collection predicates in the order which they appear, ignoring scalars.</em> Let's see that in action. First, we'll make some example data composed of a parent vector, containing a nested map, list, and set, with a couple of interleaved integers.</p><p>Now we need to compose a collection specification. Motto #2 reminds us to make the specification mimic the shape of the data. I'm going to copy-paste the data and mash the delete key to remove the scalar datums. Just to emphasize how they align, here are the data (top) and the collection specification (bottom) with some spaced formatting.</p></div><div class="panel-footer"><span class="panel-number">70/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>A minimally-competent collection specification.</h3><pre><code class="form">(validate-collections [{:a 11} 22 (list 33) 44 #{55}]
                      [{} () #{}])</code><br><code class="eval">;; => ()</code></pre><div class="note"><p>The first thing to note is that our collection specification looks a lot like our data with all the scalars removed. The second thing to notice is that even though it contains zero predicates, that's a legitimate collection specification which <code>validate-collections</code> can consume. Check this out. Validation ignores collections in the data that are not paired with a predicate in the specification.</p><p>Remember: A specification says 'Thing may, or may not exist, but if it does, it must satisfy this predicate.' `valid` means 'zero un-satisfied predicates'. This validation recognizes zero collection+predicate pairs, so there aren't any un-satisfied predicates.</p></div><div class="panel-footer"><span class="panel-number">71/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating nested collections #1</h3><pre><code class="form">(validate-collections [{:a 11} 22 (list 33) 44 #{55}]
                      [{} (list list?) #{}])</code><br><code class="eval">;; => ({:datum (33),
;;      :ordinal-path-datum [1],
;;      :path-datum [2],
;;      :path-predicate [1 0],
;;      :predicate list?,
;;      :valid? true})</code></pre><div class="note"><p>Okay, let's add a predicate. Let's specify that the second nested collection is a list. Predicates apply to their container, so we'll insert <code>list?</code> into the corresponding collection.</p><p>One predicate in the specification pairs with one collection in the data, so we receive one validation result. The <code>list?</code> predicate at path <code>[1 0]</code> in the specification was applied to the collection located at path <code>[2]</code> in the data. That nested collection is indeed a list, so <code>:valid?</code> is <code>true</code>.</p><p>Notice how <code>validate-collections</code> did some tedious and boring calculations to achieve the general effect of <em>The predicate in the second nested collection of the specification applies to the second nested collection of the data.</em> It kinda skipped over that <code>22</code> because it ignores scalars, and we're validating collections.</p></div><div class="panel-footer"><span class="panel-number">72/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating nested collections #2</h3><pre><code class="form">(validate-collections [{:a 11} 22 (list 33) 44 #{55}]
                      [{} () #{set?}])</code><br><code class="eval">;; => ({:datum #{55},
;;      :ordinal-path-datum [2],
;;      :path-datum [4],
;;      :path-predicate [2 set?],
;;      :predicate set?,
;;      :valid? true})</code></pre><div class="note"><p>Let's clear the slate and specify that nested set at the third position. One predicate applied to one collection, one validation result. And again, collection validation skipped right over the intervening scalars <code>22</code> and <code>44</code> in the data. <code>validate-collections</code> applied the predicate in the specification's third nested collection to the data's third nested collection.</p></div><div class="panel-footer"><span class="panel-number">73/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating nested collections #3</h3><pre><code class="form">(validate-collections [{:a 11} 22 (list 33) 44 #{55}]
                      [{:is-map? map?} () #{}])</code><br><code class="eval">;; => ({:datum {:a 11},
;;      :ordinal-path-datum [0],
;;      :path-datum [0],
;;      :path-predicate [0 :is-map?],
;;      :predicate map?,
;;      :valid? true})</code></pre><div class="note"><p>We might as well specify that nested map in the first position. Recall that collection predicates targeting a map require a sham key. Removing the <code>set?</code> predicate from the previous example, we'll insert a <code>map?</code> predicate at a key in the specification that doesn't appear in the data's nested map. Unlike the previous two validations, <code>validate-collections</code> didn't have to skip over any scalars. It merely applied the predicate in the specification's first nested collection to the data's first nested collection, which is indeed a map.</p></div><div class="panel-footer"><span class="panel-number">74/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating nested collections #4</h3><pre><code class="form">(validate-collections [{:a 11} 22 (list 33) 44 #{55}]
                      [vector? {} () #{}])</code><br><code class="eval">;; => ({:datum [{:a 11} 22 (33) 44 #{55}],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate vector?,
;;      :valid? true})</code></pre><div class="note"><p>We've now seen how to specify and validate each of those three nested collections, so for completeness' sake, let's specify the root. Predicates apply to their container, so for clarity, we'll insert it at the beginning, but we could interleave it anywhere at the first level of depth in the specification.</p></div><div class="panel-footer"><span class="panel-number">75/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Arranging collection predicates in a sequential specification.</h3><pre><code>(validate-collections [{:a 11} 22 (list 33) 44 #{55}] [vector? {} () #{}])</code><br><code>(validate-collections [{:a 11} 22 (list 33) 44 #{55}] [{} vector? () #{}])</code><br><code>(validate-collections [{:a 11} 22 (list 33) 44 #{55}] [{} () vector? #{}])</code><br><code>(validate-collections [{:a 11} 22 (list 33) 44 #{55}] [{} () #{} vector?])</code></pre><div class="note"><p>Technically, we could put that particular predicate anywhere in the top-level vector as long <code>(drop-last path)</code> evaluates to <code>[]</code>. All the following yield substantially the same results. In practice, I find it visually clearer to insert the predicates at the front.</p></div><div class="panel-footer"><span class="panel-number">76/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>All-up nested collection validation</h3><div class="note"><p><code>validate-collections</code> applied to the data's root four predicates — <code>vector?</code>, <code>sequential?</code>, <code>coll?</code>, and <code>any?</code> — which we interleaved among the nested collections. In addition, it validated each of the three nested collections, skipping over the intervening scalars.</p></div><pre><code class="form">(validate-collections [{:a 11} 22 (list 33) 44 #{55}]
                      [vector? {:is-map? map?} sequential? (list list?) coll? #{set?} any?])</code><br><code class="eval">;; => ({:datum [{:a 11} 22 (33) 44 #{55}],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate vector?,
;;      :valid? true}
;;     {:datum {:a 11},
;;      :ordinal-path-datum [0],
;;      :path-datum [0],
;;      :path-predicate [1 :is-map?],
;;      :predicate map?,
;;      :valid? true}
;;     {:datum [{:a 11} 22 (33) 44 #{55}],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [2],
;;      :predicate sequential?,
;;      :valid? true}
;;     {:datum (33),
;;      :ordinal-path-datum [1],
;;      :path-datum [2],
;;      :path-predicate [3 0],
;;      :predicate list?,
;;      :valid? true}
;;     {:datum [{:a 11} 22 (33) 44 #{55}],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [4],
;;      :predicate coll?,
;;      :valid? true}
;;     {:datum #{55},
;;      :ordinal-path-datum [2],
;;      :path-datum [4],
;;      :path-predicate [5 set?],
;;      :predicate set?,
;;      :valid? true}
;;     {:datum [{:a 11} 22 (33) 44 #{55}],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [6],
;;      :predicate any?,
;;      :valid? true})</code></pre><div class="panel-footer"><span class="panel-number">77/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Specifying collections nested in a parent map</h3><table><tr><td>data</td><td><pre><code>{:a [99] :b (list 77)}</code></pre></td></tr><tr><td>template</td><td><pre><code>{:a [  ] :b (list   )}</code></pre></td></tr><tr><td>specification</td><td><pre><code>{:a [vector?] :b (list list?)}</code></pre></td></tr></table><div class="note"><p>Collections nested within a map do not involve that kind of skipping because they're not sequential. Let's make this top row our example data.</p><p>Now, we copy-paste the data into the middle row, then delete the scalars. That becomes the template for our collection specification.</p><p>Let's pretend we want to specify something about those two nested collections at keys <code>:a</code> and <code>:b</code>. We stuff the predicates <em>directly inside those collections</em>. This becomes our collection specification. Let's see what happens.</p></div><div class="panel-footer"><span class="panel-number">78/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating collections nested in a parent map</h3><pre><code class="form">(validate-collections {:a [99], :b (list 77)}
                      {:a [vector?], :b (list list?)})</code><br><code class="eval">;; => ({:datum [99],
;;      :ordinal-path-datum [:a],
;;      :path-datum [:a],
;;      :path-predicate [:a 0],
;;      :predicate vector?,
;;      :valid? true}
;;     {:datum (77),
;;      :ordinal-path-datum [:b],
;;      :path-datum [:b],
;;      :path-predicate [:b 0],
;;      :predicate list?,
;;      :valid? true})</code></pre><div class="note"><p>Checklist time.</p><ul><li>Specification shape mimics data? <em>Check.</em></li><li>Validating collections, ignoring scalars? <em>Check.</em></li><li>Two paired predicates, two validations? <em>Check.</em></li></ul><p>There's a subtlety to pay attention to: the <code>vector?</code> and <code>list?</code> predicates are contained within a vector and list, respectively. Those two predicates apply to their <em>immediate</em> parent container. <code>validate-collections</code> needs those <code>:a</code> and <code>:b</code> keys to find that vector and that list. You only use a sham key when validating the map immediately above your head.</p></div><div class="panel-footer"><span class="panel-number">79/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating nested maps: When to use a sham key #1</h3><pre><code class="form">(validate-collections {:a [99], :b (list 77)}
                      {:a [vector?], :b (list list?), :howdy map?})</code><br><code class="eval">;; => ({:datum [99],
;;      :ordinal-path-datum [:a],
;;      :path-datum [:a],
;;      :path-predicate [:a 0],
;;      :predicate vector?,
;;      :valid? true}
;;     {:datum (77),
;;      :ordinal-path-datum [:b],
;;      :path-datum [:b],
;;      :path-predicate [:b 0],
;;      :predicate list?,
;;      :valid? true}
;;     {:datum {:a [99], :b (77)},
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [:howdy],
;;      :predicate map?,
;;      :valid? true})</code></pre><div class="note"><p>Let's re-use that validation and tack on a sham key with a predicate aimed at the root map. We've got the vector and list validations as before, and then, at the end, we see that <code>map?</code> at the sham <code>:howdy</code> key was applied to the root.</p></div><div class="panel-footer"><span class="panel-number">80/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating nested maps: When to use a sham key #2</h3><table><tr><td>data</td><td><pre><code>{:a [99] :b (list 77)}</code></pre></td></tr><tr><td>template</td><td><pre><code>{:a [  ] :b (list   )}</code></pre></td></tr><tr><td>remove stuff</td><td><pre><code>{:a [  ]             }</code></pre></td></tr><tr><td>add predicate</td><td><pre><code>{:a [vector?]        }</code></pre></td></tr><tr><td>specification</td><td><pre><code>{:a [vector?] :flamingo [coll?]}</code></pre></td></tr></table><div class="note"><p>One more example to illustrate this point. Again, here's our data in the top row. And again, we'll copy-paste the data, then delete the scalars. That'll be our template for our collection specification.</p><p>Now, we'll go even further and delete the <code>:b</code> key and its value, the nested list. Without :b, we won't be able to validate the list.</p><p>Next, we'll insert predicate <code>vector?</code>. That predicate is paired with its immediate parent vector, so we need to keep the <code>:a</code> key.</p><p>Finally, we'll add in a wholly different key, with a <code>coll?</code> predicate nested in a collection at the new key.</p><p>Test yourself: How many validations will occur? Keep in mind, we have two collection predicates.</p></div><div class="panel-footer"><span class="panel-number">81/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating nested maps: When to use a sham key #3</h3><pre><code class="form">(validate-collections {:a [99], :b (list 77)}
                      {:a [vector?], :flamingo [coll?]})</code><br><code class="eval">;; => ({:datum [99],
;;      :ordinal-path-datum [:a],
;;      :path-datum [:a],
;;      :path-predicate [:a 0],
;;      :predicate vector?,
;;      :valid? true})</code></pre><div class="note"><p>I asked a misleading question. In this example, there is only one predicate+collection pair. <code>vector?</code> applies to the vector at <code>:a</code>.</p><p>We might have expected <code>coll?</code> to be applied somewhere because <code>:flamingo</code> doesn't appear in the map, but notice that <code>coll?</code> is <em>contained</em> in a vector. It would only ever apply to the thing that contained it. Since the data's root doesn't contain a collection at that key, the predicate is unpaired, and thus ignored.</p></div><div class="panel-footer"><span class="panel-number">82/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Validating nested maps: When to use a sham key #4</h3><pre><code class="form">(validate-collections {:a [99], :b (list 77)}
                      {:a [vector?], :emu coll?})</code><br><code class="eval">;; => ({:datum [99],
;;      :ordinal-path-datum [:a],
;;      :path-datum [:a],
;;      :path-predicate [:a 0],
;;      :predicate vector?,
;;      :valid? true}
;;     {:datum {:a [99], :b (77)},
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [:emu],
;;      :predicate coll?,
;;      :valid? true})</code></pre><div class="note"><p>If we wanted to apply <code>coll?</code> to the root, we peel off its immediate container. <em>Now, </em><code>coll?</code>'s immediate container is the root. Since it is now properly paired with a collection, it participates in validation.</p></div><div class="panel-footer"><span class="panel-number">83/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>What's next.</h3><ol class="de-highlight whats-next"><li>Introduction</li><li>Mechanics</li><li>Validating Scalars</li><li>Validating Collections</li><li class="highlight">Validation Summaries & Thoroughness</li><li>Function Validation</li><li>Generating Random Samples & Exercising</li><li>Utilities</li><li>Predicates</li><li>Non-Terminating Sequences</li><li>Sets</li><li>Troubleshooting</li><li>Comparing spec.alpha to Speculoos</li><li>Perhaps So</li></ol><div class="note">There will be more utilities for validating collections in upcoming screencasts...</div><div class="panel-footer"><span class="panel-number">84/84</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><p id="page-footer">Copyright © 2024 Brad Losavio.<br>Compiled 2024 October 25.<span id="uuid"><br>f7ab1ff8-766b-4e56-b47a-3aa10010a29a</span></p></body></head></html>