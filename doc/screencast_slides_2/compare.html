<!DOCTYPE html>
<html lang="en"><head><link href="screedcast.css" rel="stylesheet" type="text/css"><script src="jquery-3.7.1.min.js" type="text/javascript"></script><script src="screedcast.js" type="text/javascript"></script><title>Speculoos — An experimental Clojure data validation library</title><meta charset="utf-8" compile-date="2024-12-02 14:16:29" content="width=device-width, initial-scale=1" name="viewport"><body class="smaller"><div class="panel"><div class="panel-header"></div><h1>Speculoos Screencast 15 — <code>(diff spec.alpha speculoos)</code></h1><div class="note smaller"><p>The <a href="https://github.com/blosavio/speculoos">Speculoos library</a> is an experiment to see if it is possible to perform the same tasks as <code>clojure.spec.alpha</code> using literal specifications. As a rough measure, I tried to replicate the features outlined in the <a href="https://clojure.org/guides/spec"><em> spec Guide</em></a>. I think Speculoos manages to check off most every feature to some degree, so I feel the project's ideas have merit.</p><p>If you're familiar with <code>clojure.spec.alpha</code> and are curious about how Speculoos compares, here's a side-by-side demonstration. Find the full documentation <a href="https://github.com/blosavio/speculoos">here</a>.</p><p>A warning/apology: For the other Speculoos screencasts, I tried to make the examples small and/or short. The original 'diff' webpage's goal was to show side-by-side how Speculoos compares to spec.alpha. It does that by replicating The Spec Guide, which wasn't originally written for showing a screencast. Instead of altering the examples, I merely include them here as is. The examples are therefore dense and lengthy. The original webpage is the definitive version, but if you prefer to watch and listen, I hope you find this screencast useful.</p></div><div class="panel-footer"><span class="panel-number">1/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Predicates</h3><div class="side-by-side-container"><div class="side-by-side"><p><code>spec.alpha</code></p><pre><code>(require '[clojure.spec.alpha :as s])</code></pre><div class="vspace"></div><pre><code class="form">(s/conform even? 1000)</code><br><code class="eval">;; => 1000</code></pre></div><div class="side-by-side"><p>Speculoos</p><pre><code class="form">(even? 1000)</code><br><code class="eval">;; => true</code></pre><div class="vspace"></div><pre><code class="form">(nil? nil)</code><br><code class="eval">;; => true</code></pre><div class="vspace"></div><pre><code class="form">(#(< % 5) 4)</code><br><code class="eval">;; => true</code></pre></div></div><div class="note smaller"><p>Throughout this comparison screencast, spec.alpha will appear on the left, Speculoos on the right.</p><p><code>spec.alpha</code> predicates are tested with <code>(s/conform)</code> or <code>(s/valid?)</code></p><p>Speculoos specifications are bare, unadorned Clojure predicates.</p></div><div class="panel-footer"><span class="panel-number">2/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Defining and storing specifications and predicates</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code>(s/def :order/date inst?)</code></pre><div class="vspace"></div><pre><code>(s/def :deck/suit #{:club :diamond :heart :spade})</code></pre></div><div class="side-by-side"><pre><code>(def date inst?)</code></pre><pre><code>(def suit #{:club :diamond :heart :spade})</code></pre><pre><code class="form">(import java.util.Date)</code><br><code class="eval">;; => java.util.Date</code></pre><div class="vspace"></div><pre><code class="form">(date (Date.))</code><br><code class="eval">;; => true</code></pre><div class="vspace"></div><pre><code class="form">(suit :club)</code><br><code class="eval">;; => :club</code></pre><div class="vspace"></div><pre><code class="form">(suit :shovel)</code><br><code class="eval">;; => nil</code></pre></div></div><div class="note smaller"><p><code>spec.alpha/def</code> stores the spec in a central registry.</p><p><code>clojure.core/def</code> live in your namespace</p><p><code>spec.alpha</code> provides a special <code>def</code> which stores the spec in a central registry.</p><p>Speculoos specifications are def-ed, and live in, your namespace, and are therefore automatically namespace-qualified.</p><p>If you like the idea of a spec registry, toss 'em into your own hashmap to create an *ad hoc* registry; Speculoos specifications are just predicates and can be used anywhere</p></div><div class="panel-footer"><span class="panel-number">3/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Niceties</h3><div class="side-by-side-container"><div class="side-by-side">Automatically-created spec docstrings</div><div class="side-by-side">(nothing)</div></div><div class="note smaller"><p><code>spec.alpha</code> has some slick facilities for automatically creating spec docstrings.</p><p>Speculoos specifications do not have any special docstring features beyond what you explicitly add to your function <code>def</code>s.</p></div><div class="panel-footer"><span class="panel-number">4/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Composing Predicates</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code>(s/def :num/big-even
  (s/and int?
         even?
         #(> % 1000)))</code></pre><pre><code class="form">(s/valid? :num/big-even :foo)</code><br><code class="eval">;; => false</code></pre><pre><code class="form">(s/valid? :num/big-even 10)</code><br><code class="eval">;; => false</code></pre><pre><code class="form">(s/valid? :num/big-even 100000)</code><br><code class="eval">;; => true</code></pre><pre><code>(s/def :domain/name-or-id
  (s/or :name string?
        :id int?))</code></pre><pre><code class="form">(s/valid? :domain/name-or-id "abc")</code><br><code class="eval">;; => true</code></pre><pre><code class="form">(s/valid? :domain/name-or-id 100)</code><br><code class="eval">;; => true</code></pre><pre><code class="form">(s/valid? :domain/name-or-id :foo)</code><br><code class="eval">;; => false</code></pre></div><div class="side-by-side"><pre><code>(def big-even #(and (int? %) (even? %) (> % 1000)))</code></pre><pre><code class="form">(big-even :foo)</code><br><code class="eval">;; => false</code></pre><pre><code class="form">(big-even 10)</code><br><code class="eval">;; => false</code></pre><pre><code class="form">(big-even 10000)</code><br><code class="eval">;; => true</code></pre><div class="vspace"></div><pre><code>(def name-or-id #(or (string? %) (int? %)))</code></pre><pre><code class="form">(name-or-id "abc")</code><br><code class="eval">;; => true</code></pre><pre><code class="form">(name-or-id 100)</code><br><code class="eval">;; => true</code></pre><pre><code class="form">(name-or-id :foo)</code><br><code class="eval">;; => false</code></pre></div></div><div class="note smaller"><p><code>spec.alpha</code> specs are composed with special functions <code>(s/and)</code> and <code>(s/or)</code>.</p><p>Speculoos specifications are composed with <code>clojure.core/and</code> and <code>clojure.core/or</code>.</p><p>Also note: the two have different ways to refer to datums. <code>spec.alpha</code> annotates branches with keywords (<code>:name</code> and <code>:id</code>), used to return <em>conformed</em> data. Speculoos uses a <a href="https://github.com/blosavio/speculoos?tab=readme-ov-file#mechanics"> different strategy using paths</a> to refer to datums.</p></div><div class="panel-footer"><span class="panel-number">5/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3><code>nil</code>-abling</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code class="form">(s/valid? string? nil)</code><br><code class="eval">;; => false</code></pre><div class="vspace"></div><pre><code class="form">(s/valid? (s/nilable string?) nil)</code><br><code class="eval">;; => true</code></pre></div><div class="side-by-side"><pre><code class="form">(#(or (string? %) (nil? %)) nil)</code><br><code class="eval">;; => true</code></pre></div></div><div class="vspace"></div><p>…but don't. (See <em>Perhaps so</em> webpage or screencast.)</p><div class="note smaller"><p><code>spec.alpha</code> provides a helper to include <code>nil</code> as a valid value</p><p>Simply compose to make a Speculoos predicate nilable.</p><p><code>spec.alpha</code>'s <code>explain</code> provides a nice report for non-conforming simple predicates.</p><p>Speculoos returns only <code>true/false</code> for simple predicates. Later, we'll see how Speculoos <em>does</em> produce a <a href="https://github.com/blosavio/speculoos?tab=readme-ov-file#valid-thorough">detailed report</a> for composite values.</p></div><div class="panel-footer"><span class="panel-number">6/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Entity Maps</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code>(def email-regex #"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,63}$")</code></pre><pre><code>(s/def :acct/email-type (s/and string? #(re-matches email-regex %)))</code></pre><pre><code>(s/def :acct/acctid int?)</code></pre><pre><code>(s/def :acct/first-name string?)</code></pre><pre><code>(s/def :acct/last-name string?)</code></pre><pre><code>(s/def :acct/email :acct/email-type)</code></pre><pre><code>(s/def :acct/person
  (s/keys :req [:acct/first-name :acct/last-name :acct/email]
          :opt [:acct/phone]))</code></pre></div><div class="side-by-side"></div></div><div class="vspace"></div><div class="side-by-side-container"><div class="side-by-side"></div><div class="side-by-side"><pre><code>(def email-spec #(and (string? %) (re-matches email-regex %)))</code></pre><pre><code>(def person-spec
  {:first-name string?, :last-name string?, :email email-spec, :phone any?})</code></pre><pre><code>(require '[speculoos.core :refer
           [valid-scalars? validate-scalars only-invalid]])</code></pre><div class="vspace"></div><pre><code class="form">(valid-scalars? {:first-name "Bugs",
                 :last-name "Bunny",
                 :email "bugs@example.com"}
                person-spec)</code><br><code class="eval">;; => true</code></pre></div></div><div class="note smaller"><p>Here is <code>spec.alpha</code> in action.</p><p>Here is the same process in Speculoos, re-using the regex. (The <em>spec Guide</em> does not appear to use <code>:acct/acctid</code>, so I will skip it.)</p></div><div class="panel-footer"><span class="panel-number">7/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Speculoos: Optionality, flexibility, and permissiveness #1</h3><div class="side-by-side-container"><div class="side-by-side"></div><div class="side-by-side"><pre><code class="form">(valid-scalars? {:first-name "Bugs",
                 :last-name "Bunny",
                 :email "not@even@close@to@a@valid@email"}
                (dissoc person-spec :email))</code><br><code class="eval">;; => true</code></pre><div class="vspace"></div><pre><code class="form">(valid-scalars? {:first-name "Bugs",
                 :last-name "Bunny",
                 :email :not-an-email}
                (assoc person-spec
                  :email #(string? %)))</code><br><code class="eval">;; => false</code></pre><div class="vspace"></div><pre><code class="form">(valid-scalars? {:first-name "Bugs",
                 :last-name "Bunny",
                 :email "n/a"}
                person-spec)</code><br><code class="eval">;; => false</code></pre></div></div><div class="note smaller"><p>Speculoos checks only keys that are in both the data and the specification. If you don't want to validate a particular entry, you can, on-the-fly, dissociate that key-val from the specification.</p><p>If you want to merely relax a specification, simply associate a new, more permissive predicate.</p><p>Note the function name: Speculoos <a href="https://github.com/blosavio/speculoos?tab=readme-ov-file#mottos">distinguishes</a> validating <em>scalars</em> (i.e., numbers, strings, characters, etc.) from <em>collections</em> (vectors, lists, maps, sets). Speculoos provides a corresponding group of functions specifying collection counts, presence of keys, set membership, etc.</p><p>Instead of using <code>valid…?</code> and friends, Speculoos' <code>validate…*</code> family of functions show the details of the validating each datum.</p><p>The validation results can grow unwieldy with large data and specifications, so Speculoos provides some helper functions to quickly focus on points of interest, i.e., non-valid specs.</p></div><div class="panel-footer"><span class="panel-number">8/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Speculoos: Optionality, flexibility, and permissiveness #2</h3><div class="side-by-side-container"><div class="side-by-side"></div><div class="side-by-side"><pre><code class="form">(validate-scalars {:first-name "Bugs",
                   :last-name "Bunny",
                   :email "n/a"}
                  person-spec)</code><br><code class="eval">;; => [{:datum "Bugs",
;;      :path [:first-name],
;;      :predicate string?,
;;      :valid? true}
;;     {:datum "Bunny",
;;      :path [:last-name],
;;      :predicate string?,
;;      :valid? true}
;;     {:datum "n/a",
;;      :path [:email],
;;      :predicate email-spec,
;;      :valid? nil}]</code></pre><div class="vspace"></div><pre><code class="form">(only-invalid (validate-scalars
                {:first-name "Bugs",
                 :last-name "Bunny",
                 :email "n/a"}
                person-spec))</code><br><code class="eval">;; => ({:datum "n/a",
;;      :path [:email],
;;      :predicate email-spec,
;;      :valid? nil})</code></pre></div></div><div class="note smaller"><p>Speculoos checks only keys that are in both the data and the specification. If you don't want to validate a particular entry, you can, on-the-fly, dissociate that key-val from the specification.</p><p>If you want to merely relax a specification, simply associate a new, more permissive predicate.</p><p>Note the function name: Speculoos <a href="https://github.com/blosavio/speculoos?tab=readme-ov-file#mottos">distinguishes</a> validating <em>scalars</em> (i.e., numbers, strings, characters, etc.) from <em>collections</em> (vectors, lists, maps, sets). Speculoos provides a corresponding group of functions specifying collection counts, presence of keys, set membership, etc.</p><p>Instead of using <code>valid…?</code> and friends, Speculoos' <code>validate…*</code> family of functions show the details of the validating each datum.</p><p>The validation results can grow unwieldy with large data and specifications, so Speculoos provides some helper functions to quickly focus on points of interest, i.e., non-valid specs.</p></div><div class="panel-footer"><span class="panel-number">9/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Namespaced keys</h3><div class="side-by-side-container"><div class="side-by-side"><p><code>spec.alpha</code> uses <code>:req</code> & <code>:req-un</code>, <code>:opt</code> and <code>:opt-un</code></p></div><div class="side-by-side"><pre><code class="form">(= :k ::k)</code><br><code class="eval">;; => false</code></pre><div class="vspace"></div><pre><code class="form">(validate-scalars {::a 42, ::b "abc", ::c :foo}
                  {:a int?, :b string?, :c keyword?})</code><br><code class="eval">;; => []</code></pre><div class="vspace"></div><pre><code class="form">(valid-scalars? {::a 42, ::b "abc", ::c :foo}
                {::a int?, ::b string?, ::c keyword?})</code><br><code class="eval">;; => true</code></pre><div class="vspace"></div><pre><code class="form">(valid-scalars? {:a 42, :b "abc", :c :foo}
                {:a int?, :b string?, :c keyword?})</code><br><code class="eval">;; => true</code></pre></div></div><div class="note smaller"><p><code>spec.alpha</code> distinguishes unqualified keys and fully-namespaced keys, and allows you to explicitly declare one or the other.</p><p>Speculoos implicitly distinguishes qualified from unqualified keys because <code>(not= :k ::k).</code></p><p>Observe: Qualified keys in data, unqualified keys in specification, no matches…</p><p>…qualified keys in both data and specification, validation succeeds…</p><p>…unqualified keys in both data and specification, validation succeeds.</p></div><div class="panel-footer"><span class="panel-number">10/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Keyword args</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code>(s/def :my.config/port number?)</code></pre><pre><code>(s/def :my.config/host string?)</code></pre><pre><code>(s/def :my.config/id keyword?)</code></pre><pre><code>(s/def :my.config/server
  (s/keys* :req [:my.config/id :my.config/host] :opt [:my.config/port]))</code></pre><div class="vspace"></div><pre><code class="form">(s/conform :my.config/server
           [:my.config/id :s1 :my.config/host "example.com" :my.config/port
            5555])</code><br><code class="eval">;; => #:my.config{:host "example.com",
;;                :id :s1,
;;                :port 5555}</code></pre></div><div class="side-by-side"></div></div><div class="side-by-side-container"><div class="side-by-side"></div><div class="side-by-side"><pre><code>(def port number?)</code></pre><pre><code>(def host string?)</code></pre><pre><code>(def id keyword?)</code></pre><pre><code>(def server-spec {:my.config/id id, :my.config/host host, :my.config/port port})</code></pre><div class="vspace"></div><pre><code class="form">(valid-scalars? {:my.config/id :s1,
                 :my.config/host
                   "example.com",
                 :my.config/port 5555}
                server-spec)</code><br><code class="eval">;; => true</code></pre></div></div><div class="note smaller"><p><code>spec.alpha</code> handles keyword args like this:</p><p>Speculoos does it this way:</p></div><div class="panel-footer"><span class="panel-number">11/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Does <em>thing</em> exist?</h3><div class="side-by-side-container"><div class="side-by-side"></div><div class="side-by-side"><pre><code>(def server-data-2
  [:my.config/id :s1 :my.config/host "example.com" :my.config/port 5555])</code></pre><pre><code>(def server-spec-2
  [#(= % :my.config/id) id #(= % :my.config/host) host #(= % :my.config/port)
   port])</code></pre><div class="vspace"></div><pre><code class="form">(valid-scalars? server-data-2 server-spec-2)</code><br><code class="eval">;; => true</code></pre></div></div><div class="note smaller"><p>The principle of Speculoos' validation is that if the key exists in both the data and specification, then Speculoos will apply the predicate to the datum. This fulfills the criteria of <em>Thing may or may not exist, but if Thing <strong>does</strong> exist, it must satisfy this predicate.</em></p><p>If we want to similarly validate a sequential data structure, it goes like this:</p></div><div class="panel-footer"><span class="panel-number">12/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Merging</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code>(s/def :animal/kind string?)</code></pre><pre><code>(s/def :animal/says string?)</code></pre><pre><code>(s/def :animal/common (s/keys :req [:animal/kind :animal/says]))</code></pre><pre><code>(s/def :dog/tail? boolean?)</code></pre><pre><code>(s/def :dog/breed string?)</code></pre><pre><code>(s/def :animal/dog
  (s/merge :animal/common (s/keys :req [:dog/tail? :dog/breed])))</code></pre><div class="vspace"></div><pre><code class="form">(s/valid? :animal/dog
          {:animal/kind "dog",
           :animal/says "woof",
           :dog/tail? true,
           :dog/breed "retriever"})</code><br><code class="eval">;; => true</code></pre></div><div class="side-by-side"></div></div><div class="side-by-side-container"><div class="side-by-side"></div><div class="side-by-side"><pre><code>(def animal-kind string?)</code></pre><pre><code>(def animal-says string?)</code></pre><pre><code>(def animal-spec {:kind animal-kind, :says animal-says})</code></pre><pre><code>(def dog-spec (merge animal-spec {:tail boolean?, :breed string?}))</code></pre><pre><code>(def dog-data {:kind "dog", :says "woof", :tail true, :breed "retriever"})</code></pre><div class="vspace"></div><pre><code class="form">(valid-scalars? dog-data dog-spec)</code><br><code class="eval">;; => true</code></pre></div></div><div class="note smaller"><p><code>spec.alpha</code> has a <code>merge</code> function.</p><p>Speculoos simply uses Clojure's powerful data manipulation functions.</p></div><div class="panel-footer"><span class="panel-number">13/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Multi-spec #1</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code>(s/def :event/type keyword?)</code></pre><pre><code>(s/def :event/timestamp int?)</code></pre><pre><code>(s/def :search/url string?)</code></pre><pre><code>(s/def :error/message string?)</code></pre><pre><code>(s/def :error/code int?)</code></pre><pre><code class="form">(defmulti event-type :event/type)</code><br><code class="eval">;; => nil</code></pre><pre><code class="form">(defmethod event-type :event/search
  [_]
  (s/keys :req [:event/type :event/timestamp :search/url]))</code><br><code class="eval">;; => #multifn [event-type 0x2aa7c4b5]</code></pre><pre><code class="form">(defmethod event-type :event/error
  [_]
  (s/keys :req [:event/type :event/timestamp :error/message :error/code]))</code><br><code class="eval">;; => #multifn [event-type 0x2aa7c4b5]</code></pre><pre><code>(s/def :event/event (s/multi-spec event-type :event/type))</code></pre><pre><code class="form">(s/valid? :event/event
          {:event/type :event/search,
           :event/timestamp 1463970123000,
           :search/url "https://clojure.org"})</code><br><code class="eval">;; => true</code></pre><pre><code class="form">(s/valid? :event/event
          {:event/type :event/error,
           :event/timestamp 1463970123000,
           :error/message "Invalid host",
           :error/code 500})</code><br><code class="eval">;; => true</code></pre><pre><code class="form">(s/explain :event/event {:event/type :event/restart})</code><br><code class="eval">;; => nil</code></pre></div><div class="side-by-side"></div></div><div class="note smaller"><p><code>spec.alpha</code> has the capability to dispatch validation paths according to an in-band key. Here's the <em>Guide</em>'s demo.</p><p>Since Speculoos consumes regular old Clojure data structures and functions, they work similarly. Instead of <code>def</code>-ing a series of separate predicates, for brevity, I'll inject them directly into the specification definition, but Speculoos could handle any level of indirection.</p><p>Here we see a significant difference between <code>spec.alpha</code> and Speculoos: the former fails the validation because <code>event-4</code> is missing the <code>:timestamp</code> key. Speculoos considers the presence or absence of a map's key to be a property of the collection. Within that philosophy, such a specification would properly belong in a Speculoos <em>collection specification</em>.</p></div><div class="panel-footer"><span class="panel-number">14/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Multi-spec #2</h3><div class="side-by-side-container"><div class="side-by-side"></div><div class="side-by-side"><pre><code class="form">(defmulti event-type :event/type)</code><br><code class="eval">;; => nil</code></pre><pre><code class="form">(defmethod event-type :event/search
  [_]
  {:event/type keyword?, :event/timestamp int?, :search/url string?})</code><br><code class="eval">;; => #multifn [event-type 0x2aa7c4b5]</code></pre><pre><code class="form">(defmethod event-type :event/error
  [_]
  {:event/type keyword?,
   :event/timestamp int?,
   :error/message string?,
   :error/code int?})</code><br><code class="eval">;; => #multifn [event-type 0x2aa7c4b5]</code></pre><pre><code>(def event-1
  {:event/type :event/search,
   :event/timestamp 1463970123000,
   :event/url "https://clojure.org"})</code></pre><pre><code class="form">(valid-scalars? event-1 (event-type event-1))</code><br><code class="eval">;; => true</code></pre><pre><code>(def event-2
  {:event/type :event/error,
   :event/timestamp 1463970123000,
   :error/message "Invalid host",
   :code 500})</code></pre><pre><code class="form">(valid-scalars? event-2 (event-type event-2))</code><br><code class="eval">;; => true</code></pre><pre><code>(def event-3 {:event/type :restart})</code></pre><pre><code class="form">(try (valid-scalars? event-3 (event-type event-3))
     (catch Exception e (.getMessage e)))</code><br><code class="eval">;; => "No method in multimethod 'event-type' for dispatch value: :restart"</code></pre><pre><code>(def event-4 {:event/type :event/search, :search/url 200})</code></pre><pre><code class="form">(only-invalid (validate-scalars event-4 (event-type event-4)))</code><br><code class="eval">;; => ({:datum 200,
;;      :path [:search/url],
;;      :predicate string?,
;;      :valid? false})</code></pre></div></div><div class="note smaller"><p><code>spec.alpha</code> has the capability to dispatch validation paths according to an in-band key. Here's the <em>Guide</em>'s demo.</p><p>Since Speculoos consumes regular old Clojure data structures and functions, they work similarly. Instead of <code>def</code>-ing a series of separate predicates, for brevity, I'll inject them directly into the specification definition, but Speculoos could handle any level of indirection.</p><p>Here we see a significant difference between <code>spec.alpha</code> and Speculoos: the former fails the validation because <code>event-4</code> is missing the <code>:timestamp</code> key. Speculoos considers the presence or absence of a map's key to be a property of the collection. Within that philosophy, such a specification would properly belong in a Speculoos <em>collection specification</em>.</p></div><div class="panel-footer"><span class="panel-number">15/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Collections #1</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code class="form">(s/conform (s/coll-of keyword?) [:a :b :c])</code><br><code class="eval">;; => [:a :b :c]</code></pre><pre><code class="form">(s/conform (s/coll-of number?) #{5 10 2})</code><br><code class="eval">;; => #{2 5 10}</code></pre><pre><code>(s/def :ex/vnum3
  (s/coll-of number? :kind vector? :count 3 :distinct true :into #{}))</code></pre><div class="vspace"></div><pre><code class="form">(s/conform :ex/vnum3 [1 2 3])</code><br><code class="eval">;; => #{1 2 3}</code></pre></div><div class="side-by-side"></div></div><div class="side-by-side-container"><div class="side-by-side"></div><div class="side-by-side"><pre><code class="form">(valid-scalars? [:a :b :c]
                [keyword? keyword? keyword?])</code><br><code class="eval">;; => true</code></pre><div class="vspace"></div><pre><code>(require '[speculoos.core :refer [valid-collections? validate-collections]])</code></pre><div class="vspace"></div><pre><code class="form">(valid-collections? [:a :b :c]
                    [#(every? keyword? %)])</code><br><code class="eval">;; => true</code></pre><div class="vspace"></div><pre><code class="form">(valid-collections? #{5 10 2}
                    #{#(every? number? %)})</code><br><code class="eval">;; => true</code></pre></div></div><div class="note smaller"><p><code>spec.alpha</code> provides a trio of helper functions for collections. First, <code>coll-of</code>.</p><p>Speculoos was designed from the start to specify collections. Speculoos validates collections in two different ways: it can validate groupings of <em>scalars</em>, atomic, indivisible values (i.e., numbers, booleans, etc.) and it can separately validate the properties of a <em>collection</em> (i.e., vector, map, list, set, etc.) itself, such as its size, the position of particular elements, and the relationships between elements, etc.</p><p>This example could certainly be validated as we've seen before.</p><p>Speculoos can also consider the vector as a whole with its collection validation facility.</p><p>In a collection spec, the predicate applies to the collection that contains that predicate.</p><p>Speculoos collection specs work on just about any type of collection.</p></div><div class="panel-footer"><span class="panel-number">16/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Collections #2</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code>(s/def :geom/point (s/tuple double? double? double?))</code></pre><pre><code class="form">(s/conform :geom/point [1.5 2.5 -0.5])</code><br><code class="eval">;; => [1.5 2.5 -0.5]</code></pre></div><div class="side-by-side"></div></div><div class="side-by-side-container"><div class="side-by-side"></div><div class="side-by-side"><pre><code class="form">(valid-scalars? [1.5 2.5 -0.5]
                [double? double? double?])</code><br><code class="eval">;; => true</code></pre><div class="vspace"></div><pre><code class="form">(valid-collections? [1.5 2.5 -0.5]
                    [#(every? double? %)])</code><br><code class="eval">;; => true</code></pre></div></div><div class="note smaller"><p>Next, <code>spec.alpha</code>'s <code>tuple</code>.</p><p>Tuples are Speculoos' bread and butter.</p></div><div class="panel-footer"><span class="panel-number">17/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Collections #3</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code>(s/def :game/scores (s/map-of string? int?))</code></pre><div class="vspace"></div><pre><code class="form">(s/conform :game/scores {"Sally" 1000, "Joe" 500})</code><br><code class="eval">;; => {"Joe" 500, "Sally" 1000}</code></pre></div><div class="side-by-side"><pre><code class="form">(valid-collections?
  {"Sally" 1000, "Joe" 500}
  {:check-keys #(every? string? (keys %)),
   :check-vals #(every? int? (vals %))})</code><br><code class="eval">;; => true</code></pre></div></div><div class="note smaller"><p>Finally, <code>spec.alpha</code>'s <code>map-of</code>.</p><p>Where Speculoos really takes flight is heterogeneous, arbitrarily-nested collections, but since this document is a comparison to <code>spec.alpha</code>, see the Speculoos <a href="https://github.com/blosavio/speculoos/blob/main/resources/recipes.clj">recipes</a> for examples.</p><p>Speculoos collection validation works on maps, too.</p></div><div class="panel-footer"><span class="panel-number">18/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Sequences</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code>(s/def :cook/ingredient
  (s/cat :quantity number?
         :unit keyword?))</code></pre><div class="vspace"></div><pre><code class="form">(s/valid? :cook/ingredient [2 :teaspoon])</code><br><code class="eval">;; => true</code></pre></div><div class="side-by-side"><pre><code>(def ingredient-spec [number? keyword?])</code></pre><div class="vspace"></div><pre><code class="form">(valid-scalars? [2 :teaspoon] ingredient-spec)</code><br><code class="eval">;; => true</code></pre><div class="vspace"></div><pre><code class="form">(only-invalid (validate-scalars [11 "peaches"] ingredient-spec))</code><br><code class="eval">;; => ({:datum "peaches",
;;      :path [1],
;;      :predicate keyword?,
;;      :valid? false})</code></pre></div></div><div class="note smaller"><p><code>spec.alpha</code> uses regex syntax to describe the structure of sequential data.</p><p>Speculoos uses a literal.</p><p>Invalid datums are reported like this.</p></div><div class="panel-footer"><span class="panel-number">19/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Presence of a datum</h3><div class="side-by-side-container"><div class="side-by-side"></div><div class="side-by-side"><pre><code>(def is-second-kw? #(keyword? (get % 1)))</code></pre><div class="vspace"></div><pre><code class="form">(validate-collections [2] [is-second-kw?])</code><br><code class="eval">;; => ({:datum [2],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate is-second-kw?,
;;      :valid? false})</code></pre><div class="vspace"></div><pre><code class="form">(valid-scalars? [2] ingredient-spec)</code><br><code class="eval">;; => true</code></pre></div></div><div class="note smaller"><p>Note, 'missing' scalars are not validated as they would be with <code>spec.alpha</code>.</p><p>Speculoos <a href="https://github.com/blosavio/speculoos?tab=readme-ov-file#mottos">ignores</a> predicates without a corresponding datum. Presence/absence of a datum is a property of the collection, and is thus handled with a collection specification. Like so…</p></div><div class="panel-footer"><span class="panel-number">20/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>A vector of keywords</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code>(s/def :ex/seq-of-keywords (s/* keyword?))</code></pre><div class="vspace"></div><pre><code class="form">(s/valid? :ex/seq-of-keywords [:a :b :c])</code><br><code class="eval">;; => true</code></pre><div class="vspace"></div><pre><code class="form">(s/explain-str :ex/seq-of-keywords [10 20])</code><br><code class="eval">;; => "10 - failed: keyword? in: [0] spec: :ex/seq-of-keywords\n"</code></pre></div><div class="side-by-side"><pre><code>(def inf-seq-of-keywords-spec (repeat keyword?))</code></pre><div class="vspace"></div><pre><code class="form">(valid-scalars? [:a :b :c]
                inf-seq-of-keywords-spec)</code><br><code class="eval">;; => true</code></pre><div class="vspace"></div><div class="vspace"></div><pre><code class="form">(validate-scalars [10 20]
                  inf-seq-of-keywords-spec)</code><br><code class="eval">;; => [{:datum 10,
;;      :path [0],
;;      :predicate keyword?,
;;      :valid? false}
;;     {:datum 20,
;;      :path [1],
;;      :predicate keyword?,
;;      :valid? false}]</code></pre></div></div><div class="note smaller"><p>Let's look at another <code>spec.alpha</code> example.</p><p>Now, the Speculoos <a href="https://github.com/blosavio/speculoos?tab=readme-ov-file#non-terminating-sequences">way</a>.</p></div><div class="panel-footer"><span class="panel-number">21/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Odds, then maybe even</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code>(s/def :ex/odds-then-maybe-even
  (s/cat :odds (s/+ odd?)
         :even (s/? even?)))</code></pre><div class="vspace"></div><pre><code class="form">(s/valid? :ex/odds-then-maybe-even [1 3 5 100])</code><br><code class="eval">;; => true</code></pre><div class="vspace"></div><pre><code class="form">(s/valid? :ex/odds-then-maybe-even [1])</code><br><code class="eval">;; => true</code></pre><div class="vspace"></div><pre><code class="form">(s/explain-str :ex/odds-then-maybe-even [100])</code><br><code class="eval">;; => "100 - failed: odd? in: [0] at: [:odds] spec: :ex/odds-then-maybe-even\n"</code></pre></div><div class="side-by-side"><pre><code>(def odds-then-maybe-even-spec
  #(and (<= 2 (count (partition-by odd? %)))
        (every? odd? (first (partition-by odd? %)))))</code></pre><pre><code class="form">(valid-collections?
  [1 3 5 100]
  [odds-then-maybe-even-spec])</code><br><code class="eval">;; => true</code></pre><div class="vspace"></div><pre><code class="form">(validate-collections
  [1]
  [odds-then-maybe-even-spec])</code><br><code class="eval">;; => ({:datum [1],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate odds-then-maybe-even-spec,
;;      :valid? false})</code></pre><div class="vspace"></div><pre><code class="form">(validate-collections
  [100]
  [odds-then-maybe-even-spec])</code><br><code class="eval">;; => ({:datum [100],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate odds-then-maybe-even-spec,
;;      :valid? false})</code></pre></div></div><div class="note smaller"><p><code>spec.alpha</code>…</p><p>Speculoos…</p></div><div class="panel-footer"><span class="panel-number">22/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Alternating keywords and booleans</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code>(s/def :ex/opts
  (s/* (s/cat :opt keyword?
              :val boolean?)))</code></pre><div class="vspace"></div><pre><code class="form">(s/valid? :ex/opts [:silent? false :verbose true])</code><br><code class="eval">;; => true</code></pre></div><div class="side-by-side"><pre><code>(def alt-kw-bool-spec (cycle [keyword? boolean?]))</code></pre><div class="vspace"></div><pre><code class="form">(valid-scalars? [:silent? false :verbose true]
                alt-kw-bool-spec)</code><br><code class="eval">;; => true</code></pre></div></div><div class="note smaller"><p>Here's a <code>spec.alpha</code> demonstration of opts that are alternating keywords and booleans.</p><p>Speculoos' way to do the same.</p></div><div class="panel-footer"><span class="panel-number">23/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Specifying alternatives</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code>(s/def :ex/config
  (s/* (s/cat :prop string?
              :val (s/alt :s string?
                          :b boolean?))))</code></pre><div class="vspace"></div><pre><code class="form">(s/valid? :ex/config
          ["-server" "foo"
           "-verbose" true
           "-user" "joe"])</code><br><code class="eval">;; => true</code></pre></div><div class="side-by-side"><pre><code>(def config-spec (cycle [string? #(or (string? %) (boolean? %))]))</code></pre><div class="vspace"></div><pre><code class="form">(valid-scalars? ["-server" "foo"
                 "-verbose" true
                 "-user" "joe"]
                config-spec)</code><br><code class="eval">;; => true</code></pre></div></div><div class="note smaller"><p>Finally, <code>spec.alpha</code> specifies alternatives like this.</p><p>We'd do this in Speculoos.</p><p><code>spec.alpha</code> provides the <code>describe</code> function to retrieve a spec's description. Speculoos trusts your dev environment to find and show you the definitions.</p></div><div class="panel-footer"><span class="panel-number">24/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>&</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code>(s/def :ex/even-strings (s/& (s/* string?) #(even? (count %))))</code></pre><pre><code class="form">(s/valid? :ex/even-strings ["a"])</code><br><code class="eval">;; => false</code></pre><pre><code class="form">(s/valid? :ex/even-strings ["a" "b"])</code><br><code class="eval">;; => true</code></pre><pre><code class="form">(s/valid? :ex/even-strings ["a" "b" "c"])</code><br><code class="eval">;; => false</code></pre><pre><code class="form">(s/valid? :ex/even-strings ["a" "b" "c" "d"])</code><br><code class="eval">;; => true</code></pre></div><div class="side-by-side"></div></div><div class="side-by-side-container"><div class="side-by-side"></div><div class="side-by-side"><pre><code>(def even-string-spec #(and (even? (count %)) (every? string? %)))</code></pre><pre><code class="form">(valid-collections? ["a"] [even-string-spec])</code><br><code class="eval">;; => false</code></pre><pre><code class="form">(valid-collections? ["a" "b"] [even-string-spec])</code><br><code class="eval">;; => true</code></pre><pre><code class="form">(valid-collections? ["a" "b" "c"] [even-string-spec])</code><br><code class="eval">;; => false</code></pre><pre><code class="form">(valid-collections? ["a" "b" "c" "d"] [even-string-spec])</code><br><code class="eval">;; => true</code></pre></div></div><div class="note smaller"><p><code>spec.alpha</code> created a provincial <code>&</code>.</p><p>Speculoos uses <code>clojure.core/and</code>.</p><p>This example reveals a philosophical difference between <code>spec.alpha</code> and Speculoos. Here, <code>spec.alpha</code> has combined specifying the values of a collection and the count of the collection, a property of the container. Speculoos' opinion is that specifying scalars and collections are separate concerns. For the sake of the compare and contrast, I combined the two validation tests into a single collection predicate, <code>even-string-spec</code>, abusing the fact that the container has access to its own contents. But this improperly combines two conceptually distinct operations.</p></div><div class="panel-footer"><span class="panel-number">25/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Distinguishing scalars and collections</h3><div class="side-by-side-container"><div class="side-by-side"></div><div class="side-by-side"><pre><code class="form">(valid-scalars? ["a" "b" "c" "d"]
                (repeat string?))</code><br><code class="eval">;; => true</code></pre><div class="vspace"></div><pre><code class="form">(valid-collections? ["a" "b" "c" "d"]
                    [#(even? (count %))])</code><br><code class="eval">;; => true</code></pre><div class="vspace"></div><pre><code>(require '[speculoos.core :refer [valid?]])</code></pre><div class="vspace"></div><pre><code class="form">(valid? ["a" "b" "c" "d"]
        (repeat string?)
        [#(even? (count %))])</code><br><code class="eval">;; => true</code></pre></div></div><div class="note smaller"><p>If I weren't contrasting with the <code>spec.alpha</code> <em>Guide</em>, I would have written this.</p><p>Because we'll often want to validate both a scalar specification and a collection specification at the same time, Speculoos provides a convenience function that does both.</p><p>As a testament to my belief in the importance of separating scalar and collection specifications, I reserved the shortest and most mnemonic name, <code>valid?</code>, for doing what I contend to be the proper way.</p></div><div class="panel-footer"><span class="panel-number">26/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Nested collections</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code>(s/def :ex/nested
  (s/cat :names-kw #{:names}
         :names (s/spec (s/* string?))
         :nums-kw #{:nums}
         :nums (s/spec (s/* number?))))</code></pre><div class="vspace"></div><pre><code class="form">(s/valid? :ex/nested
          [:names ["a" "b"] :nums [1 2 3]])</code><br><code class="eval">;; => true</code></pre></div><div class="side-by-side"><pre><code>(def scalar-nested-spec [#{:names} (repeat string?) #{:nums} (repeat number?)])</code></pre><div class="vspace"></div><pre><code class="form">(valid-scalars? [:names ["a" "b"] :nums [1 2 3]]
                scalar-nested-spec)</code><br><code class="eval">;; => true</code></pre></div></div><div class="note smaller"><p>Nested collections provide another nice point of comparison. Quoting the <a href="https://clojure.org/guides/spec#_sequences"><em>spec Guide</em></a></p><blockquote>When [spec.alpha] regex ops are combined, they describe a single sequence. If you need to spec a nested sequential collection, you must use an explicit call to spec to start a new nested regex context.</blockquote><p>Speculoos was designed from the outset to straightforwardly handle nested collections. We don't have to do anything special.</p></div><div class="panel-footer"><span class="panel-number">27/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Keeping only valid datums</h3><div class="side-by-side-container"><div class="side-by-side"></div><div class="side-by-side"><pre><code>(if (valid? data spec) data :invalid)</code></pre></div></div><div class="note smaller"><p>Because <code>spec.alpha/conform</code> passes through valid data, you can use its output to filter out data, as seen in the configuration example. In its current implementation, Speculoos' family of <code>valid?</code> functions only return <code>true/false</code>, so to emulate <code>spec.alpha</code>, you'd have to use a pattern such as…</p></div><div class="panel-footer"><span class="panel-number">28/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Spec'ing functions #1: spec.alpha</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code>(defn ranged-rand
  "Returns random int in range start <= rand < end"
  [start end]
  (+ start (long (rand (- end start)))))</code></pre><pre><code class="form">(s/fdef ranged-rand
  :args (s/and (s/cat :start int?
                      :end int?)
               #(< (:start %) (:end %)))
  :ret int?
  :fn (s/and #(>= (:ret %)
                  (-> %
                      :args
                      :start))
             #(< (:ret %)
                 (-> %
                     :args
                     :end))))</code><br><code class="eval">;; => screedcast-generator/ranged-rand</code></pre><pre><code>(require '[clojure.spec.test.alpha :as stest])</code></pre><pre><code class="form">(stest/instrument `ranged-rand)</code><br><code class="eval">;; => [screedcast-generator/ranged-rand]</code></pre><pre><code class="form">(try (ranged-rand 8 5) (catch Exception e (.getMessage e)))</code><br><code class="eval">;; => "Call to screedcast-generator/ranged-rand did not conform to spec."</code></pre><pre><code class="form">(stest/unstrument `ranged-rand)</code><br><code class="eval">;; => [screedcast-generator/ranged-rand]</code></pre></div><div class="side-by-side"></div></div><div class="note smaller"><p><code>spec.alpha</code> can define specifications for a function, like this example, which I've merged with a later section of the <em>spec Guide</em>, titled <em>Instrumentation and Testing</em>.</p><p>Speculoos provides a pair of corresponding utilities for testing functions. First, <code>validate-fn-with</code> wraps a function on-the-fly without mutating the function's <code>var</code>. First, I'll demonstrate a valid invocation.</p></div><div class="panel-footer"><span class="panel-number">29/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Spec'ing functions #2: Speculoos (manual)</h3><div class="side-by-side-container"><div class="side-by-side"></div><div class="side-by-side"><pre><code>(require '[speculoos.function-specs :refer [validate-fn-with]])</code></pre><pre><code>(def second-is-larger-than-first? #(< (get % 0) (get % 1)))</code></pre><div class="vspace"></div><pre><code class="form">(validate-fn-with ranged-rand
                  {:speculoos/arg-scalar-spec [int? int?],
                   :speculoos/arg-collection-spec
                     [second-is-larger-than-first?],
                   :speculoos/ret-scalar-spec int?}
                  2
                  12)</code><br><code class="eval">;; => 9</code></pre><div class="vspace"></div><pre><code class="form">(validate-fn-with ranged-rand
                  {:speculoos/arg-scalar-spec [int? int?],
                   :speculoos/arg-collection-spec
                     [second-is-larger-than-first?],
                   :speculoos/ret-scalar-spec int?}
                  8
                  5)</code><br><code class="eval">;; => ({:datum [8 5],
;;      :fn-spec-type :speculoos/argument,
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate
;;        second-is-larger-than-first?,
;;      :valid? false})</code></pre></div></div><div class="note smaller"><p>Here, we'll intentionally violate the function's argument collection specification by reversing the order of the arguments, and observe the report.</p></div><div class="panel-footer"><span class="panel-number">30/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Spec'ing functions #3: Speculoos (instrumented)</h3><div class="side-by-side-container"><div class="side-by-side"></div><div class="side-by-side"><pre><code>(require '[speculoos.function-specs :refer
           [inject-specs! instrument unstrument]])</code></pre><div class="vspace"></div><pre><code class="form">(inject-specs! ranged-rand
               {:speculoos/arg-scalar-spec [int? int?],
                :speculoos/arg-collection-spec [second-is-larger-than-first?],
                :speculoos/ret-scalar-spec int?})</code><br><code class="eval">;; => nil</code></pre><div class="vspace"></div><pre><code>(instrument ranged-rand)</code></pre><pre><code class="form">(ranged-rand 5 8)</code><br><code class="eval">;; => 6</code></pre><div class="vspace"></div><pre><code class="form">(with-out-str (ranged-rand 8 5))</code><br><code class="eval">;;=> ({:path [0],
       :value second-is-larger-than-first?,
       :datum [8 5],
       :ordinal-parent-path [],
       :valid? false})
</code></pre><pre><code>(unstrument ranged-rand)</code></pre></div></div><div class="note smaller"><p>For testing with a higher degree of integration, Speculoos' second function validation option mimics <code>spec.alpha/instrument</code>. Instrumented function specifications are gathered from the function's metadata. Speculoos provides a convenience function for injecting specs.</p><p>Now, we instrument the function…</p><p>…and then test it. Valid inputs return as normal.</p><p>Invalid arguments return without halting if the function can successfully complete (as in this scenario), but the invalid message is tossed to <code>*out*</code>.</p><p>Later, we can return the function to it's original state.</p><p>(My compliments to whoever invented the <code>unstrument</code> term to compliment <code>instrument</code>.</p></div><div class="panel-footer"><span class="panel-number">31/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Higher order functions</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code>(defn adder [x] #(+ x %))</code></pre><div class="vspace"></div><pre><code class="form">(s/fdef adder
  :args (s/cat :x number?)
  :ret (s/fspec :args (s/cat :y number?)
                :ret number?)
  :fn #(= (-> %
              :args
              :x)
          ((:ret %) 0)))</code><br><code class="eval">;; => screedcast-generator/adder</code></pre></div><div class="side-by-side"><pre><code>(require '[speculoos.function-specs :refer [validate-higher-order-fn]])</code></pre><div class="vspace"></div><pre><code class="form">(inject-specs! adder
               {:speculoos/arg-scalar-spec number?,
                :speculoos/ret-scalar-spec fn?,
                :speculoos/hof-specs {:speculoos/arg-scalar-spec [int?],
                                      :speculoos/ret-scalar-spec number?}})</code><br><code class="eval">;; => nil</code></pre><div class="vspace"></div><pre><code class="form">(validate-higher-order-fn adder [5] [10])</code><br><code class="eval">;; => 15</code></pre><div class="vspace"></div><pre><code class="form">(validate-higher-order-fn adder [5] [22/7])</code><br><code class="eval">;; => ({:datum 22/7,
;;      :fn-tier :speculoos/argument,
;;      :path [1 0],
;;      :predicate int?,
;;      :valid? false})</code></pre></div></div><div class="note smaller"><p><code>spec.alpha</code> supports validating <span class="small-caps">hof</span>s like this.</p><p>Speculoos' version looks like this.</p><p>Speculoos can recursively specify and validate the arguments and returns value of any depth of higher-order functions.</p></div><div class="panel-footer"><span class="panel-number">32/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Macros</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code class="form">(s/fdef clojure.core/declare
  :args (s/cat :names (s/* simple-symbol?))
  :ret any?)</code><br><code class="eval">;; => clojure.core/declare</code></pre><div class="vspace"></div><code class="form">(declare 100)</code><br><code class="eval">;; => Call to clojure.core/declare did not conform to spec...</code></div><div class="side-by-side"><pre><code>(defmacro silly-macro [f & args] `(~f ~@args))</code></pre><div class="vspace"></div><pre><code class="form">(silly-macro + 1 2)</code><br><code class="eval">;; => 3</code></pre><div class="vspace"></div><pre><code>(require '[speculoos.core :refer [valid-macro?]])</code></pre><div class="vspace"></div><pre><code>(def silly-macro-spec (list symbol? number? number?))</code></pre><div class="vspace"></div><pre><code class="form">(valid-macro? `(silly-macro + 1 2) silly-macro-spec)</code><br><code class="eval">;; => true</code></pre></div></div><div class="note smaller"><p><code>spec.alpha</code>'s macro analysis is nicely integrated into Clojure's macroexpander.</p><p>Speculoos is more <em>ad hoc</em>: macro output is tested the same as any other function.</p><p>Speculoos validates macro expansion like this.</p><p>(<code>valid-macro?</code> is a placeholder: I haven't written enough macros to know if it's of any use.</p></div><div class="panel-footer"><span class="panel-number">33/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Game of cards: <code>spec.alpha</code> #1</h3><pre><code>(def suit? #{:club :diamond :heart :spade})</code></pre><pre><code>(def rank? (into #{:jack :queen :king :ace} (range 2 11)))</code></pre><pre><code>(def deck (for [suit suit? rank rank?] [rank suit]))</code></pre><div class="vspace"></div><pre><code>(s/def :game/card (s/tuple rank? suit?))</code></pre><pre><code>(s/def :game/hand (s/* :game/card))</code></pre><pre><code>(s/def :game/name string?)</code></pre><pre><code>(s/def :game/score int?)</code></pre><div class="vspace"></div><pre><code>(s/def :game/player (s/keys :req [:game/name :game/score :game/hand]))</code></pre><pre><code>(s/def :game/players (s/* :game/player))</code></pre><pre><code>(s/def :game/deck (s/* :game/card))</code></pre><pre><code>(s/def :game/game (s/keys :req [:game/players :game/deck]))</code></pre><pre><code>(def kenny {:game/name "Kenny Rogers", :game/score 100, :game/hand []})</code></pre><div class="vspace"></div><pre><code class="form">(s/valid? :game/player kenny)</code><br><code class="eval">;; => true</code></pre><div class="note smaller"><p>The <em>Guide</em> presents a card game to demonstrate <code>spec.alpha</code>.</p></div><div class="panel-footer"><span class="panel-number">34/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Game of cards: <code>spec.alpha</code> #2</h3><pre><code class="form">(s/explain-data :game/game
                {:game/deck deck,
                 :game/players
                   [{:game/name "Kenny Rogers",
                     :game/score 100,
                     :game/hand [[2 :banana]]}]})</code><br><code class="eval">;; => #:clojure.spec.alpha{:problems
;;                           ({:in [:game/players 0 :game/hand 0
;;                                  1],
;;                             :path [:game/players :game/hand 1],
;;                             :pred screedcast-generator/suit?,
;;                             :val :banana,
;;                             :via [:game/game :game/players
;;                                   :game/players :game/player
;;                                   :game/player :game/hand
;;                                   :game/hand :game/card
;;                                   :game/card]}),
;;                         :spec :game/game,
;;                         :value
;;                           #:game{:deck ([7 :spade]
;;                                         [:king :spade]
;;                                         [4 :spade]
;;                                         [:queen :spade]
;;                                         [:ace :spade]
;;                                         [6 :spade]
;;                                         [3 :spade]
;;                                         [2 :spade]
;;                                         [:jack :spade]
;;                                         [9 :spade]
;;                                         [5 :spade]
;;                                         [10 :spade]
;;                                         [8 :spade]
;;                                         [7 :heart]
;;                                         [:king :heart]
;;                                         [4 :heart]
;;                                         [:queen :heart]
;;                                         [:ace :heart]
;;                                         [6 :heart]
;;                                         [3 :heart]
;;                                         [2 :heart]
;;                                         [:jack :heart]
;;                                         [9 :heart]
;;                                         [5 :heart]
;;                                         [10 :heart]
;;                                         [8 :heart]
;;                                         [7 :diamond]
;;                                         [:king :diamond]
;;                                         [4 :diamond]
;;                                         [:queen :diamond]
;;                                         [:ace :diamond]
;;                                         [6 :diamond]
;;                                         [3 :diamond]
;;                                         [2 :diamond]
;;                                         [:jack :diamond]
;;                                         [9 :diamond]
;;                                         [5 :diamond]
;;                                         [10 :diamond]
;;                                         [8 :diamond]
;;                                         [7 :club]
;;                                         [:king :club]
;;                                         [4 :club]
;;                                         [:queen :club]
;;                                         [:ace :club]
;;                                         [6 :club]
;;                                         [3 :club]
;;                                         [2 :club]
;;                                         [:jack :club]
;;                                         [9 :club]
;;                                         [5 :club]
;;                                         [10 :club]
;;                                         [8 :club]),
;;                                  :players
;;                                    [#:game{:hand [[2 :banana]],
;;                                            :name
;;                                              "Kenny Rogers",
;;                                            :score 100}]}}</code></pre><div class="note smaller"><p></p></div><div class="panel-footer"><span class="panel-number">35/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Game of cards: Speculoos #1</h3><div class="side-by-side-container"><div class="side-by-side"></div><div class="side-by-side"><pre><code>(def suits #{:club :diamond :heart :spade})</code></pre><pre><code>(def ranks (into #{:jack :queen :king :ace} (range 2 11)))</code></pre><pre><code>(def deck (vec (for [s suits r ranks] [r s])))</code></pre><pre><code>(def card-spec [ranks suits])</code></pre><pre><code>(def deck-spec (repeat card-spec))</code></pre><div class="vspace"></div><pre><code class="form">(valid-scalars? deck deck-spec)</code><br><code class="eval">;; => true</code></pre></div></div><div class="note smaller"><p>Let's follow along, slowly building up the Speculoos specification.</p></div><div class="panel-footer"><span class="panel-number">36/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Game of cards: Speculoos #2</h3><div class="side-by-side-container"><div class="side-by-side"></div><div class="side-by-side"><pre><code>(def player-spec {:name string?, :score int?, :hand (repeat card-spec)})</code></pre><pre><code>(def kenny {:name "Kenny Rogers", :score 100, :hand []})</code></pre><div class="vspace"></div><pre><code class="form">(valid-scalars? kenny player-spec)</code><br><code class="eval">;; => true</code></pre><div class="vspace"></div><pre><code>(defn draw-hand [] (vec (take 5 (repeatedly #(first (shuffle deck))))))</code></pre><div class="vspace"></div><pre><code>(def players-spec (repeat player-spec))</code></pre><div class="vspace"></div><pre><code>(def players
  [kenny {:name "Humprey Bogart", :score 188, :hand (draw-hand)}
   {:name "Julius Caesar", :score 77, :hand (draw-hand)}])</code></pre></div></div><div class="note smaller"><p></p></div><div class="panel-footer"><span class="panel-number">37/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Game of cards: Speculoos #3</h3><pre><code class="form">(valid-scalars? (:hand (players 1)) (repeat card-spec))</code><br><code class="eval">;; => true</code></pre><div class="vspace"></div><pre><code class="form">(valid-scalars? players players-spec)</code><br><code class="eval">;; => true</code></pre><div class="vspace"></div><pre><code>(def game [deck players])</code></pre><pre><code>(def game-spec [deck-spec players-spec])</code></pre><div class="vspace"></div><pre><code class="form">(valid-scalars? game game-spec)</code><br><code class="eval">;; => true</code></pre><div class="note smaller"><p></p></div><div class="panel-footer"><span class="panel-number">38/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Game of cards: Speculoos #4</h3><div class="side-by-side-container"><div class="side-by-side"></div><div class="side-by-side"><pre><code>(def corrupted-game (assoc-in game [1 0 :hand 0] [2 :banana]))</code></pre><div class="vspace"></div><pre><code class="form">(only-invalid (validate-scalars corrupted-game
                                game-spec))</code><br><code class="eval">;; => ({:datum :banana,
;;      :path [1 0 :hand 0 1],
;;      :predicate #{:club :diamond :heart :spade},
;;      :valid? nil})</code></pre></div></div><div class="note smaller"><p>What happens when we have bad data?</p><p>Speculoos reports an invalid datum <code>:banana</code> according to predicate <code>suits</code> located at path <code>[1 0 :hand 0 1]</code>, which you can inspect with <code>get-in*</code> and similar functions.</p></div><div class="panel-footer"><span class="panel-number">39/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Generators: <code>spec.alpha</code> #1</h3><pre><code class="form">(gen/sample (s/gen #{:club :diamond :heart :spade}))</code><br><code class="eval">;; => (:spade
;;      :club
;;      :diamond
;;        :heart
;;      :spade
;;        :heart
;;      :diamond
;;        :diamond
;;      :heart
;;        :spade)</code></pre><div class="vspace"></div><pre><code class="form">(gen/sample (s/gen (s/cat :k keyword?
                          :ns (s/+ number?))))</code><br><code class="eval">;; => ((:x/X 2.0)
;;      (:ka/Q9 -0.5)
;;      (:z/K1 0.5 1)
;;      (:Q/y? 3 -1.0 1.75 -2.5)
;;      (:Z/IZ+ 3 -7 -1.5 -3)
;;      (:f/s_ 0.953125 1.0 -1.5 -9 -2.0)
;;      (:!o/Um9 -2.6875 -2.5)
;;      (:./!! -3.0 ##Inf)
;;      (:pd_a/eMjv 1.0 1.0)
;;      (:g/Z?+. 0.25
;;               15 4.859375
;;               -0.814453125 6.0
;;               38 -0.75
;;               -2 -0.53125))</code></pre><div class="note smaller"><p>The <em>spec Guide</em> emphasizes that one of <code>spec.alpha</code>'s explicit design goals is to facilitate property-based testing. <code>spec.alpha</code> does this by closely cooperating with <code>test.check</code>, which generates sample data that conforms to the spec. Next, we'll see a few examples of these capabilities by generating sample data from the card game specs.</p></div><div class="panel-footer"><span class="panel-number">40/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Generators: <code>spec.alpha</code> #1</h3><pre><code class="form">(gen/generate (s/gen :game/player))</code><br><code class="eval">;; => #:game{:hand ([4 :club]
;;                  [:ace :spade]
;;                  [5 :club]
;;                  [:jack :club]
;;                  [5 :spade]
;;                  [:queen :club]
;;                  [:queen :heart]
;;                  [7 :heart]
;;                  [10 :spade]
;;                  [:ace :club]
;;                  [7 :spade]
;;                  [:ace :club]
;;                  [4 :spade]
;;                  [10 :spade]
;;                  [5 :club]
;;                  [6 :heart]
;;                  [8 :spade]
;;                  [:ace :diamond]
;;                  [:ace :club]
;;                  [9 :diamond]
;;                  [10 :heart]
;;                  [6 :heart]
;;                  [6 :spade]
;;                  [9 :club]
;;                  [:king :heart]
;;                  [6 :spade]
;;                  [9 :club]
;;                  [:queen :diamond]
;;                  [:queen :heart]),
;;           :name "Nqw88aai5",
;;           :score -344}</code></pre><div class="note smaller"><p></p></div><div class="panel-footer"><span class="panel-number">41/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Generators: Speculoos #1</h3><div class="side-by-side-container"><div class="side-by-side"></div><div class="side-by-side"><pre><code>(require '[speculoos.utility :refer [data-from-spec]])</code></pre><div class="vspace"></div><pre><code class="form">(data-from-spec game-spec :random)</code><br><code class="eval">;; => [[[:jack :diamond] [9 :diamond]
;;      [8 :diamond] [6 :heart] [4 :club]]
;;     [{:hand [[10 :diamond] [:jack :spade]
;;              [:queen :club] [:king :heart]
;;              [4 :spade]],
;;       :name "YrkQ",
;;       :score 108}
;;      {:hand [[10 :club] [:jack :heart]
;;              [:ace :spade] [10 :diamond]
;;              [:queen :spade]],
;;       :name "88MAx8xtOEGF3A",
;;       :score 861}
;;      {:hand [[10 :spade] [4 :heart]
;;              [2 :heart] [3 :spade]
;;              [:jack :heart]],
;;       :name "a0",
;;       :score -879}
;;      {:hand [[7 :heart] [10 :club]
;;              [:king :diamond]
;;              [:jack :spade]
;;              [:king :spade]],
;;       :name "NGx1894M5uZ8Txwdevi9",
;;       :score -176}
;;      {:hand [[4 :heart] [9 :spade]
;;              [3 :heart] [:king :club]
;;              [:queen :diamond]],
;;       :name "4Do3Cn2u1IeLLpbF0",
;;       :score 538}]]</code></pre></div></div><div class="note smaller"><p>Speculoos provides a very rudimentary version that mimics this functionality. Because <code>game-spec</code> is composed of infinitely-repeating sequences, let's create a simplified version that terminates, using the basic <code>test.check</code> generators. Speculoos cannot in all instances automatically pull apart a compound predicate such as <code>#(and (int? %) (< % 10))</code> in order to compose a generator.</p></div><div class="panel-footer"><span class="panel-number">42/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Generators: Speculoos #2</h3><div class="side-by-side-container"><div class="side-by-side"></div><div class="side-by-side"><pre><code class="form">(data-from-spec [int?] :random)</code><br><code class="eval">;; => [-692]</code></pre><div class="vspace"></div><pre><code class="form">(data-from-spec [nil?])</code><br><code class="eval">;; => [nil]</code></pre><div class="vspace"></div><pre><code class="form">(repeatedly 5 #(data-from-spec [string?] :random))</code><br><code class="eval">;; => (["kYHsowMo1Mvs"]
;;     ["C4cbmhDT9z26"]
;;     ["B5d6dfCY5ZG2"]
;;     ["w61mjbT6"]
;;     ["eTF1NOh1p0aW1Lq4L181nh2Ze"])</code></pre></div></div><div class="note smaller"><p>Automatically setting up generators and property-based testing is the main area where Speculoos lags <code>spec.alpha</code>. I do not yet have a great idea on how to automatically pull apart compound, composed predicates. See the <a href="https://github.com/blosavio/speculoos?tab=readme-ov-file#exercising">docs</a>, <a href="https://blosavio.github.io/speculoos/speculoos.utility.html#var-inspect-fn"><span class="small-caps">api</span></a> and a <a href="#and">later subsection</a> to see how to manually or semi-automatically add generators into the predicate metadata.</p><p>Let's follow along as best as we can…</p></div><div class="panel-footer"><span class="panel-number">43/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Generators: Speculoos #3</h3><div class="side-by-side-container"><div class="side-by-side"></div><div class="side-by-side"><pre><code class="form">(repeatedly 3 #(data-from-spec (into [keyword?] (repeat 3 double?)) :random))</code><br><code class="eval">;; => ([:m*ghPA?0 0.9741200641728938 -228.0
;;      15.038936614990234]
;;     [:?3_.hV 0.016840696334838867
;;      57.23224979639053 -8.0]
;;     [:sc*2 13.85888671875 -285.09375
;;      0.0390625])</code></pre><div class="vspace"></div><pre><code class="form">(data-from-spec player-spec :random)</code><br><code class="eval">;; => {:hand [[8 :club] [:jack :club]
;;            [:king :spade] [7 :heart]
;;            [:queen :club]],
;;     :name "J20J2bShd",
;;     :score 183}</code></pre></div></div><div class="note smaller"><p>The card game specifications refer to earlier sections.</p></div><div class="panel-footer"><span class="panel-number">44/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Exercise</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code class="form">(s/exercise (s/cat :k keyword?
                   :ns (s/+ number?))
            5)</code><br><code class="eval">;; => ([(:?/E 0) {:k :?/E, :ns [0]}]
;;     [(:Vu/!! -3.0 -1)
;;      {:k :Vu/!!, :ns [-3.0 -1]}]
;;     [(:P/n 0 -1 -1)
;;      {:k :P/n, :ns [0 -1 -1]}]
;;     [(:-/*D 0.5 0 2.0 -1.75)
;;      {:k :-/*D, :ns [0.5 0 2.0 -1.75]}]
;;     [(:A8B/m.6 -1 -1)
;;      {:k :A8B/m.6, :ns [-1 -1]}])</code></pre><div class="vspace"></div><pre><code class="form">(s/exercise (s/or :k keyword?
                  :s string?
                  :n number?)
            5)</code><br><code class="eval">;; => (["" [:s ""]]
;;     ["" [:s ""]]
;;     ["gv" [:s "gv"]]
;;     ["6R" [:s "6R"]]
;;     [:P:4/-K? [:k :P:4/-K?]])</code></pre><div class="vspace"></div><pre><code class="form">(s/exercise-fn `ranged-rand)</code><br><code class="eval">;; => ([(-1 0) -1]
;;     [(-8 -2) -8]
;;     [(-4 0) -3]
;;     [(-9 -1) -8]
;;     [(-13 1) -13]
;;     [(-1 21) 15]
;;     [(-6 0) -5]
;;     [(-14 4) -9]
;;     [(0 11) 4]
;;     [(-45 -1) -28])</code></pre></div><div class="side-by-side"><pre><code>(require '[speculoos.utility :refer [exercise]])</code></pre><pre><code>(require '[speculoos.function-specs :refer [exercise-fn]])</code></pre><div class="vspace"></div><pre><code class="form">(exercise [int? string? boolean? char?] 5)</code><br><code class="eval">;; => ([[-992 "869f66VkUQ3v1KqctB68Qbb4a8" false \2] true]
;;     [[-499 "Z2FiVlw44xi35hyU0gsXFp6dk5y" false \2] true]
;;     [[950 "UF6uSg5f8Z84nOuU42n0Vlcs9Vk1" false \0] true]
;;     [[736 "ywykGb93t" true \4] true]
;;     [[-378 "FIdA18ao50QttonFHH2C3H8w8" false \r] true])</code></pre><div class="vspace"></div><pre><code class="form">(inject-specs! ranged-rand {:speculoos/arg-scalar-spec [int? int?]})</code><br><code class="eval">;; => nil</code></pre><div class="vspace"></div><pre><code class="form">(exercise-fn ranged-rand 10)</code><br><code class="eval">;; => ([[843 -471] 622]
;;     [[-176 192] -11]
;;     [[779 -495] 765]
;;     [[310 402] 319]
;;     [[434 282] 325]
;;     [[148 610] 411]
;;     [[-677 357] 304]
;;     [[-183 -223] -220]
;;     [[593 416] 539]
;;     [[156 -664] -11])</code></pre></div></div><div class="note smaller"><p><code>spec.alpha</code>'s data-generating capabilities allows you to <em>exercise</em> a function by invoking it with generated arguments.</p><p>Speculoos mimics the <code>exercise</code> function, but (for now) only exercises a scalar specification.</p><p>Speculoos also mimics <code>spec.alpha</code>'s <code>exercise-fn</code>, again only for scalar specifications, on the function's arguments.</p></div><div class="panel-footer"><span class="panel-number">45/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3><code>and</code> generators #1</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code class="form">(gen/generate (s/gen (s/and int? even?)))</code><br><code class="eval">;; => -124</code></pre><pre><code>(defn divisible-by [n] #(zero? (mod % n)))</code></pre><div class="vspace"></div><pre><code class="form">(gen/sample (s/gen (s/and int?
                          #(> % 0)
                          (divisible-by 3))))</code><br><code class="eval">;; => (3 30 15 83400 6 6303 3 3858 18 3)</code></pre></div><div class="side-by-side"></div></div><div class="note smaller"><p>In certain cases, a spec will require the data to fall within a very small range of possible values, such as <em>an even positive integer, divisible by three, less than 31, greater than 12.</em> The generators are not likely to be able to produce multiple conforming samples using only <code>(s/gen int?)</code>, so we construct predicates with <code>spec.alpha</code>'s <code>and</code>.</p><p>Right now, Speculoos cannot <em>automatically</em> dive into a compound predicate such as <code>#(and (int? %) (even? %))</code> to create a competent generator, but it does offer a few options. First, you could manually compose a random sample generator and attach it the predicate's metadata. You may use whatever generator you prefer; <code>test.check.generators</code> work well.</p></div><div class="panel-footer"><span class="panel-number">46/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3><code>and</code> generators #2: <code>defpred</code> manual generator</h3><div class="side-by-side-container"><div class="side-by-side"></div><div class="side-by-side"><pre><code>(require '[speculoos.utility :refer [defpred validate-predicate->generator]]
         '[clojure.test.check.generators :as tc-gen])</code></pre><pre><code>(defn gen-int-pos-div-by-3
  []
  (last (tc-gen/sample (tc-gen/fmap #(* % 3) tc-gen/nat) 50)))</code></pre><div class="vspace"></div><pre><code>(def pred-1
  (with-meta #(and (int? %) (> % 0) ((divisible-by 3) %))
    {:speculoos/predicate->generator gen-int-pos-div-by-3}))</code></pre><pre><code>(defpred pred-2
         #(and (int? %) (> % 0) ((divisible-by 3) %))
         gen-int-pos-div-by-3)</code></pre><div class="vspace"></div><pre><code class="form">(validate-predicate->generator pred-1 5)</code><br><code class="eval">;; => ([12 true]
;;     [72 true]
;;     [3 true]
;;     [24 true]
;;     [15 true])</code></pre><pre><code class="form">(validate-predicate->generator pred-2 5)</code><br><code class="eval">;; => ([66 true]
;;     [81 true]
;;     [75 true]
;;     [30 true]
;;     [54 true])</code></pre></div></div><div class="note smaller"><p>The <code>defpred</code> utility macro does the equivalent when you explicitly supply a sample generator.</p><p>`validate->...` verifies that the samples produced by generator satisfy the predicate</p></div><div class="panel-footer"><span class="panel-number">47/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3><code>and</code> generators #3: <code>defpred</code> automatic generator</h3><div class="side-by-side-container"><div class="side-by-side"></div><div class="side-by-side"><pre><code>(defpred pred-3 #(and (int? %) (pos? %) ((divisible-by 3) %)))</code></pre><div class="vspace"></div><pre><code class="form">(validate-predicate->generator pred-3 5)</code><br><code class="eval">;; => ([12 true]
;;     [30 true]
;;     [30 true]
;;     [3 true]
;;     [30 true])</code></pre></div></div><div class="note smaller"><p>However, if you write your predicate in a way that conforms to <code>defpred</code>'s assumptions, it <em>will</em> compose a generator automatically.</p><p>This is another area where <code>spec.alpha</code>'s approach outclasses Speculoos. Because you write a <code>spec.alpha</code> spec in an already 'pulled-apart' state, it can compose a generator starting with the first branch of that compound predicate and then use the following predicates as filters to refine the generated values.</p><p>Speculoos consumes predicates as already-defined functions, and it appears fiendishly involved to inspect the internal structure of a function — whose source may not be available — in order to generically extract individual components to an arbitrary nesting depth.</p><p>Three questions<ol><li>Is this why <code>spec.alpha</code> specs are written that way?</li><li>Would it be possible at all to decompose a predicate function object without access to the source?</li><li>If Speculoos never offers fully-automatic sample generation from a given compound predicate, is that deal-breaker for the entire approach?</li></ol></p></div><div class="panel-footer"><span class="panel-number">48/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Custom generators #1</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code>(s/def :ex/kws
  (s/with-gen (s/and keyword? #(= (namespace %) "my.domain"))
              #(s/gen #{:my.domain/name :my.domain/occupation :my.domain/id})))</code></pre><pre><code class="form">(s/valid? :ex/kws :my.domain/name)</code><br><code class="eval">;; => true</code></pre><pre><code class="form">(gen/sample (s/gen :ex/kws))</code><br><code class="eval">;; => (:my.domain/occupation
;;      :my.domain/name
;;      :my.domain/id :my.domain/name
;;      :my.domain/name :my.domain/name
;;      :my.domain/name :my.domain/id
;;      :my.domain/name :my.domain/id)</code></pre></div><div class="side-by-side"></div></div><div class="side-by-side-container"><div class="side-by-side"></div><div class="side-by-side"><pre><code>(def kw-pred
  (into #{} (map #(keyword "my.domain" %) ["name" "occupation" "id"])))</code></pre><div class="vspace"></div><pre><code class="form">(valid-scalars? [:my.domain/name] [kw-pred])</code><br><code class="eval">;; => true</code></pre><div class="vspace"></div><pre><code class="form">(exercise [kw-pred] 5)</code><br><code class="eval">;; => ([[:my.domain/name] true]
;;     [[:my.domain/name] true]
;;     [[:my.domain/name] true]
;;     [[:my.domain/name] true]
;;     [[:my.domain/id] true])</code></pre></div></div><div class="note smaller"><p><code>spec.alpha</code> acknowledges that you may want to generate values by some other means, and thus allows custom generators via <code>with-gen</code>.</p><p>Speculoos considers a free-floating set to be a membership predicate. Speculoos generates sample values by randomly selecting from such a set. We can compose an equivalent set to generate qualified keywords.</p></div><div class="panel-footer"><span class="panel-number">49/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Custom generators #2</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code>(require '[clojure.spec.gen.alpha :as sgen])</code></pre><pre><code>(def kw-gen-3
  (sgen/fmap #(keyword "my.domain" %)
             (sgen/such-that #(not= % "") (sgen/string-alphanumeric))))</code></pre><div class="vspace"></div><pre><code class="form">(sgen/sample kw-gen-3 5)</code><br><code class="eval">;; => (:my.domain/k
;;     :my.domain/xfm
;;     :my.domain/ey
;;     :my.domain/UkH
;;     :my.domain/UY6)</code></pre></div><div class="side-by-side"></div></div><div class="side-by-side-container"><div class="side-by-side"></div><div class="side-by-side"><pre><code>(def kw-pred-2
  (into #{}
        (map #(keyword "my.domain" %)
          (sgen/sample (sgen/such-that #(not= % "")
                                       (sgen/string-alphanumeric))))))</code></pre><div class="vspace"></div><pre><code class="form">(exercise [kw-pred-2] 5)</code><br><code class="eval">;; => ([[:my.domain/9r6] true]
;;     [[:my.domain/djkv9] true]
;;     [[:my.domain/L1i] true]
;;     [[:my.domain/K] true]
;;     [[:my.domain/f] true])</code></pre></div></div><div class="note smaller"><p><code>spec.alpha</code> provides combinators for creating more complicated generators.</p><p>Speculoos merely relies on <code>clojure.core</code> and <code>test.check.generators</code> for that.</p></div><div class="panel-footer"><span class="panel-number">50/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Custom generators #3</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code>(s/def :ex/hello
  (s/with-gen #(clojure.string/includes? % "hello")
              #(sgen/fmap (fn [[s1 s2]] (str s1 "hello" s2))
                          (sgen/tuple (sgen/string-alphanumeric)
                                      (sgen/string-alphanumeric)))))</code></pre><pre><code class="form">(sgen/sample (s/gen :ex/hello))</code><br><code class="eval">;; => ("hello"
;;     "6helloY"
;;     "helloDt"
;;     "uPLhellox"
;;     "wwhello1ni"
;;     "hello"
;;     "1w7K88hello"
;;     "OMyThellodr2oB16"
;;     "7e7qEAohello"
;;     "ThelloVxM")</code></pre></div><div class="side-by-side"></div></div><div class="side-by-side-container"><div class="side-by-side"></div><div class="side-by-side"><pre><code class="form">(exercise [#"\w{0,3}hello\w{1,5}"])</code><br><code class="eval">;; => ([["BhelloJYNdh"] true]
;;     [["helloOiH"] true]
;;     [["8helloK"] true]
;;     [["dhellod"] true]
;;     [["tdhellogEI"] true]
;;     [["chelloaXWS"] true]
;;     [["WhellodjEnT"] true]
;;     [["hellocqa"] true]
;;     [["MZIhello2"] true]
;;     [["XXhellodc3kI"] true])</code></pre></div></div><div class="note smaller"><p><code>spec.alpha</code> making a <em>hello</em>-string generator.</p><p>You could certainly copy-paste that generator and use it as is. Speculoos could also generate a sample string via a regular expression predicate.</p></div><div class="panel-footer"><span class="panel-number">51/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Range specs</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code>(s/def :bowling/roll (s/int-in 0 11))</code></pre><div class="vspace"></div><pre><code class="form">(gen/sample (s/gen :bowling/roll))</code><br><code class="eval">;; => (0 0 0 1 5 1 0 5 10 6)</code></pre></div><div class="side-by-side"><pre><code>(defpred bowling-roll
         #(and (int? %) (<= 0 % 10))
         #(last (gen/sample (gen/large-integer* {:min 0, :max 10}))))</code></pre><pre><code class="form">(validate-predicate->generator bowling-roll)</code><br><code class="eval">;; => ([7 true]
;;     [1 true]
;;     [5 true]
;;     [1 true]
;;     [6 true]
;;     [4 true]
;;     [8 true])</code></pre><pre><code>(defpred bowling-roll-2 #(and (int? %) (<= 0 % 10)) #(rand-int 11))</code></pre><pre><code class="form">(validate-predicate->generator bowling-roll-2)</code><br><code class="eval">;; => ([6 true]
;;     [8 true]
;;     [0 true]
;;     [6 true]
;;     [9 true]
;;     [8 true]
;;     [7 true])</code></pre><pre><code class="form">(exercise [(set (range 11))])</code><br><code class="eval">;; => ([[0] true]
;;     [[4] true]
;;     [[1] true]
;;     [[5] true]
;;     [[0] true]
;;     [[3] true]
;;     [[3] true]
;;     [[4] true]
;;     [[7] true]
;;     [[10] true])</code></pre></div></div><div class="note smaller"><p>Spec-ing and generating a range of integers in <code>spec.alpha</code>.</p><p>Speculoos has a few different ways to do that.</p><p>But for integers, nothing beats the succinctness of <code>rand-int</code>.</p><p>For small group sizes, a set-as-predicate might feel more natural.</p></div><div class="panel-footer"><span class="panel-number">52/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Range of instants</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code>(s/def :ex/the-aughts (s/inst-in #inst "2000" #inst "2010"))</code></pre><div class="vspace"></div><pre><code class="form">(drop 50 (gen/sample (s/gen :ex/the-aughts) 55))</code><br><code class="eval">;; => (#inst "2009-05-22T23:22:50.882-00:00"
;;     #inst "2000-01-01T16:09:16.630-00:00"
;;     #inst "2000-01-01T00:00:00.007-00:00"
;;     #inst "2008-05-26T10:21:41.028-00:00"
;;     #inst "2000-01-01T00:06:16.250-00:00")</code></pre></div><div class="side-by-side"></div></div><div class="side-by-side-container"><div class="side-by-side"></div><div class="side-by-side"><pre><code>(defpred the-aughts
         #(instance? java.util.Date %)
         #(last (gen/sample (s/gen :ex/the-aughts) 55)))</code></pre><div class="vspace"></div><pre><code class="form">(validate-predicate->generator the-aughts 5)</code><br><code class="eval">;; => ([#inst "2000-01-01T00:00:00.218-00:00" true]
;;     [#inst "2000-01-01T00:00:00.004-00:00" true]
;;     [#inst "2000-01-01T00:00:00.000-00:00" true]
;;     [#inst "2009-02-13T16:54:36.144-00:00" true]
;;     [#inst "2000-01-03T23:21:55.430-00:00" true])</code></pre></div></div><div class="note smaller"><p><code>spec.alpha</code> does a range of <code>instant</code>s.</p><p>Unfortunately, <code>test.check</code> does not provide an instance generator for Speculoos to borrow. So I'll shamelessly steal <code>spec.alpha</code>'s.</p></div><div class="panel-footer"><span class="panel-number">53/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>Range of doubles</h3><div class="side-by-side-container"><div class="side-by-side"><pre><code>(s/def :ex/dubs
  (s/double-in :min -100.0 :max 100.0 :NaN? false :infinite? false))</code></pre><div class="vspace"></div><pre><code class="form">(s/valid? :ex/dubs 2.9)</code><br><code class="eval">;; => true</code></pre><pre><code class="form">(s/valid? :ex/dubs Double/POSITIVE_INFINITY)</code><br><code class="eval">;; => false</code></pre><pre><code class="form">(gen/sample (s/gen :ex/dubs))</code><br><code class="eval">;; => (-2.0
;;     2.0
;;     -1.0
;;     -3.0
;;     -2.0
;;     -0.5
;;     1.0
;;     2.75
;;     -0.25
;;     0.4375)</code></pre></div><div class="side-by-side"><div class="vspace"></div><div class="vspace"></div><pre><code>(defpred dubs
         #(and (<= -100 % 100) (not (NaN? %)) (not (infinite? %)))
         #(gen/generate
            (gen/double* {:min -100, :max 100, :infinite? false, "NaN?" true})))</code></pre><div class="vspace"></div><pre><code class="form">(validate-predicate->generator dubs 10)</code><br><code class="eval">;; => ([-0.03125 true]
;;     [6.896982669830322 true]
;;     [15.89151680469513 true]
;;     [0.34375 true]
;;     [14.28515625 true]
;;     [10.75634765625 true]
;;     [-0.03125 true]
;;     [0.0615234375 true]
;;     [3.4903335571289062 true]
;;     [-31.47607421875 true])</code></pre></div></div><div class="note smaller"><p>Finally, <em>The spec Guide</em> illustrates generating doubles with specific conditions.</p><p>Speculoos leans on <code>test.check.generators</code> for that flexibility.</p></div><div class="panel-footer"><span class="panel-number">54/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><div class="panel"><div class="panel-header"></div><h3>What's next.</h3><ol class="de-highlight whats-next"><li>Introduction</li><li>Mechanics</li><li>Validating Scalars</li><li>Validating Collections, Basics</li><li>Validating Collections, Advanced</li><li>Validating Collections, Extras</li><li>Validation Summaries & Thoroughness</li><li>Function Validation</li><li>Generating Random Samples & Exercising</li><li>Utilities</li><li>Predicates</li><li>Non-Terminating Sequences</li><li>Sets</li><li>Troubleshooting</li><li>Comparing spec.alpha to Speculoos</li><li class="highlight">Perhaps So</li><li>Case Study</li></ol><div class="note smaller"><p>Frankly, when I started writing Speculoos, I would have guessed that it could mimic only some fraction of <code>spec.alpha</code>. I think this page demonstrates that it can fulfill a decent chunk. Perhaps somebody else beyond me feels that composing specifications the Speculoos way is more intuitive.</p><p>Still, Speculoos is very much a proof-of-concept, experimental prototype. Function instrumentation is really rough. Custom generators need more polishing. Many of the bottom-level functions could use attention to performance.</p><p><a href="https://github.com/blosavio">Let me know</a> what you think.</p></div><div class="panel-footer"><span class="panel-number">55/55</span><span class="footer-link">https://github.com/blosavio/speculoos</span></div></div><p id="page-footer">Copyright © 2024 Brad Losavio.<br>Compiled 2024 December 02.<div class="license"><p>This program and the accompanying materials are made available under the terms of the <a href="https://opensource.org/license/MIT">MIT License</a>.</p></div><span id="uuid"><br>0c99bbbe-b977-4e5b-8e37-32c2a8f07b0d</span></p></body></head></html>