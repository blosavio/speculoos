<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>speculoos.fn-in documentation</title><link rel="stylesheet" type="text/css" href="codox.css" /><link rel="stylesheet" type="text/css" href="highlight.css" /></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Speculoos</span> <span class="project-version">1</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1"><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>speculoos</span></div></div></li><li class="depth-2 branch"><a href="speculoos.collection-functions.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>collection-functions</span></div></a></li><li class="depth-2 branch"><a href="speculoos.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch current"><a href="speculoos.fn-in.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fn-in</span></div></a></li><li class="depth-2 branch"><a href="speculoos.function-specs.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>function-specs</span></div></a></li><li class="depth-2"><a href="speculoos.utility.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>utility</span></div></a></li></ul><h3 class="no-link"><span class="inner">Speculoos Links</span></h3><ul class="index-link"><li class="depth-1 current"><a href="home.html">Home</a></li><li class="depth-1 current"><a href="documentation.html">Documentation</a></li><li class="depth-1 current"><a href="source.html">Source</a></li><li class="depth-1 current"><a href="contact.html">Contact</a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="speculoos.fn-in.html#var-assoc*"><div class="inner"><span>assoc*</span></div></a></li><li class="depth-1"><a href="speculoos.fn-in.html#var-assoc-in*"><div class="inner"><span>assoc-in*</span></div></a></li><li class="depth-1"><a href="speculoos.fn-in.html#var-dissoc*"><div class="inner"><span>dissoc*</span></div></a></li><li class="depth-1"><a href="speculoos.fn-in.html#var-dissoc-in*"><div class="inner"><span>dissoc-in*</span></div></a></li><li class="depth-1"><a href="speculoos.fn-in.html#var-get*"><div class="inner"><span>get*</span></div></a></li><li class="depth-1"><a href="speculoos.fn-in.html#var-get-in*"><div class="inner"><span>get-in*</span></div></a></li><li class="depth-1"><a href="speculoos.fn-in.html#var-update*"><div class="inner"><span>update*</span></div></a></li><li class="depth-1"><a href="speculoos.fn-in.html#var-update-in*"><div class="inner"><span>update-in*</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">speculoos.fn-in</h1><div class="doc"><div class="markdown"><p>This namespace provides functions to:</p>
<ul>
<li>inspect an element (<code>get</code>)</li>
<li>change an element (<code>assoc</code>)</li>
<li>apply a function to an element (<code>update</code>)</li>
<li>remove an element (<code>dissoc</code>)</li>
</ul>
<p>from any of Clojureâ€™s collection types (plus infinite sequences), similarly to their <code>clojure.core</code> namesakes. The <code>...-in</code> variants operate on any heterogeneous, arbitrarily-nested data structure.</p>
<p>Conventions:</p>
<ul>
<li><code>c</code> collection</li>
<li><code>i</code> index/key</li>
<li><code>x</code> value</li>
<li><code>f</code> function</li>
<li><code>arg1</code>, <code>arg2</code>, <code>arg3</code> optional args to multi-arity function <code>f</code>.</li>
</ul>
</div></div><div class="public anchor" id="var-assoc*"><h3>assoc*</h3><h4 class="type">multimethod</h4><div class="usage"></div><div class="doc"><div class="markdown"><p><code>(assoc* c i val)</code></p>
<p>Returns a new collection <code>c</code> with the key/index <code>i</code> associated with the supplied value <code>val</code>. Similar to <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/assoc"><code>clojure.core/assoc</code></a> , but operates on all Clojure collections. Indexes beyond the end of a sequence are padded with <code>nil</code>.</p>
<p>Note: Because set members are addressed by their value, the <code>assoc*</code>-ed value may match a pre-existing set member, and the returned set may have one fewer members.</p>
<p>Examples:</p>
<pre><code class="language-clojure">(assoc* [11 22 33] 1 99) ;; =&gt; [11 99 33]
(assoc* {:a 11 :b 22} :b 99) ;; =&gt; {:a 11, :b 99}
(assoc* (list 11 22 33) 1 99) ;; =&gt; (11 99 33)
(assoc* #{11 22 33} 22 99) ;; =&gt; #{99 33 11}
(assoc* (range 3) 1 99) ;; =&gt; (0 99 2)
(assoc* (take 6 (iterate dec 10)) 3 99) ;; =&gt; (10 9 8 99 6 5)

;; associating an existing set member reduces the size of the set
(assoc* #{11 22 33} 22 33) ;; =&gt; #{33 11}

;; associating a value into a non-terminating sequence
(take 5 (assoc* (repeat 3) 2 99)) ;; =&gt; (3 3 99 3 3)

;; associating a value beyond a sequence's bounds causes nil-padding
(assoc* [11 22 33] 5 99) ;; =&gt; (11 22 33 nil nil 99)
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/fn_in.clj#L202">view source</a></div></div><div class="public anchor" id="var-assoc-in*"><h3>assoc-in*</h3><div class="usage"><code>(assoc-in* c [i &amp; i_s] x)</code></div><div class="doc"><div class="markdown"><p>Returns collection <code>c</code> with a new value <code>x</code> associated at location <code>i</code>. Similar to <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/assoc-in"><code>clojure.core/assoc-in</code></a> , but operates on any heterogeneous, arbitrarily-nested collections. Supplying an empty path throws an exception.</p>
<p>Examples:</p>
<pre><code class="language-clojure">(assoc-in* [1 2 3 [4 5 [6 7]]] [3 2 1] :foo) ;; =&gt; [1 2 3 [4 5 [6 :foo]]]
(assoc-in* {:a {:b {:c 42}}} [:a :b :c] 99) ;; =&gt; {:a {:b {:c 99}}}
(assoc-in* (list 1 2 [3 4 (list 5)]) [2 1] :foo) ;; =&gt; (1 2 [3 :foo (5)])
(assoc-in* #{1 [2 #{3}]} [[2 #{3}] 1 3] :hello) ;; =&gt; #{1 [2 #{:hello}]}

;; heterogeneous, nested collections
(assoc-in* [11 {:a [22 {:b 33}]}] [1 :a 1 :b] 42) ;; =&gt; [11 {:a [22 {:b 42}]}]
(assoc-in* {'foo (list 11 {22/7 'baz})} ['foo 1 22/7] :new-val) ;; =&gt; {foo (11 {22/7 :new-val})}

;; associating beyond nested sequence's bounds causes nil-padding
(assoc-in* [11 22 [33 44]] [2 3] 99) ;; =&gt; [11 22 (33 44 nil 99)]

;; associating a non-existent key-val in a map merely expands the map
(assoc-in* {:a 11 :b {:c 22}} [:b :d] 99) ;; =&gt; {:a 11, :b {:c 22, :d 99}}
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/fn_in.clj#L244">view source</a></div></div><div class="public anchor" id="var-dissoc*"><h3>dissoc*</h3><h4 class="type">multimethod</h4><div class="usage"></div><div class="doc"><div class="markdown"><p><code>(dissoc* c i)</code></p>
<p>Returns a new collection <code>c</code> with the value located at key/index <code>i</code> removed. Similar to <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/dissoc"><code>clojure.core/dissoc</code></a> , but operates on all Clojure collections. <code>i</code> must be within the bounds of a a sequence. If element at <code>i</code> does not exist in a map or set, the new returned collection is identical. Similarly, <code>dissoc</code>-ing an element from a <code>clojure.lang.Repeat</code> returns an indistinguishable sequence.</p>
<p>Examples:</p>
<pre><code class="language-clojure">(dissoc* [1 2 3] 1) ;; =&gt; [1 3]
(dissoc* {:a 1 :b 2} :a) ;; =&gt; {:b 2}
(dissoc* (list 1 2 3) 1) ;; =&gt; (1 3)
(dissoc* #{1 2 3} 2) ;; =&gt; #{1 3}
(dissoc* (take 3 (cycle [:a :b :c])) 1) ;; =&gt; (:a :c)

;; non-existent entity
(dissoc* #{1 2 3} 99) ;; =&gt; #{1 3 2}
(dissoc* {:a 1 :b 2} :c) ;; =&gt; {:a 1, :b 2}
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/fn_in.clj#L391">view source</a></div></div><div class="public anchor" id="var-dissoc-in*"><h3>dissoc-in*</h3><div class="usage"><code>(dissoc-in* c [i &amp; i_s])</code></div><div class="doc"><div class="markdown"><p>Remove element located at <code>i</code> from an arbitrarily-nested collection <code>c</code>. Any containing collections are preserved if <code>i</code> addresses a single scalar. If <code>i</code> addresses a nested collection, all children are removed.</p>
<p>Examples:</p>
<pre><code class="language-clojure">(dissoc-in* [11 [22 [33 44]]] [1 1 0]) ;; =&gt; [11 [22 [44]]]
(dissoc-in* {:a 11 :b {:c 22 :d 33}} [:b :c]) ;; =&gt; {:a 11, :b {:d 33}}
(dissoc-in* (list 11 (list 22 33)) [1 0]) ;; =&gt; (11 (33))
(dissoc-in* #{11 [22 33]} [[22 33] 0]) ;; =&gt; #{[33] 11}
(dissoc-in* [11 (range 4)] [1 2]) ;; =&gt; [11 (0 1 3)]

;; heterogeneous, nested collections
(dissoc-in* [11 {:a (list 22 [33 44])}] [1 :a 1 0]) ;; =&gt; [11 {:a (22 [44])}]
(dissoc-in* {:a 11 :b [22 #{33 44}]} [:b 1 33]) ;; =&gt; {:a 11, :b [22 #{44}]}

;; dissociating an element that is itself a nested collection
(dissoc-in* [11 [22]] [1]) ;; =&gt; [11]
(dissoc-in* {:a {:b {:c 99}}} [:a :b]) ;; =&gt; {:a {}}

;; containers are preserved
(dissoc-in* [1 [2 [3]]] [1 1 0]) ;; =&gt; [1 [2 []]]
(dissoc-in* [11 {:a 22}] [1 :a]) ;; =&gt; [11 {}]
(dissoc-in* [1 2 #{3}] [2 3]) ;; ;; =&gt; [1 2 #{}]
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/fn_in.clj#L425">view source</a></div></div><div class="public anchor" id="var-get*"><h3>get*</h3><h4 class="type">multimethod</h4><div class="usage"></div><div class="doc"><div class="markdown"><p><code>(get* c i)</code></p>
<p>Inspect the value at location <code>i</code> within a collection <code>c</code>. Similar to <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/get"><code>clojure.core/get</code></a> . Elements contained in vectors and lists are addressed by integer index, elements withing maps are addressed by key (which may be a composite entity), elements withing sets are addressed by the elementâ€™s value (which may be a composite entity).</p>
<p>Examples:</p>
<pre><code class="language-clojure">(get* [1 2 3 4 5] 2) ;; =&gt; 3
(get* {:a 1 :b 2 :c 3} :b) ;; =&gt; 2
(get* (list 1 2 3 4 5) 2) ;; =&gt; 3
(get* #{1 2 3} 2) ;; =&gt; 2
(get* (range 99) 3) ;; =&gt; 3
(get* (cycle [1 2 3]) 5) ;; =&gt; 3

;; non-keyword key
(get* {[1 2 3] 'val-1 99 'val-2} 99) ;; =&gt; val-2
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/fn_in.clj#L64">view source</a></div></div><div class="public anchor" id="var-get-in*"><h3>get-in*</h3><div class="usage"><code>(get-in* c keys)</code></div><div class="doc"><div class="markdown"><p>Inspects the value in heterogeneous, arbitrarily-nested collection <code>c</code> at path <code>keys</code>, a vector of indexes/keys. This version of <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/get-in"><code>clojure.core/get-in</code></a> operates on all Clojure collections. An empty path vector returns the original collection. Performance is not optimized, so it might steal your lunch money.</p>
<p>Examples:</p>
<pre><code class="language-clojure">(get-in* [11 22 33 [44 [55]]] [3 1 0]) ;; =&gt; 55
(get-in* {:a 11 :b {:c 22 :d {:e 33}}} [:b :d :e]) ;; =&gt; 33
(get-in* (list 11 22 [33 (list 44 (list 55))]) [2 1 1 0]) ;; =&gt; 55
(get-in* #{11 [22 [33]]} [[22 [33]] 1 0]) ;; =&gt; 33

;; empty path addresses root collection
(get-in* [11 22 33] []) ;; =&gt; [11 22 33]

;; heterogeneous, nested collections; return may be a collection
(get-in* {:a [11 22 {:b [33 [44] 55 [66]]}]} [:a 2 :b 3]) ;; =&gt; [66]

;; address of a nested set; compare to next example
(get-in* [11 {:a [22 #{33}]}] [1 :a 1   ]) ;; =&gt; #{33}

;; address of an element contained within a nested set; compare to previous example
(get-in* [11 {:a [22 #{33}]}] [1 :a 1 33]) ;; =&gt; 33

;; non-terminating sequence
(get-in* (repeat [11 22 33]) [3 1]) ;; =&gt; 22

;; nested non-terminating sequences
(get-in* (repeat (cycle [:a :b :c])) [99 5]) ;; =&gt; :c
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/fn_in.clj#L97">view source</a></div></div><div class="public anchor" id="var-update*"><h3>update*</h3><div class="usage"><code>(update* c i f)</code><code>(update* c i f arg1)</code><code>(update* c i f arg1 arg2)</code><code>(update* c i f arg1 arg2 arg3)</code><code>(update* c i f arg1 arg2 arg3 &amp; more)</code></div><div class="doc"><div class="markdown"><p>Returns a new collection <code>c</code> with function <code>f</code> applied to the value at location <code>i</code>. If the location doesnâ€™t exist, <code>nil</code> is passed to <code>f</code>. Additional arguments <code>args</code> may be supplied trailing <code>f</code>. Similar to <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/update"><code>clojure.core/update</code></a> , but operates on all Clojure collections.</p>
<p>Note: Because set members are addressed by their value, the <code>update*</code>-ed value may match a pre-existing set member, and the returned set may have one fewer members.</p>
<p>Examples:</p>
<pre><code class="language-clojure">(update* [10 20 30] 1 dec) ;; =&gt; [10 19 30]
(update* {:a 10} :a dec) ;; =&gt; {:a 9}
(update* (list 10 20 30) 1 dec) ;; =&gt; (10 19 30)
(update* #{10 20 30} 20 dec) ;; =&gt; #{19 30 10}

;; function handles nil if no value exists
(update* [1 2 3] 4 (constantly :updated-val)) ;; =&gt; (1 2 3 nil :updated-val)

;; additional args
(update* {:a 99} :a #(/ %1 %2) 9) ;; =&gt; {:a 11}

;; update absorbs existing set member resulting in a smaller set
(update* #{1 2 3} 2 dec) ;; =&gt; #{1 3}
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/fn_in.clj#L274">view source</a></div></div><div class="public anchor" id="var-update-in*"><h3>update-in*</h3><div class="usage"><code>(update-in* m ks f &amp; args)</code></div><div class="doc"><div class="markdown"><p>Returns a new collection <code>c</code> with the value at location <code>ks</code> updated by applying function <code>f</code> to the previous value. Similar to <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/update-in"><code>clojure.core/update-in</code></a> , but operates on any heterogeneous, arbitrarily-nested collection. Additional arguments <code>args</code> may be supplied trailing <code>f</code>. If location <code>ks</code> does not exist, <code>f</code> must handle <code>nil</code>.</p>
<p>Note: Updating a set member to another previously-existing set member will decrease the size of the set.</p>
<p>Examples:</p>
<pre><code class="language-clojure">(update-in* [11 [22 [33]]] [1 1 0] inc) ;; =&gt; [11 [22 [34]]]
(update-in* {:a {:b {:c 99}}} [:a :b :c] inc) ;; =&gt; {:a {:b {:c 100}}}
(update-in* (list 11 [22 (list 33)]) [1 1 0] inc) ;; =&gt; (11 [22 (34)])
(update-in* #{11 [22 #{33}]} [[22 #{33}] 1 33] inc) ;; =&gt; #{[22 #{34}] 11}

;; heterogeneous nested collections
(update-in* [11 {:a 22 :b (list 33 44)}] [1 :b 1] inc) ;; =&gt; [11 {:a 22, :b (33 45)}]
(update-in* {:a [11 #{22}]} [:a 1 22] #(* % 2)) ;; =&gt; {:a [11 #{44}]}

;; beyond end of sequence
(+ nil) ;; =&gt; nil
(update-in* [1 2 3] [3] +) ;; =&gt; (1 2 3 nil)

;; non-existent key-val
(not nil) ;; =&gt; true
(update-in* {:a {:b 11}} [:a :c] not) ;; =&gt; {:a {:b 11, :c true}}

;; updating a set member to an existing value
(update-in* #{11 12} [11] inc) ;; =&gt; #{12}

;; additional args
(update-in* [11 [22 [99]]] [1 1 0] #(/ %1 %2) 3) ;; =&gt; [11 [22 [33]]]
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/fn_in.clj#L309">view source</a></div></div></div></body></html>