<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>speculoos.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Speculoos</span> <span class="project-version">version 7</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1"><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>speculoos</span></div></div></li><li class="depth-2 branch current"><a href="speculoos.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="speculoos.function-specs.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>function-specs</span></div></a></li><li class="depth-2"><a href="speculoos.utility.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>utility</span></div></a></li></ul><ul class="index-link"><li class="depth-1"><a href="https://github.com/blosavio/speculoos">Project home</a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="speculoos.core.html#var-all-paths"><div class="inner"><span>all-paths</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-clamp"><div class="inner"><span>clamp</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-only-invalid"><div class="inner"><span>only-invalid</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-only-valid"><div class="inner"><span>only-valid</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-ordinal-get"><div class="inner"><span>ordinal-get</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-ordinal-get-in"><div class="inner"><span>ordinal-get-in</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-recover-literal-path"><div class="inner"><span>recover-literal-path</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-reduce-indexed"><div class="inner"><span>reduce-indexed</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-valid-collections.3F"><div class="inner"><span>valid-collections?</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-valid-macro.3F"><div class="inner"><span>valid-macro?</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-valid-scalars.3F"><div class="inner"><span>valid-scalars?</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-valid.3F"><div class="inner"><span>valid?</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-validate"><div class="inner"><span>validate</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-validate-collections"><div class="inner"><span>validate-collections</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-validate-macro-with"><div class="inner"><span>validate-macro-with</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-validate-scalars"><div class="inner"><span>validate-scalars</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-validate-with-path-spec"><div class="inner"><span>validate-with-path-spec</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">speculoos.core</h1><div class="doc"><div class="markdown"><p>This namespace provides functions to validate Clojure data. They operate on any heterogeneous, arbitrarily-nested data structure.</p>
<p>Terminology:</p>
<ul>
<li><code>data</code>: A heterogeneous, arbitrarily-nested Clojure data structure that represents information.</li>
<li><code>scalar</code>: A non-divisible datum, such as a number, string, boolean, etc.</li>
<li><code>collection</code>: A composite data structure, such as a vector, list, map, set, lazy-sequence, etc., composed of scalars and other collections.</li>
<li><code>specification</code>: A human- and machine-readable description of data.</li>
<li><code>validate</code>: To systematically apply predicates to datums.</li>
<li><code>valid</code>: All datums satisfy their corresponding predicates; more specifically, <em>zero invalid datum-predicate pairs</em>.</li>
<li><code>path</code>: A vector of indexes/keys that uniquely locate a datum.</li>
<li><code>predicate</code>: A function that returns <code>true</code>/<code>false</code>, usually 1-arity, but in particular circumstances may be more.</li>
<li><code>ordinal</code>: A mode of operation wherein a nested collectionâ€™s path considers only its ordering relative to other collections.</li>
</ul>
<p>Remember three Mottos:</p>
<ol>
<li>Validate scalars separately from validating collections.</li>
<li>Make the specification mimic the shape of the data.</li>
<li>Validation ignores un-paired predicates and un-paired datums.</li>
</ol>
</div></div><div class="public anchor" id="var-all-paths"><h3>all-paths</h3><div class="usage"><code>(all-paths form)</code><code>(all-paths form accumulator path container-type)</code></div><div class="doc"><div class="markdown"><p>Returns a vector of <code>{:path _ :value _}</code> to all values in <code>form</code>, a heterogeneous, arbitrarily-nested data structure, including both scalars (e.g., numbers, strings, etc.) and collections (e.g., lists, vectors, maps, sets). <code>paths</code> are suitable for consumption by <a href="null">get-in*</a>, <a href="null">update-in*</a>, <a href="null">assoc-in*</a>, and the like. Outermost root element is located by <code>MapEntry</code> <code>[:path []]</code>.</p>
<p>Note: The 4-arity version is a recursion target and not intended to be called.</p>
<p>Examples:</p>
<pre><code class="language-clojure">;; vector path elements are zero-indexed integers
(all-paths [42 :foo 22/7])
;; =&gt; [{:path [], :value [42 :foo 22/7]}
;;     {:path [0], :value 42}
;;     {:path [1], :value :foo}
;;     {:path [2], :value 22/7}]

;; map path elements are keys (often keywords, but not always)
(all-paths {:a 11 :b 22})
;; =&gt; [{:path [], :value {:a 11, :b 22}}
;;     {:path [:a], :value 11}
;;     {:path [:b], :value 22}]

;; list path elements are zero-indexed integers
(all-paths (list 11 22))
;; =&gt; [{:path [], :value (11 22)}
;;     {:path [0], :value 11}
;;     {:path [1], :value 22}]

;; set path elements are the values themselves
(all-paths #{:red :blue})
;; =&gt; [{:path [], :value #{:red :blue}}
;;     {:path [:red], :value :red}
;;     {:path [:blue], :value :blue}]

;; heterogeneous, nested collections; multi-element paths composed of integer indexes and keys
(all-paths [42 {:a 'foo}])
;; =&gt; [{:path [], :value [42 {:a foo}]}
;;     {:path [0], :value 42}
;;     {:path [1], :value {:a foo}}
;;     {:path [1 :a], :value foo}]

(all-paths {:x #{99}})
;; =&gt; [{:path [], :value {:x #{99}}}
;;     {:path [:x], :value #{99}}
;;     {:path [:x 99], :value 99}]

</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L188">view source</a></div></div><div class="public anchor" id="var-clamp"><h3>clamp</h3><div class="usage"><code>(clamp c1 c2)</code></div><div class="doc"><div class="markdown"><p>Given two sequences <code>c1</code> and <code>c2</code>, if either <code>(isa? (type _) :speculoos/non-terminating)</code>, clamp its size at the count of the other, stuff its contents into a vector, and return both as <code>[new-c1 new-c2]</code>. If neither are <code>:speculoos/non-terminating</code>, return <code>[c1 c2]</code> unchanged. Supplying two non-terminating sequences throws.</p>
<p>Examples:</p>
<pre><code class="language-clojure">(clamp [:a :b :c :d :e] (range)) ;; =&gt; [[:a :b :c :d :e] [0 1 2 3 4]]
(clamp [] (repeat 42)) ;; ==&gt; [[] []]
(clamp (iterate dec 0) (list 'foo 'bar 'baz)) ;; =&gt; [[0 -1 -2] (foo bar baz)]

;; neither non-terminating; args pass through unchanged
(clamp [1 2 3] (list :a \z)) ;; [[1 2 3] (:a \z)]

;; sequence is only possibly non-terminating; actual argument `c2` is shorter
(clamp [1 2 3 4 5] (range 3)) ;; =&gt; [[1 2 3 4 5] [0 1 2]]
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L74">view source</a></div></div><div class="public anchor" id="var-only-invalid"><h3>only-invalid</h3><div class="usage"><code>(only-invalid validations)</code></div><div class="doc"><div class="markdown"><p>Returns only validation entries where <code>:datum</code> does <strong>not</strong> satisfy <code>:predicate</code>, i.e., <code>:valid?</code> is <code>false</code> or <code>nil</code>.</p>
<p>Examples:</p>
<pre><code class="language-clojure">(only-invalid (validate-scalars [42   :foo     22/7   ]
                                [int? keyword? symbol?]))
;; =&gt; ({:path [2], :datum 22/7, :predicate symbol?, :valid? false})

(only-invalid (validate-collections [42    (list :foo)]
                                    [list? [list?]    ]))
;; =&gt; ({:path [0], :value list?, :datum [42 (:foo)], :ordinal-parent-path [], :valid? false})
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L782">view source</a></div></div><div class="public anchor" id="var-only-valid"><h3>only-valid</h3><div class="usage"><code>(only-valid validations)</code></div><div class="doc"><div class="markdown"><p>Returns only validation entries where <code>:datum</code> satisfies <code>:predicate</code>, i.e., <code>:valid?</code> is neither <code>false</code> nor <code>nil</code>.</p>
<p>Examples:</p>
<pre><code class="language-clojure">(only-valid (validate-scalars [42       :foo    22/7  ]
                              [decimal? symbol? ratio?]))
;; =&gt; ({:path [2], :datum 22/7, :predicate ratio?, :valid? true})

(only-valid (validate-collections [42    (list :foo)]
                                  [list? [list?]    ]))
;; =&gt; ({:path [1 0], :value list?, :datum (:foo), :ordinal-parent-path [0], :valid? true})
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L763">view source</a></div></div><div class="public anchor" id="var-ordinal-get"><h3>ordinal-get</h3><h4 class="type">multimethod</h4><div class="usage"></div><div class="doc"><div class="markdown"><p><code>(ordinal-get coll i)</code></p>
<p>Performs the same task as <a href="null">get*</a>, but when encountering a vector or list, considers only elements that are collections. The element is addressed by an <em>ordinal path</em>. Map elements are addressed by keys, as usual. (Keys may themselves be integers, or a composite value.) Set elements are addressed by their identities.</p>
<p>Examples:</p>
<pre><code class="language-clojure">(ordinal-get [11 [22] 33 [44] [55] 66 [77]] 0) ;; =&gt; [22]
(ordinal-get [11 [22] 33 [44] [55] 66 [77]] 2) ;; =&gt; [55]
(ordinal-get [11 [22] 33 [44] [55] 66 [77]] 3) ;; =&gt; [77]
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L859">view source</a></div></div><div class="public anchor" id="var-ordinal-get-in"><h3>ordinal-get-in</h3><div class="usage"><code>(ordinal-get-in c keys)</code></div><div class="doc"><div class="markdown"><p>A <a href="null">get-in*</a> that, when encountering a vector or list, considers only elements that are collections. Map and set addresses work as usual.</p>
<p>Examples:</p>
<pre><code class="language-clojure">(ordinal-get-in [42 [:foo] 99 [:bar] 33 [:baz]] [2]) ;; =&gt; [:baz]
(ordinal-get-in {:a [[42] [77] ['hello]]} [:a 2]) ;; =&gt; [hello]
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L885">view source</a></div></div><div class="public anchor" id="var-recover-literal-path"><h3>recover-literal-path</h3><div class="usage"><code>(recover-literal-path form ord-path)</code></div><div class="doc"><div class="markdown"><p>Given heterogeneous, arbitrarily-nested data structure <code>form</code> and ordinal collection path <code>ord-path</code>, returns the literal path to the nested child collection.</p>
<p>Examples:</p>
<pre><code class="language-clojure">(recover-literal-path [11 [22] 33 [44] 55 [66]] [2])
;; =&gt; [5]

(recover-literal-path {:a {:b [11 [22] 33 [44]]}}
                      [:a :b 1])
;; =&gt; [:a :b 3]

(recover-literal-path (list 11 22 [33 [44] [55] [66]])
                      [1 2])
;; =&gt; [2 3]
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L1102">view source</a></div></div><div class="public anchor" id="var-reduce-indexed"><h3>reduce-indexed</h3><div class="usage"><code>(reduce-indexed f coll)</code><code>(reduce-indexed f val coll)</code></div><div class="doc"><div class="markdown"><p>Systematically apply <code>f</code> to elements of <code>coll</code>, carrying an index along with the accumulating value, analogous to how <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/map-indexed">map-indexed</a> relates to <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/map">map</a>. Function <code>f</code> should be a function of 3 arguments: zero-indexed integer, the accumulating value, and the next element of <code>coll</code>. <code>coll</code> may be any Clojure collection.</p>
<p>If <code>val</code> is not supplied:</p>
<ul>
<li><code>reduce-indexed</code> returns the result of applying <code>f</code> to the first 2 items coll, then applying <code>f</code> to that result and the 3rd item, etc.</li>
<li>If <code>coll</code> contains zero items, <code>f</code> must accept no arguments as well, and <code>reduce-indexed</code> returns the result of calling <code>f</code> with no arguments.</li>
<li>If <code>coll</code> has only one item, it is returned and <code>f</code> is not called.</li>
</ul>
<p>If <code>val</code> is supplied:</p>
<ul>
<li><code>reduce-indexed</code> returns the result of applying <code>f</code> to <code>val</code> and the first item in <code>coll</code>, then applying <code>f</code> to that result and the 2nd item, etc.</li>
<li>If <code>coll</code> contains zero items, returns <code>val</code> and <code>f</code> is not called.</li>
</ul>
<p>Note:</p>
<ol>
<li>Implemented with only <code>first</code>, <code>next</code>, etc., and therefore currently makes no consideration for performance.</li>
<li>Hash-map and array-map elements are peeled off as instances of <code>clojure.lang.MapEntry</code>, a pseudo-vector of <code>[key value]</code>.</li>
<li>Set elements are consumed in an un-defined order.</li>
</ol>
<p>Examples:</p>
<pre><code class="language-clojure">(reduce-indexed #(conj %2 (vector %1 %3)) [:initial] [:item1 :item2 :item3])
;; =&gt; [:initial [0 :item1] [1 :item2] [2 :item3]]

(reduce-indexed #(assoc %2 %3 %1) {:init-val 99} [:a :b :c])
;; =&gt; {:init-val 99, :a 0, :b 1, :c 2}
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L107">view source</a></div></div><div class="public anchor" id="var-valid-collections.3F"><h3>valid-collections?</h3><div class="usage"><code>(valid-collections? data spec)</code></div><div class="doc"><div class="markdown"><p>Following validation with <a href="speculoos.core.html#var-validate-collections">validate-collections</a>, returns <code>true</code> if every <strong>collection</strong> element in <code>data</code> satisfies every corresponding predicate in collection specification <code>spec</code>, <code>false</code> otherwise.</p>
<p>Note: <code>valid-collections?</code> returns <code>true</code> if validation returns zero <code>{:valid? falsey}</code> results.</p>
<p>Note: If a corresponding specification predicate does not exist, that element of data will not be checked. Use <a href="speculoos.utility.html#var-collections-without-predicates">collections-without-predicates</a> to locate elements of <code>data</code> that lack corresponding predicates in <code>spec</code>. Use <a href="speculoos.utility.html#var-thoroughly-valid-collections.3F">thoroughly-valid-collections?</a> to require that every collection in <code>data</code> is validated.</p>
<p>See <a href="speculoos.core.html#var-validate-collections">validate-collections</a> for details on the mechanics of collection validation.</p>
<p>Examples:</p>
<pre><code class="language-clojure">(valid-collections? [      42 [        :foo]]  ;; &lt;-- data
                    [list?    [vector?     ]]) ;; &lt;-- specification
;; =&gt; false

(valid-collections? {                 :a 42 :b {                 :c 'foo}} ;; &lt;-- data
                    {:outer-coll map?       :b {:inner-coll map?        }});; &lt;-- specification
;; =&gt; true

;; un-paired datum; nested vector in data not tested
(valid-collections? [        11     [22]]
                    [vector?            ])
;; =&gt; true
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L1325">view source</a></div></div><div class="public anchor" id="var-valid-macro.3F"><h3>valid-macro?</h3><div class="usage"><code>(valid-macro? macro-args spec)</code></div><div class="doc"><div class="markdown"><p>Returns <code>true</code> if macroexpansion fully satisfies scalar specification <code>spec</code>. Supply <code>macro</code> and <code>args</code> as if to <code>macroexpand-1</code> itself, i.e., <code>`(macro-name arg1 arg 2...)</code>.</p>
<p>Note 1: Many entities that appear to be a function in a macro expansion are in fact symbols.</p>
<p>Note 2: Macro expansion works subtly different between the CIDER nREPL and from the CLI, e.g. <code>$ lein test</code>. Use syntax quote ` as a workaround.</p>
<p>Use <a href="speculoos.core.html#var-validate-macro-with">validate-macro-with</a> to produce a detailed validation report.</p>
<p>Example:</p>
<pre><code class="language-clojure">(defmacro example-macro [f &amp; args] `(~f ~@args))

(macroexpand-1 `(example-macro + 1 2 3)) ;; =&gt; (clojure.core/+ 1 2 3)

(def example-macro-spec (list symbol? number? number? number?))

(valid-macro? `(example-macro + 1 2 3) example-macro-spec) ;; =&gt; true
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L1509">view source</a></div></div><div class="public anchor" id="var-valid-scalars.3F"><h3>valid-scalars?</h3><div class="usage"><code>(valid-scalars? data spec)</code></div><div class="doc"><div class="markdown"><p>Following validation with <a href="speculoos.core.html#var-validate-scalars">validate-scalars</a>, returns <code>true</code> if every <strong>scalar</strong> element in <code>data</code> satisfies every corresponding predicate in scalar specification <code>spec</code>, <code>false</code> otherwise.</p>
<p>Note: <code>valid-scalars?</code> returns <code>true</code> if validation returns zero <code>{:valid? falsey}</code> results.</p>
<p>Note: If a corresponding specification predicate does not exist, that element of data will not be checked. Use <a href="speculoos.utility.html#var-scalars-without-predicates">scalars-without-predicates</a> to locate elements of <code>data</code> that lack corresponding predicates in <code>spec</code>. Use <a href="speculoos.utility.html#var-thoroughly-valid-scalars.3F">thoroughly-valid-scalars?</a> to require that every scalar in <code>data</code> is validated.</p>
<p>See <a href="speculoos.core.html#var-validate-scalars">validate-scalars</a> for details on the mechanics of scalar validation.</p>
<p>Examples:</p>
<pre><code class="language-clojure">(valid-scalars? [42   :foo     22/7  ]  ;; &lt;-- data
                [int? keyword? ratio?]) ;; &lt;-- specification
;; =&gt; true

(valid-scalars? {:a 42 :b 'foo}
                {:a string? :b symbol?}) ;; =&gt; false

;; un-paired datums
(valid-scalars? [42 :foo 22/7]
                [int?        ]) ;; =&gt; true

;; un-paired predicates
(valid-scalars? {:a 42     }
                {:b symbol?}) ;; =&gt; true
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L801">view source</a></div></div><div class="public anchor" id="var-valid.3F"><h3>valid?</h3><div class="usage"><code>(valid? data scalar-spec collection-spec)</code></div><div class="doc"><div class="markdown"><p>Following validations with <a href="speculoos.core.html#var-validate-scalars">validate-scalars</a> and then with <a href="speculoos.core.html#var-validate-collections">validate-collections</a>, returns <code>true</code> if <code>data</code> satisfies every corresponding predicate in scalar specification <code>scalar-spec</code> and every corresponding predicate in collection specification <code>collection-spec</code>, <code>false</code> otherwise.</p>
<p><code>valid?</code> provides a combined interface to <a href="speculoos.core.html#var-valid-scalars.3F">valid-scalars?</a> and <a href="speculoos.core.html#var-valid-collections.3F">valid-collections?</a>. Scalar validation and collection validation are performed in completely distinct operations. Their results are merely combined into a single <code>true</code>/<code>false</code> high-level summary. Use <a href="speculoos.core.html#var-validate">validate</a> to generate a detailed report of scalar and collection validation.</p>
<p>Note: <code>valid?</code> returns <code>true</code> if validations return zero <code>{:valid? falsey}</code> results.</p>
<p>See <a href="speculoos.core.html#var-validate-scalars">validate-scalars</a> and <a href="speculoos.core.html#var-validate-collections">validate-collections</a> for details on the the mechanics of validation.</p>
<p>Examples:</p>
<pre><code class="language-clojure">(valid? [42 [:foo [22/7]]]             ;; data
        [int? [keyword? [ratio?]]]     ;; scalar specification
        [vector? [vector? [vector?]]]) ;; collections specification
;; =&gt; true

(valid? {:a 42 :b {:c ['foo true]}}           ;; data
        {:a int? :b {:c [keyword? boolean?]}} ;; scalar specification
        {:root-coll map? :b {:c [vector?]}})  ;; collection specification
;; =&gt; false
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L1424">view source</a></div></div><div class="public anchor" id="var-validate"><h3>validate</h3><div class="usage"><code>(validate data scalar-spec collection-spec)</code></div><div class="doc"><div class="markdown"><p>Perform a scalar validation of <code>data</code> using scalar specification <code>scalar-spec</code>, then immediately perform a collection validation of <code>data</code> using collection specification <code>collection-spec</code>, then return the merged vector of each result. See <a href="speculoos.core.html#var-validate-scalars">validate-scalars</a> and <a href="speculoos.core.html#var-validate-collections">validate-collections</a>.</p>
<p>Remember three Mottos:</p>
<ol>
<li>Validate scalars separately from validating collections.</li>
<li>Make the specification mimic the shape of the data.</li>
<li>Validation ignores un-paired predicates and un-paired datums.</li>
</ol>
<p><code>validate</code> performs two separate validations, in two distinct steps, then returns a single summary that merges both results. First, <code>data</code>â€™s scalars are validated, then <code>data</code>â€™s collections are validated. Finally, the results of those two distinct validations are merged into a comprehensive summary.</p>
<p>Examples:</p>
<pre><code class="language-clojure">;; only scalar validation with `validate-scalars`
(validate-scalars [42]    ;; data
                  [int?]) ;; scalar specification
;; =&gt; [{:path [0], :datum 42, :predicate int?, :valid? true}]

;; only collection validation with `validate-collections`
(validate-collections [42]       ;; data
                      [vector?]) ;; collection specification
;; =&gt; ({:path [0], :value vector?, :datum [42], :ordinal-parent-path [], :valid? true})

;; scalar validation, then collection validation, with a single invocation
(validate [42]       ;; data
          [int?]     ;; scalar specification
          [vector?]) ;; collection specification
;; =&gt; ({:path [0], :datum 42, :predicate int?, :valid? true}
;;     {:path [0], :value vector?, :datum [42], :ordinal-parent-path [], :valid? true})


;; only scalar validation with `validate-scalars`
(validate-scalars {:a 11}       ;; data
                  {:a string?}) ;; scalar specification
;; [{:path [:a], :datum 11, :predicate #function[clojure.core/string?--5475], :valid? false}]

;; only collection validation with `validate-collections`
(validate-collections {                 :a 11}  ;; data
                      {:coll-type? map?      }) ;; collection specification
;; ({:path [:coll-type?], :value map?, :datum {:a 11}, :ordinal-parent-path [], :valid? true})

;; scalar validation, then collection validation, with a single invocation
(validate {:a 11}             ;; data
          {:a string?}        ;; scalar specification
          {:coll-type? map?}) ;; collection specification
;; =&gt; ({:path [:a], :datum 11, :predicate string?, :valid? false}
;;     {:path [:coll-type?], :value map?, :datum {:a 11}, :ordinal-parent-path [], :valid? true})
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L1364">view source</a></div></div><div class="public anchor" id="var-validate-collections"><h3>validate-collections</h3><div class="usage"><code>(validate-collections data spec)</code></div><div class="doc"><div class="markdown"><p>Returns a sequence of <code>{:path-predicate _ :predicate _ :path-datum _ :datum _ :ordinal-path-datum _ :valid? _}</code> hash-maps for every <strong>collection</strong> datum in <code>data</code> with a corresponding predicate in collection specification <code>spec</code>. <code>data</code> is an arbitrarily-nested, heterogeneous data structure. <code>spec</code> is a corresponding â€˜shapeâ€™, i.e., all nested structures are of the same type and position. Only elements of <code>spec</code> that satisfy <code>fn?</code> are used. <code>validate-collections</code> descends into all nested collections. <code>validate-collections</code> only validates complete datum-predicate pairs., i.e., only collections in <code>data</code> that have a corresponding predicate in <code>spec</code>. See <a href="speculoos.core.html#var-valid-collections.3F">valid-collections?</a> and <a href="speculoos.utility.html#var-thoroughly-valid-collections.3F">thoroughly-valid-collections?</a> for high-level summaries of collection validation.</p>
<ul>
<li><code>:path-predicate</code> is a vector suitable for sending to <a href="null">get-in*</a>, <a href="null">assoc-in*</a>, <a href="null">update-in*</a>, etc., that locates the predicate within the specification.</li>
<li><code>:path-datum</code> is the literal path to the datum within <code>data</code> to which the the collection predicate is applied.</li>
<li><code>:ordinal-path-datum</code> is a vector suitable for sending to <a href="speculoos.core.html#var-ordinal-get">ordinal-get</a> and <a href="speculoos.core.html#var-ordinal-get-in">ordinal-get-in</a>, which locates the collection within <code>data</code> to which the collection predicate is applied.</li>
<li><code>:predicate</code> is a 1-arity function which returns truthy/falsey.</li>
<li><code>:datum</code> is the collection entity in <code>data</code>.</li>
<li><code>:valid?</code> is the result of invoking the predicate with the collection datum.</li>
</ul>
<p>The ordering of results is an implementation detail and not specified.</p>
<p>Remember three Mottos:</p>
<ol>
<li>Validate scalars separately from validating collections.</li>
<li>Make the specification mimic the shape of the data.</li>
<li>Validation ignores un-paired predicates and un-paired datums.</li>
</ol>
<p>Predicates at <code>path</code> within the collection specification are applied to the collection located at <code>(drop-last path)</code> within <code>data</code>. Generally, the predicate is applied to the â€˜parentâ€™ collection that contains it.</p>
<p>Examples:</p>
<pre><code class="language-clojure">(validate-collections [42      [99     ]]  ;; &lt;-- data
                      [vector? [vector?]]) ;; &lt;-- specification
;; =&gt; ({:datum [42 [99]], :valid? true, :path-predicate [0], :predicate vector?, :ordinal-path-datum [], :path-datum []}
;;     {:datum [99], :valid? true, :path-predicate [1 0], :predicate vector?, :ordinal-path-datum [0], :path-datum [1]})

;; predicate `vector?` at path [0] in specification is applied to the collection at path (drop-last [0]) in data
;; predicate `vector?` at path [1 0] in specification is applied to the collection at path (drop-last [1 0]) in data

(validate-collections {                :a 42 :b {                   :c 99}}
                      {:root-coll map?       :b {:child-coll? list?      }})
;; =&gt; ({:datum {:a 42, :b {:c 99}}, :valid? true, :path-predicate [:root-coll], :predicate map?, :ordinal-path-datum [], :path-datum []}
;;     {:datum {:c 99}, :valid? false, :path-predicate [:b :child-coll?], :predicate list?, :ordinal-path-datum [:b], :path-datum [:b]})

;; predicate `map?` at path [:root-coll] in specification is applied to the collection at path (drop-last [:root-coll]) in data
;; predicate `list?` at path [:b :child-coll?] in specification is applied to the collection at path (drop-last [:b :child-coll?]) in data
</code></pre>
<p>Only complete collection-predicate pairs are validated. Un-paired collections and un-paired predicates are ignored.</p>
<pre><code class="language-clojure">;; nested vector in data is not paired with a corresponding predicate in specification
(validate-collections [11 22 33 [44 55 66]] ;;  &lt;-- data
                      [vector?  [        ]]) ;; &lt;-- specification
;; =&gt; ({:datum [11 22 33 [44 55 66]], :valid? true, :path-predicate [0], :predicate vector?, :ordinal-path-datum [], :path-datum []})

;; specification's map does not contain a predicate that corresponds to data's outer map
(validate-collections {:a 11 :b [22 33]}  ;; &lt;-- data
                      {      :b [list?]}) ;; &lt;-- specification
;; =&gt; ({:datum [22 33], :valid? false, :path-predicate [:b 0], :predicate list?, :ordinal-path-datum [:b], :path-datum [:b]})

;; un-paired list? and set? predicates in collection specification are ignored
(validate-collections [99] [vector? [list?] [set?]])
;; =&gt; ({:datum [99], :valid? true, :path-predicate [0], :predicate vector?, :ordinal-path-datum [], :path-datum []})
</code></pre>
<p>Note: (Possibly) non-terminating sequences are clamped at the length of the corresponding element in the other collection. Therefore, if there are fewer <code>spec</code> predicates than elements to be tested in <code>data</code>, you must pad the collection specification, e.g., <code>(constantly true)</code>, to force validation of those datums. (I donâ€™t like this policy, but I donâ€™t have a better heuristic by which to clamp a non-terminating sequence with in-band information.)</p>
<pre><code class="language-clojure">;; non-terminating specification is clamped at the length of the data
(validate-collections [[11] [22] [33]]
                      (repeat [vector?]))
;; =&gt; ({:datum [11], :valid? true, :path-predicate [0 0], :predicate vector?, :ordinal-path-datum [0], :path-datum [0]}
;;     {:datum [22], :valid? true, :path-predicate [1 0], :predicate vector?, :ordinal-path-datum [1], :path-datum [1]}
;;     {:datum [33], :valid? true, :path-predicate [2 0], :predicate vector?, :ordinal-path-datum [2], :path-datum [2]})

;; non-terminating data is clamped at the length of the specification
(validate-collections (cycle [[11] [22] [33]])
                      [[vector?]])
;; =&gt; ({:datum [11], :valid? true, :path-predicate [0 0], :predicate vector?, :ordinal-path-datum [0], :path-datum [0]})

;; only the first nested vector is validated because the data's non-terminating sequence
;; was clamped to the length of the specification

;; padding the specification to catch the full cycle of the data
(validate-collections (cycle [[11] [22] [33]])
                      [[vector?] [any?] [any?]])
;; =&gt; ({:datum [11], :valid? true, :path-predicate [0 0], :predicate vector?, :ordinal-path-datum [0], :path-datum [0]}
;;     {:datum [22], :valid? true, :path-predicate [1 0], :predicate any?, :ordinal-path-datum [1], :path-datum [1]}
;;     {:datum [33], :valid? true, :path-predicate [2 0], :predicate any?, :ordinal-path-datum [2], :path-datum [2]})
</code></pre>
<p>Overview of the algorithm.</p>
<ol>
<li>Run <a href="speculoos.core.html#var-all-paths">all-paths</a> on the data.
<pre><code class="language-clojure">(all-paths [11 {:b 22} [[33]]])
;; =&gt; [{:path [], :value [11 {:b 22} [[33]]]}
;;     {:path [0], :value 11}
;;     {:path [1], :value {:b 22}}
;;     {:path [1 :b], :value 22}
;;     {:path [2], :value [[33]]}
;;     {:path [2 0], :value [33]}
;;     {:path [2 0 0], :value 33}]

;; Seven total elements: four collections, three scalars.
</code></pre>
</li>
<li>Run <a href="speculoos.core.html#var-all-paths">all-paths</a> on the specification.
<pre><code class="language-clojure">(all-paths [vector? {:coll-type? map?} [[list?]]])
;; =&gt; [{:path [], :value [vector? {:coll-type? map?} [[list?]]]}
;;     {:path [0], :value vector?}
;;     {:path [1], :value {:coll-type? map?}}
;;     {:path [1 :coll-type?], map?}
;;     {:path [2], :value [[list?]]}
;;     {:path [2 0], :value [list?]}
;;     {:path [2 0 0], :value list?}]

;; Seven total elements: four collections, three predicates.
</code></pre>
</li>
<li>
<p>Remove <strong>scalar</strong> elements from the data.</p>
<pre><code class="language-clojure">(filter #(coll? (:value %)) (all-paths [11 {:b 22} [[33]]]))
;; =&gt; ({:path [], :value [11 {:b 22} [[33]]]}
;;     {:path [1], :value {:b 22}}
;;     {:path [2], :value [[33]]}
;;     {:path [2 0], :value [33]})

;; Four collections in data.
</code></pre>
</li>
<li>
<p>Remove <strong>collections</strong> from the specification.</p>
<pre><code class="language-clojure">(only-fns (all-paths [vector? {:coll-type? map?} [[list?]]]))
;; =&gt; [{:path [0], :value vector?}
;;     {:path [1 :coll-type?], :value map?}
;;     {:path [2 0 0], :value list?}]

;; Three predicates in specification.
</code></pre>
</li>
<li>
<p>Associate predicates in the specification with collections in the data. The collections in the data correspond to the <em>containers/parent</em> of the predicate within the specification. Basically, the predicate at <code>path</code> in the specification will be applied to the collection at <code>(drop-last)</code> in the data.</p>
<pre><code class="language-clojure">;; predicate `vector?` at path [0] in spec is paired with entity at path (drop-last [0]) in data
;; predicate `map?` at path [1 :coll-type?] in spec is paired with entity at path (drop-last [1 :coll-type?]) in data
;; predicate `list?` at path [2 0 0] in spec is paired with entity at path (drop-last [2 0 0]) in data
;; the nested vector at path [2] in data does not have a corresponding predicate in specification; it will not be validated
</code></pre>
</li>
<li>
<p>For each collection-predicate pair, apply the predicate to the collection.</p>
<pre><code class="language-clojure">(vector? [11 {:b 22} [[33]]]) ;; true
(map? {:b 22}) ;; true
(list? [33]) ;; false

;; or, all at once             v-----------------------v-----v--------- these scalars in data are ignored
(validate-collections [        11 {                 :b 22} [[33   ]]]  ;; &lt;-- data
                      [vector?    {:coll-type? map?      } [[list?]]]) ;; &lt;-- specification
;;                     ^-----------------------^-------------^--------- these predicates in spec are applied
;;                                                                      to the parent containers in data

;; =&gt; ({:datum [11 {:b 22} [[33]]], :valid? true, :path-predicate [0], :predicate vector?, :ordinal-path-datum [], :path-datum []}
;;     {:datum {:b 22}, :valid? true, :path-predicate [1 :coll-type?], :predicate map?, :ordinal-path-datum [0], :path-datum [1]}
;;     {:datum [33], :valid? false, :path-predicate [2 0 0], :predicate list?, :ordinal-path-datum [1 0], :path-datum [2 0]})
</code></pre>
</li>
</ol>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L1130">view source</a></div></div><div class="public anchor" id="var-validate-macro-with"><h3>validate-macro-with</h3><div class="usage"><code>(validate-macro-with macro-args spec)</code></div><div class="doc"><div class="markdown"><p>Returns results of validating the macroexpansion of a macro and arguments against scalar specification <code>spec</code>. Supply <code>macro-args</code> as if to <code>macroexpand-1</code> itself, i.e., <code>`(macro-name arg1 arg 2...)</code>.</p>
<p>Note: Many entities that appear to be a function in a macro expansion are, in fact, symbols.</p>
<p>Use <a href="speculoos.core.html#var-valid-macro.3F">valid-macro?</a> to produce a high-level summary result.</p>
<p>Example:</p>
<pre><code class="language-clojure">(defmacro example-macro [f &amp; args] `(~f ~@args))

(macroexpand-1 `(example-macro + 1 2 3)) ;; =&gt; (clojure.core/+ 1 2 3)

(def example-macro-spec (list symbol? number? number? number?))

(validate-macro-with `(example-macro + 1 2 3) example-macro-spec)
;; =&gt; [{:path [0], :datum clojure.core/+, :predicate symbol?, :valid? true}
;;     {:path [1], :datum 1, :predicate number?, :valid? true}
;;     {:path [2], :datum 2, :predicate number?, :valid? true}
;;     {:path [3], :datum 3, :predicate number?, :valid? true}]
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L1480">view source</a></div></div><div class="public anchor" id="var-validate-scalars"><h3>validate-scalars</h3><h4 class="type">multimethod</h4><div class="usage"></div><div class="doc"><div class="markdown"><p>Returns a sequence of <code>{:path _ :datum _ :predicate _ :valid? _}</code> hash-maps for every <strong>scalar</strong> datum in <code>data</code> with a corresponding predicate in scalar specification <code>spec</code>. <code>data</code> is a heterogeneous, arbitrarily-nested data structure of arbitrary values. <code>spec</code> is a corresponding â€˜shapeâ€™, i.e., all nested structures are of the same type and length, containing predicates to test against. <code>validate-scalars</code> recursively descends into all nested collections. Only validates complete datum-predicate pairs, i.e., only nodes that are in both <code>data</code> and in <code>spec</code>. See <a href="speculoos.core.html#var-valid-scalars.3F">valid-scalars?</a> and <a href="speculoos.utility.html#var-thoroughly-valid-scalars.3F">thoroughly-valid-scalars?</a> for high-level summaries of scalar validation.</p>
<ul>
<li><code>:path</code> is a vector suitable for sending to <a href="null">get-in*</a>, <a href="null">assoc-in*</a>, <a href="null">update-in*</a>, and friends.</li>
<li><code>:datum</code> is the scalar entity in <code>data</code>.</li>
<li><code>:predicate</code> is a 1-arity function-like thing that returns truthy/falsey, i.e, regexes and sets may serve as predicates.</li>
<li><code>:valid?</code> is the result of invoking the predicate with the scalar datum.</li>
</ul>
<p>The ordering of results is an implementation detail and not specified.</p>
<p>Remember three Mottos:</p>
<ol>
<li>Validate scalars separately from validating collections.</li>
<li>Make the specification mimic the shape of the data.</li>
<li>Validation ignores un-paired predicates and un-paired datums.</li>
</ol>
<p>Examples:</p>
<pre><code class="language-clojure">(validate-scalars [42   :foo     \c   ] ;; &lt;-- data
                  [int? keyword? char?]) ;; &lt;-- specification
;; =&gt; [{:path [0], :datum 42, :predicate int?, :valid? true}
;;     {:path [1], :datum :foo, :predicate keyword?, :valid? true}
;;     {:path [2], :datum \c, :predicate char?, :valid? true}]

(validate-scalars {:a 42    :b 'foo  }  ;; &lt;-- data
                  {:a int? :b symbol?}) ;; &lt;-- specification
;; =&gt; [{:path [:a], :datum 42, :predicate int?, :valid? true}
;;     {:path [:b], :datum foo, :predicate symbol?, :valid? true}]

;; nested data and specification
(validate-scalars [42     {:z 'baz}    ]
                  [ratio? {:z keyword?}])
;; =&gt; [{:path [0], :datum 42, :predicate ratio?, :valid? false}
;;     {:path [1 :z], :datum baz, :predicate keyword?], :valid? false}]

;; data and specification not same length
(validate-scalars [42 :foo 22/7]
                  [int?        ])
;; =&gt; [{:path [0], :datum 42, :predicate int?, :valid? true}]

(validate-scalars [42                     ]
                  [decimal? keyword? char?])
;; =&gt; [{:path [0], :datum 42, :predicate decimal?, :valid? false}]

;; regular expression predicate
(validate-scalars [ "foo"]
                  [#"f.."])
;; =&gt; [{:path [0], :datum "foo", :predicate #"f..", :valid? "foo"}]

;; set as a membership predicate
(validate-scalars [:green              ]
                  [#{:red :green :blue}])
;; =&gt; [{:path [0], :datum :green, :predicate #{:green :red :blue}, :valid? :green}]
</code></pre>
<p>Within a scalar specification, a bare regular expression literal <code>#"..."</code> is automatically treated as <code>#(re-matches #"...")</code>.</p>
<pre><code class="language-clojure">(validate-scalars ["abc" "xyz"]
                  [#"a.c" #"^[wxyz]{3}$"])
;; =&gt; [{:path [0], :datum "abc", :predicate #"a.c", :valid? "abc"}
;;     {:path [1], :datum "xyz", :predicate #"^[wxyz]{3}$", :valid? "xyz"}]
</code></pre>
<p>Within a scalar specification, a set is treated as a membership predicate when the data at that same path in the data contains a scalarâ€¦</p>
<pre><code class="language-clojure">(validate-scalars [11    :red]
                  [int? #{:blue :green :red}]) ;; &lt;-- set in specification, but not in data
;; =&gt; [{:path [1], :datum :red, :predicate #{:green :red :blue}, :valid? :red}
;;     {:path [0], :datum 11, :predicate int?, :valid? true}]
</code></pre>
<p>â€¦ whereas a set in the scalar specification at the same path as a set in the data is treated as a regular nested collection: The set mimics a container in the data. Any predicates within the specification set are applied to <em>all</em> scalars contained in the data as if <code>#(every? keyword? %)</code>. The key is changed from <code>:datum</code> to <code>:datums-set</code> to emphasize this behavior.</p>
<pre><code class="language-clojure">(validate-scalars [11   #{:tea :coffee :water}]  ;; &lt;-- sets in both data...
                  [int? #{:keyword?}          ]) ;; &lt;-- ... and in specification
;; =&gt; ({:path [0], :datum 11, :predicate #function[clojure.core/int?], :valid? true}
;;     {:path [1], :datums-set #{:coffee :tea :water}, :predicate :keyword?, :valid? false})
</code></pre>
<p>Non-terminating sequences in <code>data</code> are acceptable as long as the corresponding sequence (i.e., at the same path) in <code>spec</code> terminates, and <em>vice versa</em>.</p>
<pre><code class="language-clojure">(validate-scalars (cycle [42 'foo 22/7])   ;; &lt;-- data is an infinite sequence
                  [int? keyword? ratio?])  ;; &lt;-- specification terminates
;; =&gt; [{:path [0], :datum 42, :predicate int?, :valid? true}
;;     {:path [1], :datum foo, :predicate keyword?, :valid? false}
;;     {:path [2], :datum 22/7, :predicate ratio?, :valid? true}]

(validate-scalars [11 22 33]     ;; &lt;-- data terminates
                  (repeat int?)) ;; &lt;-- specification is an infinite sequence
;; =&gt; [{:path [0], :datum 11, :predicate int?, :valid? true}
;;     {:path [1], :datum 22, :predicate int?, :valid? true}
;;     {:path [2], :datum 33, :predicate int?, :valid? true}]
</code></pre>
<p>Overview of the algorithm.</p>
<ol>
<li>
<p>Run <a href="speculoos.core.html#var-all-paths">all-paths</a> on the data.</p>
<pre><code class="language-clojure">;; data is a three-element vector composed of an integer, a symbol, and a ratio
(all-paths [42 'foo 22/7])
;; =&gt; [{:path [], :value [42 foo 22/7]}
;;     {:path [0], :value 42}
;;     {:path [1], :value foo}
;;     {:path [2], :value 22/7}]

;; Four total elements: one vector and three scalars.
</code></pre>
</li>
<li>
<p>Run <a href="speculoos.core.html#var-all-paths">all-paths</a> on the specification.</p>
<pre><code class="language-clojure">;; specification is a two-element vector composed of an `int?` predicate and a `keyword?` predicate
;; will only validate first and second elements of data
(all-paths [int? keyword?])
;; =&gt; [{:path [], :value [int? keyword?]}
;;     {:path [0], :value int?}
;;     {:path [1], :value keyword?}

;; Three total elements: one vector and two scalars (i.e., predicate functions).
</code></pre>
</li>
<li>
<p>Remove collections elements from each result.</p>
<pre><code class="language-clojure">;; remove non-collections from data's all-paths sequence
(only-non-collections [{:path [], :value [42 'foo 22/7]}
                       {:path [0], :value 42}
                       {:path [1], :value 'foo}
                       {:path [2], :value 22/7}])
;; =&gt; [{:path [0], :value 42}
;;     {:path [1], :value foo}
;;     {:path [2], :value 22/7}]

;; remove non-collections from specification's all-paths sequence
(only-non-collections [{:path [], :value [int? keyword?]}
                       {:path [0], :value int?}
                       {:path [1], :value keyword?}])
;; =&gt; [{:path [0], :value int?}
;;     {:path [1], :value keyword?}]
</code></pre>
</li>
<li>
<p>Remove from data scalars that lack a predicate in the specification.</p>
<pre><code class="language-clojure">;; =&gt; [{:path [0], :value 42}
;;     {:path [1], :value foo}

;; third element of data vector does not have a corresponding predicate
</code></pre>
</li>
<li>
<p>Remove from specification predicates that lack a scalar in the data.</p>
<pre><code class="language-clojure">;; =&gt; [{:path [0], :value int?}
;;     {:path [1], :value keyword?}]

;; both predicates contained in specification have a corresponding scalar
</code></pre>
</li>
<li>
<p>For each scalar-predicate pair, apply the predicate to the scalar.</p>
<pre><code class="language-clojure">(int? 42) ;; =&gt; true
(keyword? 'foo) ;; =&gt; false

;; or, all at once
(validate-scalars [42   'foo     22/7]  ;; &lt;-- data, a three-element vector
                  [int? keyword?     ]) ;; &lt;-- specification, a two-element vector
;; [{:path [0], :datum 42, :predicate int?, :valid? true}
    {:path [1], :datum foo, :predicate keyword?, :valid? false}]
</code></pre>
</li>
</ol>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L541">view source</a></div></div><div class="public anchor" id="var-validate-with-path-spec"><h3>validate-with-path-spec</h3><div class="usage"><code>(validate-with-path-spec data spec)</code></div><div class="doc"><div class="markdown"><p>Given a heterogeneous, arbitrarily-nested structure <code>data</code>, validate against path specification vector <code>spec</code>. Each entry in <code>spec</code> is a map with keys <code>:paths</code> and <code>:predicate</code>. <code>:paths</code> is a vector to <a href="null">get-in*</a> paths to elements (scalar and/or collections) in <code>data</code>, supplied in-order to the function associated with <code>:predicate</code>, whose arity matches the number of paths in <code>:paths</code>. The function should return truthy or falsey values (strict <code>true</code>/<code>false</code> is recommended, but not required).</p>
<p>Examples:</p>
<pre><code class="language-clojure">;; relating one scalar to another (predicate is 2-arity)
(validate-with-path-spec [11 :foo 22] [{:paths [[2] [0]] :predicate #(= %2 (/ %1 2))}])
;; =&gt; ({:args (22 11), :valid? true, :paths [[2] [0]], :predicate fn--47025]})

;; relating one scalar to another, different depths of the sequence (predicate is 3-arity)
(validate-with-path-spec {:a 42 :b [42 {:c 42}]} [{:paths [[:b 0] [:a] [:b 1 :c]] :predicate #(= %1 %2 %3)}])
;; =&gt; ({:args (42 42 42), :valid? true, :paths [[:b 0] [:a] [:b 1 :c]], :predicate fn--47045]})

;; specification containing two validations
(validate-with-path-spec [:foo [42 22/7]] [{:paths [[1 0]] :predicate int?} {:paths [[1]] :predicate vector?}])
;; =&gt; ({:args (42), :valid? true, :paths [[1 0]], :predicate int?]}
;;     {:args ([42 22/7]), :valid? true, :paths [[1]], :predicate vector?]})
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L1540">view source</a></div></div></div></body></html>