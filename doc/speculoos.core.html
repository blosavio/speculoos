<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>speculoos.core documentation</title><link rel="stylesheet" type="text/css" href="codox.css" /><link rel="stylesheet" type="text/css" href="highlight.css" /></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Speculoos</span> <span class="project-version">version1</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1"><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>speculoos</span></div></div></li><li class="depth-2 branch"><a href="speculoos.collection-functions.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>collection-functions</span></div></a></li><li class="depth-2 branch current"><a href="speculoos.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="speculoos.fn-in.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fn-in</span></div></a></li><li class="depth-2 branch"><a href="speculoos.function-specs.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>function-specs</span></div></a></li><li class="depth-2"><a href="speculoos.utility.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>utility</span></div></a></li></ul><h3 class="no-link"><span class="inner">Speculoos Links</span></h3><ul class="index-link"><li class="depth-1 current"><a href="home.html">Home</a></li><li class="depth-1 current"><a href="documentation.html">Documentation</a></li><li class="depth-1 current"><a href="source.html">Source</a></li><li class="depth-1 current"><a href="contact.html">Contact</a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="speculoos.core.html#var-all-paths"><div class="inner"><span>all-paths</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-clamp"><div class="inner"><span>clamp</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-only-invalid"><div class="inner"><span>only-invalid</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-only-valid"><div class="inner"><span>only-valid</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-ordinal-get"><div class="inner"><span>ordinal-get</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-ordinal-get-in"><div class="inner"><span>ordinal-get-in</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-valid-collections.3F"><div class="inner"><span>valid-collections?</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-valid-macro.3F"><div class="inner"><span>valid-macro?</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-valid-scalars.3F"><div class="inner"><span>valid-scalars?</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-valid.3F"><div class="inner"><span>valid?</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-validate"><div class="inner"><span>validate</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-validate-collections"><div class="inner"><span>validate-collections</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-validate-macro-with"><div class="inner"><span>validate-macro-with</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-validate-scalars"><div class="inner"><span>validate-scalars</span></div></a></li><li class="depth-1"><a href="speculoos.core.html#var-validate-with-path-spec"><div class="inner"><span>validate-with-path-spec</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">speculoos.core</h1><div class="doc"><div class="markdown"><p>This namespace provides functions to validate Clojure data. They operate on any heterogeneous, arbitrarily-nested data structure.</p>
<p>Terminology:</p>
<ul>
<li><code>validate</code>: To systematically apply predicates to datums.</li>
<li><code>valid</code>: All datums satisfy their corresponding predicates.</li>
<li><code>scalar</code>: A non-divisible datum, such as a number, string, boolean, etc.</li>
<li><code>collection</code>: A composite data structure, such as a vector, list, map, set, lazy-sequence, etc., composed of scalars and other collections.</li>
<li><code>path</code>: A vector of indexes/keys that uniquely locate a datum.</li>
<li><code>predicate</code>: A function that returns <code>true</code>/<code>false</code>, usually 1-arity, but in particular circumstances may be more.</li>
<li><code>ordinal</code>: A mode of operation wherein a nested collectionâ€™s path considers only its ordering relative to other collections.</li>
</ul>
</div></div><div class="public anchor" id="var-all-paths"><h3>all-paths</h3><div class="usage"><code>(all-paths form)</code><code>(all-paths form accumulator path container-type)</code></div><div class="doc"><div class="markdown"><p>Returns a vector of <code>{:path _ :value _}</code> to all values in <code>form</code>, a heterogeneous, arbitrarily-nested data structure, including both scalars (e.g., numbers, strings, etc.) and collections (e.g., lists, vectors, maps, sets). <code>paths</code> are suitable for consumption by <a href="speculoos.fn-in.html#var-get-in*">get-in*</a>, <a href="speculoos.fn-in.html#var-update-in*">update-in*</a>, <a href="speculoos.fn-in.html#var-assoc-in*">assoc-in*</a>, and the like. Outermost root element is located by <code>MapEntry</code> <code>[:path []]</code>.</p>
<p>Note: The 4-arity version is a recursion target and not intended to be called.</p>
<p>Examples:</p>
<pre><code class="language-clojure">(all-paths [42 :foo \c]) ;; =&gt; [{:path [], :value [42 :foo \c]} {:path [0], :value 42} {:path [1], :value :foo} {:path [2], :value \c}]
(all-paths {:a 1 :b 2}) ;; =&gt; [{:path [], :value {:a 1, :b 2}} {:path [:a], :value 1} {:path [:b], :value 2}]
(all-paths (list 1 2)) ;; =&gt; [{:path [], :value (1 2)} {:path [0], :value 1} {:path [1], :value 2}]
(all-paths #{:red :blue}) ;; =&gt; [{:path [], :value #{:red :blue}} {:path [:red], :value :red} {:path [:blue], :value :blue}]

;; heterogeneous, nested collections
(all-paths [42 {:a 'foo}]) ;; =&gt; [{:path [], :value [42 {:a foo}]} {:path [0], :value 42} {:path [1], :value {:a foo}} {:path [1 :a], :value foo}]
(all-paths {:x #{99}}) ;; =&gt; [{:path [], :value {:x #{99}}} {:path [:x], :value #{99}} {:path [:x 99], :value 99}]
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L122">view source</a></div></div><div class="public anchor" id="var-clamp"><h3>clamp</h3><div class="usage"><code>(clamp c1 c2)</code></div><div class="doc"><div class="markdown"><p>Given two sequences <code>c1</code> and <code>c2</code>, if either <code>(isa? (type _) :speculoos/non-terminating)</code>, clamp its size at the count of the other, stuff its contents into a vector, and return both as <code>[new-c1 new-c2]</code>. If neither are <code>:speculoos/non-terminating</code>, return <code>[c1 c2]</code> unchanged. Supplying two non-terminating sequences throws.</p>
<p>Examples:</p>
<pre><code class="language-clojure">(clamp [:a :b :c :d :e] (range)) ;; =&gt; [[:a :b :c :d :e] [0 1 2 3 4]]
(clamp [] (repeat 42)) ;; ==&gt; [[] []]
(clamp (iterate dec 0) (list 'foo 'bar 'baz)) ;; =&gt; [[0 -1 -2] (foo bar baz)]

;; neither non-terminating; args pass through unchanged
(clamp [1 2 3] (list :a \z)) ;; [[1 2 3] (:a \z)]

;; sequence is only possibly non-terminating; actual argument `c2` is shorter
(clamp [1 2 3 4 5] (range 3)) ;; =&gt; [[1 2 3 4 5] [0 1 2]]
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L65">view source</a></div></div><div class="public anchor" id="var-only-invalid"><h3>only-invalid</h3><div class="usage"><code>(only-invalid validations)</code></div><div class="doc"><div class="markdown"><p>Returns only validation entries where <code>:value</code> does not satisfy <code>:predicate.</code> I.e., <code>:valid?</code> is <code>false</code> or <code>nil</code>.</p>
<p>Examples:</p>
<pre><code class="language-clojure">(only-invalid (validate-scalars [42 :foo 22/7] [int? keyword? symbol?]))
;; =&gt; ({:path [2], :datum 22/7, :predicate symbol?, :valid? false})

(only-invalid (validate-collections [42 (list :foo)] [list? [list?]]))
;; =&gt; ({:path [0], :value list?, :datum [42 (:foo)], :ordinal-parent-path [], :valid? false})
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L504">view source</a></div></div><div class="public anchor" id="var-only-valid"><h3>only-valid</h3><div class="usage"><code>(only-valid validations)</code></div><div class="doc"><div class="markdown"><p>Returns only validation entries where <code>:value</code> satisfies <code>:predicate</code>. I.e., <code>:valid?</code> is neither <code>false</code> nor <code>nil</code>.</p>
<p>Examples:</p>
<pre><code class="language-clojure">(only-valid (validate-scalars [42 :foo 22/7] [decimal? symbol? ratio?]))
;; =&gt; ({:path [2], :datum 22/7, :predicate ratio?, :valid? true})

(only-valid (validate-collections [42 (list :foo)] [list? [list?]]))
;; =&gt; ({:path [1 0], :value list?, :datum (:foo), :ordinal-parent-path [0], :valid? true})
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L487">view source</a></div></div><div class="public anchor" id="var-ordinal-get"><h3>ordinal-get</h3><h4 class="type">multimethod</h4><div class="usage"></div><div class="doc"><div class="markdown"><p><code>(ordinal-get coll i)</code></p>
<p>Performs the same task as <a href="speculoos.fn-in.html#var-get*">get*</a>, but when encountering a vector or list, considers only elements that are collections. The element is addressed by an <em>ordinal path</em>. Map elements are addressed by keys, as usual. (Keys may themselves be integers, or a composite value.) Set elements are addressed by their identities.</p>
<p>Examples:</p>
<pre><code class="language-clojure">(ordinal-get [11 [22] 33 [44] [55] 66 [77]] 0) ;; =&gt; [22]
(ordinal-get [11 [22] 33 [44] [55] 66 [77]] 2) ;; =&gt; [55]
(ordinal-get [11 [22] 33 [44] [55] 66 [77]] 3) ;; =&gt; [77]
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L575">view source</a></div></div><div class="public anchor" id="var-ordinal-get-in"><h3>ordinal-get-in</h3><div class="usage"><code>(ordinal-get-in c keys)</code></div><div class="doc"><div class="markdown"><p>A <a href="speculoos.fn-in.html#var-get-in*">get-in*</a> that, when encountering a vector or list, considers only elements that are collections. Map and set addresses work as usual.</p>
<p>Examples:</p>
<pre><code class="language-clojure">(ordinal-get-in [42 [:foo] 99 [:bar] 33 [:baz]] [2]) ;; =&gt; [:baz]
(ordinal-get-in {:a [[42] [77] ['hello]]} [:a 2]) ;; =&gt; [hello]
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L601">view source</a></div></div><div class="public anchor" id="var-valid-collections.3F"><h3>valid-collections?</h3><div class="usage"><code>(valid-collections? data spec)</code></div><div class="doc"><div class="markdown"><p>Returns <code>true</code> if <a href="speculoos.core.html#var-validate-collections">validate-collections</a> on <code>data</code> and collection specification <code>spec</code> all validate truthy.</p>
<p>Examples:</p>
<pre><code class="language-clojure">(valid-collections? [42 [:foo]] [list? [vector?]]) ;; =&gt; false
(valid-collections? {:a 42 :b {:c 'foo}} {:outer-coll map? :b {:inner-coll map?}}) ;; =&gt; true
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L770">view source</a></div></div><div class="public anchor" id="var-valid-macro.3F"><h3>valid-macro?</h3><div class="usage"><code>(valid-macro? macro-args spec)</code></div><div class="doc"><div class="markdown"><p>Returns <code>true</code> if macroexpansion fully satisfies scalar specification <code>spec</code>. Supply <code>macro</code> and <code>args</code> as if to <code>macroexpand-1</code> itself, i.e., <code>`(macro-name arg1 arg 2...)</code>.</p>
<p>Note 1: Many entities that appear to be a function in a macro expansion are in fact symbols.</p>
<p>Note 2: Macro expansion works subtly different between the CIDER nREPL and from the CLI, e.g. <code>$ lein test</code>. Use syntax quote ` as a workaround.</p>
<p>Example:</p>
<pre><code class="language-clojure">(defmacro example-macro [f &amp; args] `(~f ~@args))

(macroexpand-1 `(example-macro + 1 2 3)) ;; =&gt; (clojure.core/+ 1 2 3)

(def example-macro-spec (list symbol? number? number? number?))

(valid-macro? `(example-macro + 1 2 3) example-macro-spec) ;; =&gt; true
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L894">view source</a></div></div><div class="public anchor" id="var-valid-scalars.3F"><h3>valid-scalars?</h3><div class="usage"><code>(valid-scalars? data spec)</code></div><div class="doc"><div class="markdown"><p><code>true</code> if every element in <code>data</code> satisfies corresponding predicate in scalar specification <code>spec</code>, <code>false</code> otherwise. Note, if a corresponding specification predicate does not exist, that element of data will not be checked. Use <a href="speculoos.utility.html#var-scalars-without-predicates">scalars-without-predicates</a> to locate elements of data that lack corresponding predicates in <code>spec</code>.</p>
<p>Examples:</p>
<pre><code class="language-clojure">(valid-scalars? [42 :foo 22/7] [int? keyword? ratio?]) ;; =&gt; true
(valid-scalars? {:a 42 :b 'foo} {:a string? :b symbol?}) ;; =&gt; false

;; unmatched datums
(valid-scalars? [42 :foo 22/7] [int?]) ;; =&gt; true

;; unmatched predicates
(valid-scalars? {:a 42} {:b symbol?}) ;; =&gt; true
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L521">view source</a></div></div><div class="public anchor" id="var-valid.3F"><h3>valid?</h3><div class="usage"><code>(valid? data scalar-spec collection-spec)</code></div><div class="doc"><div class="markdown"><p>Returns <code>true</code> if <code>data</code> fully satisfies both <code>scalar-spec</code> and <code>collection-spec</code>. See <a href="speculoos.core.html#var-valid-scalars.3F">valid-scalars?</a> and <a href="speculoos.core.html#var-valid-collections.3F">valid-collections?</a>.</p>
<p>Examples:</p>
<pre><code class="language-clojure">(valid? [42 [:foo [22/7]]] [int? [keyword? [ratio?]]] [vector? [vector? [vector?]]])
;; =&gt; true

(valid? {:a 42 :b {:c ['foo true]}} {:a int? :b {:c [keyword? boolean?]}} {:root-coll map? :b {:c [vector?]}})
;; =&gt; false
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L807">view source</a></div></div><div class="public anchor" id="var-validate"><h3>validate</h3><div class="usage"><code>(validate data scalar-spec collection-spec)</code></div><div class="doc"><div class="markdown"><p>Run respective validations of both <code>scalar-spec</code> and <code>collection-spec</code> on <code>data</code>. Returns a merged vector of results. See <a href="speculoos.core.html#var-validate-scalars">validate-scalars</a> and <a href="speculoos.core.html#var-validate-collections">validate-collections</a>.</p>
<p>Examples:</p>
<pre><code class="language-clojure">(validate [42] [int?] [vector?])
;; =&gt; ({:path [0], :datum 42, :predicate int?, :valid? true}
;;     {:path [0], :value vector?, :datum [42], :ordinal-parent-path [], :valid? true})

(validate {:a 11} {:a string?} {:coll-type? map?})
;; =&gt; ({:path [:a], :datum 11, :predicate string?, :valid? false}
;;     {:path [:coll-type?], :value map?, :datum {:a 11}, :ordinal-parent-path [], :valid? true})
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L786">view source</a></div></div><div class="public anchor" id="var-validate-collections"><h3>validate-collections</h3><div class="usage"><code>(validate-collections data spec)</code></div><div class="doc"><div class="markdown"><p>Given <code>data</code>, an arbitrarily-nested, heterogeneous data structure, apply all predicates within <code>spec</code>, a collection specification. Only elements of <code>spec</code> that satisfy <code>fn?</code> are tested.</p>
<p>Note: (Possibly) non-terminating sequences are clamped at the length of the corresponding element in the other collection. Therefore, if there are fewer <code>spec</code> predicates than elements to be tested in <code>data</code>, you must pad the collection specification, e.g., <code>(constantly true)</code>, to force validation of those datums. (I donâ€™t like this policy, but I donâ€™t have a better heuristic by which to clamp a non-terminating sequence with in-band information.)</p>
<p>Examples:</p>
<pre><code class="language-clojure">(validate-collections [42 [99]] [vector? [vector?]])
;; =&gt; ({:path [0], :value vector?, :datum [42 [99]], :ordinal-parent-path [], :valid? true}
;;     {:path [1 0], :value vector?, :datum [99], :ordinal-parent-path [0], :valid? true})

(validate-collections {:a 42 :b {:c 99}} {:root-coll map? :b {:child-coll? list?}})
;; =&gt; ({:path [:root-coll], :value map?, :datum {:a 42, :b {:c 99}}, :ordinal-parent-path [], :valid? true}
;;     {:path [:b :child-coll?], :value list?, :datum {:c 99}, :ordinal-parent-path [:b], :valid? false})
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L740">view source</a></div></div><div class="public anchor" id="var-validate-macro-with"><h3>validate-macro-with</h3><div class="usage"><code>(validate-macro-with macro-args spec)</code></div><div class="doc"><div class="markdown"><p>Returns results of validating the macroexpansion of a macro and arguments against scalar specification <code>spec</code>. Supply <code>macro-args</code> as if to <code>macroexpand-1</code> itself, i.e., <code>`(macro-name arg1 arg 2...)</code>.</p>
<p>Note: Many entities that appear to be a function in a macro expansion are, in fact, symbols.</p>
<p>Example:</p>
<pre><code class="language-clojure">(defmacro example-macro [f &amp; args] `(~f ~@args))

(macroexpand-1 `(example-macro + 1 2 3)) ;; =&gt; (clojure.core/+ 1 2 3)

(def example-macro-spec (list symbol? number? number? number?))

(validate-macro-with `(example-macro + 1 2 3) example-macro-spec)
;; =&gt; [{:path [0], :datum clojure.core/+, :predicate symbol?, :valid? true}
;;     {:path [1], :datum 1, :predicate number?, :valid? true}
;;     {:path [2], :datum 2, :predicate number?, :valid? true}
;;     {:path [3], :datum 3, :predicate number?, :valid? true}]
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L867">view source</a></div></div><div class="public anchor" id="var-validate-scalars"><h3>validate-scalars</h3><div class="usage"><code>(validate-scalars data spec)</code></div><div class="doc"><div class="markdown"><p>For every scalar datum in <code>data</code>, test corresponding predicate in specification <code>spec</code>. Tests predicates on scalars, non-collection leaf nodes of a collection. <code>data</code> is a heterogeneous, arbitrarily-nested data structure of arbitrary values. <code>spec</code> is a corresponding â€˜shapeâ€™, i.e., all nested structures are of the same type and length, containing predicates to test against. <code>validate-scalars</code> recursively descends into all nested data structures and produces a flattened sequence of <code>{:path _ :value _ :predicate _}</code> hash-maps for each datum-predicate pair.</p>
<p><code>:path</code> is a vector suitable for sending to <a href="speculoos.fn-in.html#var-get-in*">get-in*</a>, <a href="speculoos.fn-in.html#var-assoc-in*">assoc-in*</a>, <a href="speculoos.fn-in.html#var-update-in*">update-in*</a>, and friends. <code>:value</code> is the entity in data. <code>:predicate</code> is a 1-arity function-like thing that returns truthy/falsey; i.e, regexes and sets can serve as a predicate. Only validates nodes that are in both <code>data</code> and <code>spec</code>.</p>
<p>The ordering of results is an implementation detail and not specified.</p>
<p>Examples:</p>
<pre><code class="language-clojure">(validate-scalars [42 :foo \c] [int? keyword? char?])
;; =&gt; [{:path [0], :datum 42, :predicate int?, :valid? true}
;;     {:path [1], :datum :foo, :predicate keyword?, :valid? true}
;;     {:path [2], :datum \c, :predicate char?, :valid? true}]

(validate-scalars {:a 42 :b 'foo} {:a int? :b symbol?})
;; =&gt; [{:path [:a], :datum 42, :predicate int?, :valid? true}
;;     {:path [:b], :datum foo, :predicate symbol?, :valid? true}]

;; nested data and specification
(validate-scalars [42 {:z 'baz}] [ratio? {:z keyword?}])
;; =&gt; [{:path [0], :datum 42, :predicate ratio?, :valid? false}
;;     {:path [1 :z], :datum baz, :predicate keyword?], :valid? false}]

;; data and specification not same length
(validate-scalars [42 :foo 22/7] [int?])
;; =&gt; [{:path [0], :datum 42, :predicate int?, :valid? true}]

(validate-scalars [42] [decimal? keyword? char?])
;; =&gt; [{:path [0], :datum 42, :predicate decimal?, :valid? false}]

;; regular expression predicate
(validate-scalars ["foo"] [#"f.."])
;; =&gt; [{:path [0], :datum "foo", :predicate #"f..", :valid? "foo"}]

;; set as a membership predicate
(validate-scalars [:green] [#{:red :green :blue}])
;; =&gt; [{:path [0], :datum :green, :predicate #{:green :red :blue}, :valid? :green}]
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L359">view source</a></div></div><div class="public anchor" id="var-validate-with-path-spec"><h3>validate-with-path-spec</h3><div class="usage"><code>(validate-with-path-spec data spec)</code></div><div class="doc"><div class="markdown"><p>Given a heterogeneous, arbitrarily-nested structure <code>data</code>, validate against path specification vector <code>spec</code>. Each entry in <code>spec</code> is a map with keys <code>:paths</code> and <code>:predicate</code>. <code>:paths</code> is a vector to <a href="speculoos.fn-in.html#var-get-in*">get-in*</a> paths to elements (scalar and/or collections) in <code>data</code>, supplied in-order to the function associated with <code>:predicate</code>, whose arity matches the number of paths in <code>:paths</code>. The function should return truthy or falsey values (strict true/false is recommended, but not required).</p>
<p>Examples:</p>
<pre><code class="language-clojure">;; relating one scalar to another (predicate is 2-arity)
(validate-with-path-spec [11 :foo 22] [{:paths [[2] [0]] :predicate #(= %2 (/ %1 2))}])
;; =&gt; ({:args (22 11), :valid? true, :paths [[2] [0]], :predicate fn--47025]})

;; relating one scalar to another, different depths of the sequence (predicate is 3-arity)
(validate-with-path-spec {:a 42 :b [42 {:c 42}]} [{:paths [[:b 0] [:a] [:b 1 :c]] :predicate #(= %1 %2 %3)}])
;; =&gt; ({:args (42 42 42), :valid? true, :paths [[:b 0] [:a] [:b 1 :c]], :predicate fn--47045]})

;; specification containing two validations
(validate-with-path-spec [:foo [42 22/7]] [{:paths [[1 0]] :predicate int?} {:paths [[1]] :predicate vector?}])
;; =&gt; ({:args (42), :valid? true, :paths [[1 0]], :predicate int?]}
;;     {:args ([42 22/7]), :valid? true, :paths [[1]], :predicate vector?]})
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/blosavio/speculoos/blob/main/src/speculoos/core.clj#L923">view source</a></div></div></div></body></html>