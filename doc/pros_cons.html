<!DOCTYPE html>
<html lang="en"><head><link href="tufte.css" rel="stylesheet" type="text/css"><link href="speculoos.css" rel="stylesheet" type="text/css"><title>Speculoos — Pros, Cons, & Alts</title><meta charset="utf-8" compile-date="2024-07-24 09:05:18" content="width=device-width, initial-scale=1" name="viewport"><body><nav id="nav-bar"><ul><li><a href="home.html">Home</a></li><li><a href="ideas.html">Ideas</a></li><li><a href="documentation.html">Documentation</a></li><li><a href="recipes.html">Recipes</a></li><li><a href="diff.html"><code>diff</code></a></li><li>Pros, Cons, &amp; Alts</li><li class="small-caps"><a href="index.html">api</a></li><li><a href="source.html">Source</a></li><li><a href="contact.html">Contact</a></li></ul></nav><article><h1>Speculoos Pros, Cons, & Alternatives</h1><section><h2>Pros</h2><ul><li>I think writing specifications with Clojure data literals is nice.</li><li>I find it conceptually simpler to specify collections independently from scalars.</li><li>The way Speculoos decomposes a heterogeneous, arbitrarily-nested data structure makes it straightforward to write utility functions, especially with the starred functions. Many of the functions in <code>speculoos.utility</code> are just a few lines. <code>speculoos.core/all-paths</code> exposes this deconstructed version of both the data and the specification, so that you can write your own utilities.</li></ul></section><section><h2>Cons</h2><ul><li><p><code>clojure.spec.alpha</code> is designed and written by a <a href="https://www.infoq.com/presentations/Value-Identity-State-Rich-Hickey/">genuine</a> <a href="https://github.com/tallesl/Rich-Hickey-fanclub">wizard</a>. I wouldn't be surprised if Rich already had these ideas and then discarded them.</p></li><li><p>On the other hand, Speculoos was haphazardly written by a <a href="contact.html">person</a> who'll put milk in the pantry. My ideas may be absurd.</p></li><li><p>There seem to be a decent number of Clojure <a href="pros_cons.html#alts">projects</a> that do roughly the same validation tasks with a similar look and feel. Many appear to be mature and/or stable. Why not use one of those? For that matter, why not simply use <code>clojure.spec.alpha</code>?</p></li><li><p>Cardinal sin of software development: I have written relatively few Clojure specs, and yet I wrote a data specification lib. Speculoos <em>skates to where the puck used to be</em>. Roughly speaking, Speculoos aims to replicate an acceptable subset of <code>spec.alpha</code> functionality. More specifically, what is contained in the <a href="https://clojure.org/guides/spec"><em>Spec Guide</em></a>. If there happen to be any use cases or features not covered there and not apparent from the <span class="small-caps">api</span>, Speculoos won't have them.<label class="margin-toggle sidenote-number" for="exclude"></label><input class="margin-toggle" id="exclude" type="checkbox"><span class="sidenote">Other than features I have explicitly decided not to include, like returning conformed values.</span></input> Likewise, Speculoos copies any not-so-great ideas.</p></li><li><p><strong>Speculoos is in a very <em>pre-alpha</em>.</strong> I paid no particular attention to performance, and have done exactly zero performance benchmarking.<label class="margin-toggle sidenote-number" for="laborious"></label><input class="margin-toggle" id="laborious" type="checkbox"><span class="sidenote">In fact, some of Speculoos&apos; bottom-level functions laboriously and inefficiently step through collections. I deliberately wrote this way for clarity to my inexperienced brain, with complete disregard for good performance.</span></input> Also, function instrumentation is ever-so-barely <em>not broken</em> because I don't know how to wrangle vars.</p><p>Implementation issues aside, some decisions are still up in the air. For one example, if a specification+data is invalid, should it return a fully-qualified invalid key such as <code>:speculoos/invalid</code>, or should it pass the data along and return the invalid announcement out-of-band?</p></li><li><p>The un-feature that might sink the entire Speculoos project: Because Speculoos predicates are regular functions, there is no completely general way to automatically deconstruct them to create a generator.</p><p><code>spec.alpha</code> dedicates much effort to automatically producing generators to test and exercise functions. I would not be surprised to learn that <code>spec.alpha</code>'s design involves <code>spec/and</code> and <code>spec/or</code> instead of bare predicates precisely to enable this capability.</p><p>On the other hand, Speculoos can only generate test values when the predicate is transparent, like <code>int?</code>. The moment a predicate gets wrapped like this <code>#(int? %)</code>, you must either arrange the predicate definition in a proscribed pattern, or you must manually supply the generator. And either of those options requires access to the source code.</p></li><li><p>Speculoos specifications become unwieldy when an element could be either a scalar or a collection. In that scenario, strictly separating collection validation from scalar specification works against you. For example, suppose you wanted to specify a <code>defn</code> S-expression. Sometimes you'll have a docstring…</p><code>(defn foo "docstring" [arg1 arg2 …] (body))</code><p>…and sometimes you won't.</p><code>(defn baz [arg1 arg2 …] (body))</code><p>Depending on the presence of a docstring, the argument vector could be in the third or fourth position. A Speculoos collection specification is general enough to describe that pattern, but it's not quite as clean as it would be with a <code>spec.alpha</code> regex sequence spec.<label class="margin-toggle sidenote-number" for="other-hand"></label><input class="margin-toggle" id="other-hand" type="checkbox"><span class="sidenote">On the other hand, a semi-random sampling of a few dozen <code>clojure.core</code> functions turns up very few argument lists which would require that particular kind of optionality. Perhaps <code>defn</code> is an outlier.</span></input></p></li></ul></section><section id="alts"><h2>Alternatives</h2><ul><li>Staples SparX <a href="https://github.com/staples-sparx/clj-schema">clj-schema</a><p>Schemas for Clojure data structures and values. Delineates operations on maps, seqs, and sets. Contributors: Alex Baranosky, Laurent Petit, Punit Rathore</p></li><li>Steve Miner's <a href="https://github.com/miner/herbert">Herbert</a><p><em>A schema language for Clojure data</em> for documenting and validating. Schemas themselves are <code>edn</code> values. Yay! The <em>ReadMe</em> announces that Herbert is obsolete with the introduction of <code>spec.alpha</code> in Clojure release 1.9</p></li><li>John Newman's <a href="https://github.com/johnmn3/injest">injest</a><p>Path thread macros for navigating into and transforming data. An alternative to Speculoos' <code>fn-in*</code> facilities.</p></li><li>Metosin <a href="https://github.com/metosin/malli">Malli</a><p><em>Data-driven schemas</em> incorporating the best parts of existing libs, mixed with their own tools. Lots of features, multiple choices for syntax. Active development as of 2024 May.</p></li><li>Plumatic <a href="https://github.com/plumatic/schema">Schema</a><p>Widely-recommended, widely-used, mature, and pretty to my eyes. If Speculoos has any appeal to you, check it out.</p></li><li>Christophe Grand's <a href="https://github.com/cgrand/seqexp">seqexp</a><p><em>Regular expressions for sequences (and other sequables)!</em> A nice compact library, with an implementation that focuses on performance.<label class="margin-toggle sidenote-number" for="note-to-self"></label><input class="margin-toggle" id="note-to-self" type="checkbox"><span class="sidenote">Note to self: Study the implementation.</span></input></p></li><li>Jonathan Claggett's <a href="https://github.com/jclaggett/seqex">seqex</a><p><em>Sequence Expressions, similar to regular expressions but able to describe arbitrary sequences of values (not just characters).</em> Tightly-focused, clean and memorable interface. Clever re-application of regular expressions.</p></li><li>Clojure's <a href="https://github.com/clojure/spec.alpha"><code>spec.alpha</code></a><p>Developed by the Clojure team, so there's a ton of skill and experience, plus probably the most battle-hardened alternative. Looks to have been in <em>alpha</em> for seven years, so maybe the team is still mulling how to do Clojure specifications. Maybe there's a sliver of real estate for Speculoos' ideas to occupy.</p></li><li>Clojure's <a href="https://github.com/clojure/spec-alpha2"><code>spec-alpha2</code></a><p>The <em>ReadMe</em><label class="margin-toggle sidenote-number" for="alpha-alpha"></label><input class="margin-toggle" id="alpha-alpha" type="checkbox"><span class="sidenote">This page refers to the library as <code>alpha.spec</code> but the GitHub project name is <code>spec-alpha2</code>.</span></input> describes the project as <em>an evolution from spec.alpha as well as work towards several new features</em> and the <a href="https://github.com/clojure/spec-alpha2/wiki/Differences-from-spec.alpha">differences</a> page calls it <em>a work in progress</em>.<label class="margin-toggle sidenote-number" for="spec-alpha-2-status"></label><input class="margin-toggle" id="spec-alpha-2-status" type="checkbox"><span class="sidenote">As of 2020 June 20, <a href="https://ask.clojure.org/index.php/9397/clarify-usage-on-the-spec-alpha2-github-page?show=9398#a9398">Alex Miller states</a> <em>We do not believe this lib is ready to use yet (it is incomplete and has a number of known bugs).</em></span></input> Consumes <a href="https://github.com/clojure/spec-alpha2/wiki/Schema-and-select">literal schemas</a>, so it seems like we're grasping for the same elusive ideas. There is some discussion on strictly separating symbolic specs and spec objects, but as far as I can tell, this is not separating scalar specification and collection specification the way Speculoos does.</p></li><li>Jamie Brandon's <a href="https://github.com/jamii/strucjure">Strucjure</a><p>A <a href="https://www.scattered-thoughts.net/writing/strucjure-motivation/">well-reasoned</a>, elegant design. Repository was archived on 2019 March 16, but I still often click over to this project.</p></li><li>Brian Marick's <a href="https://github.com/marick/structural-typing">structural-typing</a><p>Focused on <a href="https://en.wikipedia.org/wiki/Structural_type_system">structural typing</a> in Clojure. Not precisely the same goals, but the <em>flavor</em> of this project is similar to Speculoos.</p></li><li>Peter Taoussanis' <a href="https://github.com/taoensso/truss">Truss</a><p><em>A tiny library that provides fast and flexible runtime assertions with terrific error messages.</em> Its use of pure predicates works the way my brain works.</p></li></ul></section></article><p id="page-footer">Copyright © 2024 Brad Losavio.<br>Compiled 2024 July 24.<span id="uuid"><br>5c606f2e-4b44-4ecb-b054-3358306cc2c5</span></p></body></head></html>