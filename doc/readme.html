<!DOCTYPE html>
<html lang="en"><head><link href="speculoos.css" rel="stylesheet" type="text/css"><title>Speculoos — An experimental Clojure lib for data specification</title><meta charset="utf-8" compile-date="2024-09-21 15:49:46" content="width=device-width, initial-scale=1" name="viewport"><body><a href="https://clojars.org/com.sagevisuals/speculoos"><img src="https://img.shields.io/clojars/v/com.sagevisuals/speculoos.svg"></a><br><a href="#setup">Setup</a><br><a href="https://blosavio.github.io/speculoos/index.html">API</a><br><a href="#intro">Introduction</a><br><a href="#mottos">Mottos</a><br><a href="#mechanics">Mechanics</a><br><a href="#scalar-validation">Validating Scalars</a><br><a href="#collection-validation">Validating Collections</a><br><a href="#valid-thorough">Validation Summaries and Thorough Validations</a><br><a href="#function-validation">Validating Functions</a><br><a href="#exercising">Generating Random Samples and Exercising</a><br><a href="#utilities">Utilities</a><br><a href="#predicates">Predicates</a><br><a href="#non-terminating-sequences">Non-terminating Sequences</a><br><a href="#sets">Sets</a><br><a href="https://blosavio.github.io/speculoos/diff.html">Comparison to spec.alpha</a><br><a href="https://blosavio.github.io/speculoos/perhaps_so.html">Perhaps So</a><br><a href="https://github.com/blosavio/speculoos/tree/main/doc/recipes.clj">Recipes</a><br><a href="#troubleshooting">Troubleshooting</a><br><a href="#alternatives">Alternatives</a><br><a href="#glossary">Glossary</a><br><a href="https://github.com/blosavio">Contact</a><br><h1>Speculoos</h1><em>An experiment with Clojure specification literals</em><br><section id="setup"><h2>Setup</h2><h3>Leiningen/Boot</h3><pre><code>[com.sagevisuals/speculoos "2"]</code></pre><h3>Clojure CLI/deps.edn</h3><pre><code>com.sagevisuals/speculoos {:mvn/version "2"}</code></pre><h3>Require</h3><pre><code>(require '[speculoos.core :refer [valid-scalars? valid-collections?]])</code></pre></section><section id="intro"><h2>Introduction</h2><p>Imagine you'd like to know if <em>My Clojure vector contains an integer, then a string, and finally a ratio</em>. One example of that data vector might look like this.</p><pre><code>[42 "abc" 22/7]</code></pre><p>It would be nice if we could write a specification that is shaped like that data.</p><pre><code>[int? string? ratio?]</code></pre><p>Speculoos can validate our data vector with that specification vector.</p><pre><code>(valid-scalars? [42 "abc" 22/7]
                [int? string? ratio?])
;; => true</code></pre><p>Now imagine we'd like ensure we have <em>A Clojure hash-map with an integer at key <code>:x</code> and a ratio at key <code>:y</code></em>. Something like this.</p><pre><code>{:x 42 :y 22/7}</code></pre><p>We could write a specification map that's shaped like that data map.</p><pre><code>{:x int? :y ratio?}</code></pre><p>Speculoos can validate our data map with that specification map.</p><pre><code>(valid-scalars? {:x 42, :y 22/7}
                {:x int?, :y ratio?})
;; => true</code></pre><p>Notice how in both cases, the specifications mimic the shape of the data. The vector's specification is itself a vector. The map's specification is itself a map.</p><p>Speculoos can validate any heterogeneous, arbitrarily-nested data collection using specifications composed of plain Clojure collections and functions. In short, Speculoos is an experimental library that aims to perform the same tasks as <a href="https://clojure.org/about/spec"><code>clojure.spec.alpha</code></a> with an intuitive interface that employs flexible and powerful specification literals.</p></section><section id="mottos"><h2>★ Mottos</h2><p>When using Speculoos, remember these three Mottos:<ol><li>Validate scalars separately from validating collections.</li><li>Shape the specification to mimic the data.</li><li>Ignore un-paired predicates and un-paired datums.</li></ol></p><p>Speculoos provides functions for validating scalars contained within a heterogeneous, arbitrarily-nested data structure, and another, distinct group of functions for validating properties of those nested collections. Validating scalars separately from validating collections carries several advantages. First, separate scalar and collection specifications are simpler, so we don't have to learn an new domain-specific language. Speculoos can consume specifications composed of regular Clojure data structures. Inspect and manipulate your specification with any Clojure collection-handling functions you prefer. Second, specifying scalars separately from specifying collections offers mental clarity about what's going on. Your predicates will only ever apply to a scalar, or to a collection, never both. Third, you only need to specify as much, or as little, as necessary. If you only want to validate a few scalars, you won't be forced to specify anything concerning a collection.</p><p>Speculoos aims to make composing specifications straightforward, and inspecting them transparent. A Speculoos specification is merely an arrangement of nested vectors, lists, maps, sequences, and sets that contain predicates. Those predicates are arranged in a pattern that instruct the validation functions where to apply the predicates. The specification for a vector is a vector. The specification for a map, is itself a map. There's a nearly one-to-one correspondence between the shape of the data and the shape of the specification. Speculoos specifications aim to be intuitive to peek at by eye, but also amenable to alteration. You can use your favorite Clojure data wrangling functions to tighten, relax, or remove portions of a Speculoos specification.</p><p>Speculoos provides flexibility, power, optionality, and re-usability of specifications by ignoring datums that do not have a corresponding predicate in the specification and ignoring predicates that do not have a corresponding datum in the data. Maybe at your job in an assembly line, you only care about some slice of a large chunk of data. Supplying predicates for only a subset of datums allows you to only validate those specified datums while being agnostic towards the other datums. Going in the other direction, maybe somebody shared a giant specification that describes data about a person, their postal address, their contact info, etc. Because a Speculoos specification is just a data structure with regular predicates, you can, on-the-fly, pull out the portion relevant to postal addresses and apply that to your instances of address data. Speculoos lets you specify exactly what elements you'd like to validate. No more, no less.</p></section><section id="mechanics"><h2>Mechanics</h2><p>Knowing a little bit about how Speculoos does its job will greatly help you understand how to use it. First, we need to know on how to address elements contained within a heterogeneous, arbitrarily-nested data structure. Speculoos follows the conventions set by <code>clojure.core/get-in</code>, and extends those conventions where necessary.</p><p>Vectors are addressed by zero-indexed integers.</p><pre><code>           [100 101 102 103]</code><br><code>indexes --> 0   1   2   3</code></pre><p>Same for lists…</p><pre><code>          '(97 98 99 100)</code><br><code>indexes --> 0  1  2  3</code></pre><p>…and same for other sequences, like <code>range</code>.</p><pre><code>(range 29 33) ;; => (29 30 31 32)</code><br><code>indexes -----------> 0  1  2  3</code></pre><p>Maps are addressed by their keys, which are often keywords, like this.</p><pre><code>        {:a 1 :foo "bar" :hello 'world}</code><br><code>keys --> :a   :foo       :hello</code></pre><p>But maps may be keyed by <em>any</em> value, including integers…</p><pre><code>        {0 "zero" 1 "one" 99 "ninety-nine"}</code><br><code>keys --> 0        1       99</code></pre><p>…or some other scalars…</p><pre><code>        {"a" :value-at-str-key-a 'b :value-at-sym-key-b \c :value-at-char-key-c}</code><br><code>keys --> "a"                     'b                     \c</code></pre><p>…even composite values.</p><pre><code>        {[0] :val-at-vec-0 [1 2 3] :val-at-vec-1-2-3 {} :val-at-empty-map}</code><br><code>keys --> [0]               [1 2 3]                   {}</code></pre><p>Set elements are addressed by their identities, so they are located at themselves.</p><pre><code>             #{42 :foo true 22/7}</code><br><code>identities --> 42 :foo true 22/7</code></pre><p>A <em>path</em> is a sequence of indexes, keys, or identities that allow us refer to a single element buried within a nested data structure. For each level of nesting, we add an element to the path sequence. <code>clojure.core/get-in</code> illustrates how this works.</p><pre><code>(get-in [100 101 102 103] [2]) ;; => 102</code></pre><p>For a vector containing only integers, each element is addressed by a path of length one. To locate integer <code>102</code>, the path is <code>[2]</code>. If we consider a vector nested within a vector…</p><pre><code>(get-in [100 101 [102 103]] [2]) ;; => [102 103]</code></pre><p>…that same path <code>[2]</code> now locates the nested vector. To navigate to an integer contained within the nested vector…</p><pre><code>(get-in [100 101 [102 103]] [2 0]) ;; => 102</code></pre><p>…requires a path of length two: <code>[2 0]</code> where the <code>2</code> addresses the nested vector <code>[102 103]</code> and the <code>0</code> addresses the <code>102</code> within the nested vector. If we have an integer contained within a vector, contained within a vector, contained within a vector, we'd use a path of length three to get that integer.</p><pre><code>(get-in [100 [101 [102]]] [1]) ;; => [101 [102]]</code><br><code>(get-in [100 [101 [102]]] [1 1]) ;; => [102]</code><br><code>(get-in [100 [101 [102]]] [1 1 0]) ;; => 102</code></pre><p>The <code>102</code> is buried three levels deep, so we use a path with that many entries.</p><p>This system works similarly for maps. Elements contained in un-nested collections are located with a path of length one.</p><pre><code>(get-in {:x 100, :y 101, :z 102} [:z]) ;; => 102</code></pre><p>In this example, <code>102</code> is located with a path composed of a single key, keyword <code>:z</code>. If we now consider a map nested within another map…</p><pre><code>(get-in {:x 100, :y 101, :z {:w 102}} [:z :w]) ;; => 102</code></pre><p>…we need a path with two elements: key <code>:z</code> navigates us to the nested <code>{:w 102}</code> map, and then key <code>:w</code> navigates us to the <code>102</code> within that nested map.</p><p>There's no restriction on what may be nested in what, so we can nest a map within a vector…</p><pre><code>(get-in [100 101 {:x 102}] [2 :x]) ;; => 102</code></pre><p>…or nest a vector within a map…</p><pre><code>(get-in {:x 100, :y {:z [101 102]}} [:y :z 1]) ;; => 102</code></pre><p>…or, if we use a <a href="https://github.com/blosavio/fn-in">modified version</a> of <code>clojure.core/get-in</code>, nest a vector within a map within a list.</p><pre><code>(require '[fn-in.core :refer [get-in*]])</code><br><br><code>(get-in* '(100 101 {:x [102]}) [2 :x 0]) ;; => 102</code></pre><p><code>102</code> is contained in three levels of nesting, so its path is comprised of three pieces.</p><p>Speculoos provides a little machine to wrangle paths for us. When supplied with a heterogeneous, arbitrarily-nested data structure, <code>speculoos.core/all-paths</code> returns a sequence of <code>{:path … :value …}</code> for every element, both scalars and collections.</p><pre><code>(require '[speculoos.core :refer [all-paths]])</code><br><br><code>(all-paths [100 101 102])
;; => [{:path [], :value [100 101 102]}
;;     {:path [0], :value 100}
;;     {:path [1], :value 101}
;;     {:path [2], :value 102}]</code></pre><p>Note: We receive paths for four items, three integers, plus a path to the outer container itself. The root collection always has a path <code>[]</code>. The integer elements each have a path of a single, zero-indexed integer that locates them within the parent vector. Here's how it works with a map.</p><pre><code>(all-paths {:x 100, :y 101, :z 102})
;; => [{:path [], :value {:x 100, :y 101, :z 102}}
;;     {:path [:x], :value 100}
;;     {:path [:y], :value 101}
;;     {:path [:z], :value 102}]</code></pre><p>Each of the three integers has a path with a key that locates them within the parent map, and the parent map has a path of <code>[]</code> because it's the root collection.</p><p>If we supply a nested data structure, the paths reflect that nesting.</p><pre><code>(all-paths [100 101 [102 103]])
;; => [{:path [], :value [100 101 [102 103]]}
;;     {:path [0], :value 100}
;;     {:path [1], :value 101}
;;     {:path [2], :value [102 103]}
;;     {:path [2 0], :value 102}
;;     {:path [2 1], :value 103}]</code></pre><p>Now, we have six elements to consider: each of the four integers have a path, and both of the collections have a path. The outer parent vector has path <code>[]</code> because it's the root, and the nested collection is located at path <code>[2]</code>, the third element of the root vector. Let's look at all the paths of nested maps.</p><pre><code>(all-paths {:x 100, :y 101, :z {:w 102}})
;; => [{:path [], :value {:x 100, :y 101, :z {:w 102}}}
;;     {:path [:x], :value 100}
;;     {:path [:y], :value 101}
;;     {:path [:z], :value {:w 102}}
;;     {:path [:z :w], :value 102}]</code></pre><p>Again, each of the three integers has a path, and both of the maps have a path, for a total of five paths.</p><p>There is nothing special about integers. <code>all-paths</code> will treat any element, scalar or collection, the same way. <em>Every element has a path.</em> We could replace those integers with functions, un-nested in a vector…</p><pre><code>(all-paths [int? string? ratio?])
;; => [{:path [], :value [int? string? ratio?]}
;;     {:path [0], :value int?}
;;     {:path [1], :value string?}
;;     {:path [2], :value ratio?}]</code></pre><p>…or nested in a map…</p><pre><code>(all-paths {:x int?, :y string?, :z {:w ratio?}})
;; => [{:path [],
;;      :value {:x int?,
;;              :y string?,
;;              :z {:w ratio?}}}
;;     {:path [:x], :value int?}
;;     {:path [:y], :value string?}
;;     {:path [:z], :value {:w ratio?}}
;;     {:path [:z :w], :value ratio?}]</code></pre><p>The important principle to remember is this: Every element, scalar and collection, of a heterogeneous, arbitrarily-nested data structure, can be assigned an unambiguous path, regardless of its container type.</p><p>If you ever find yourself with a nested list on your hands, <code>all-paths</code> has got you covered.</p><pre><code>(all-paths [42 (list 'foo 'bar 'baz)])
;; => [{:path [], :value [42 (foo bar baz)]}
;;     {:path [0], :value 42}
;;     {:path [1], :value (foo bar baz)}
;;     {:path [1 0], :value foo}
;;     {:path [1 1], :value bar}
;;     {:path [1 2], :value baz}]</code></pre><p>Likewise, sets are indispensable in some situations, so <code>all-paths</code> can handle it.</p><pre><code>(all-paths {:a 42, :b #{:chocolate :vanilla :strawberry}})
;; => [{:path [], :value {:a 42, :b #{:chocolate :strawberry :vanilla}}}
;;     {:path [:a], :value 42}
;;     {:path [:b], :value #{:chocolate :strawberry :vanilla}}
;;     {:path [:b :strawberry], :value :strawberry}
;;     {:path [:b :chocolate], :value :chocolate}
;;     {:path [:b :vanilla], :value :vanilla}]</code></pre><p>Admittedly, addressing elements in a set can be a little like herding cats, but it's still useful to have the capability. Wrangling sets merits its own <a href="#sets">dedicated section</a>.</p></section><section id="scalar-validation"><h2>Scalar Validation</h2><p>Let's return to the English-language specification we saw in the introduction: <em>A vector containing an integer, then a string, then a ratio</em>. Consider the paths of this vector…</p><pre><code>(all-paths [42 "abc" 22/7])
;; => [{:path [], :value [42 "abc" 22/7]}
;;     {:path [0], :value 42}
;;     {:path [1], :value "abc"}
;;     {:path [2], :value 22/7}]</code></pre><p>…and the paths of this vector…</p><pre><code>(all-paths [int? string? ratio?])
;; => [{:path [], :value [int? string? ratio?]}
;;     {:path [0], :value int?}
;;     {:path [1], :value string?}
;;     {:path [2], :value ratio?}]</code></pre><p>We see that elements of both share paths. If we keep only the paths to scalars, i.e., we discard the root collections at path <code>[]</code>, each has three elements remaining.<ul><li><code>42</code> and <code>int?</code> both at path <code>[0]</code>, in their respective vectors,</li><li><code>"abc"</code> and <code>string?</code> both at path <code>[1]</code>, and</li><li><code>22/7</code> and <code>ratio?</code> both at path <code>[2]</code>.</li></ul></p><p>Those pairs of scalars and predicates line up nicely, and we could evaluate each pair, in turn.</p><pre><code>(int? 42) ;; => true</code><br><code>(string? "abc") ;; => true</code><br><code>(ratio? 22/7) ;; => true</code></pre><p>All three scalars satisfy their respective predicates that they're paired with. Speculoos provides a function, <code>validate-scalars</code> that substantially does all that work for us. Given data and a specification that share the data's shape (Motto #2), <code>validate-scalars</code>:</p><ol><li>Runs <code>all-paths</code> on the data, then the specification.</li><li>Removes the collection elements from each, keeping only the scalars in each.</li><li>Removes the scalars in data that lack a predicate at the same path in the specification, and removes the predicates in the specification that lack datums at the same path in the data.</li><li>For each remaining pair of scalar+predicate, applies the predicate to the scalar.</li></ol><p>Let's see that in action. We invoke <code>validate-scalars</code> with the data vector as the first argument and the specification vector as the second argument.</p><pre><code>(require '[speculoos.core :refer [validate-scalars]])</code><br><br><code>(validate-scalars [42 "abc" 22/7]
                  [int? string? ratio?])
;; => [{:datum 42,
;;      :path [0],
;;      :predicate int?,
;;      :valid? true}
;;     {:datum "abc",
;;      :path [1],
;;      :predicate string?,
;;      :valid? true}
;;     {:datum 22/7,
;;      :path [2],
;;      :predicate ratio?,
;;      :valid? true}]</code></pre><p>Let's apply the Mottos to what we just did. Motto #1: At the moment, we're validating scalars, as the <em>-scalars</em> suffix of the function name reminds us. The validation yielded only predicates applied to scalars; scalar validation ignored the collections. Motto #2: The shape of our specification mimics the data. Because both are vectors, <code>validate-scalars</code> was able to properly apply each predicate its respective datum. Motto #3: Every predicate was paired with a datum and <em>vice versa</em>, so validation did not ignore anything.</p><p><code>validate-scalars</code> returns a sequence of all the scalars in data that share a path with a predicate in the specification. For each of those pairs, we receive a map containing the <code>:datum</code> scalar element of the data, the <code>:predicate</code> test function element of the specification, the <code>:path</code> addressing each in their respective structures, and the <code>valid?</code> result of applying the predicate function to the datum.</p><p>What if there's a length mis-match between the data and the specification? Motto #3 tells us that validation ignores un-paired datums. Let's look at the <code>all-paths</code> for that situation.</p><pre><code>;; data vector containing an integer, a symbol, and a character</code><br><code>(all-paths [42 "abc" 22/7])
;; => [{:path [], :value [42 "abc" 22/7]}
;;     {:path [0], :value 42}
;;     {:path [1], :value "abc"}
;;     {:path [2], :value 22/7}]</code><br><br><code>;; specification vector containing one predicate</code><br><code>(all-paths [int?]) ;; => [{:path [], :value [int?]}
 {:path [0], :value int?}]</code></pre><p>After discarding the root collections at path <code>[]</code> we find the only scalar+predicate pair at path <code>[0]</code>, and that's the only pair that <code>validate-scalars</code> looks at.</p><pre><code>(validate-scalars [42 "abc" 22/7]
                  [int?])
;; => [{:datum 42,
;;      :path [0],
;;      :predicate int?,
;;      :valid? true}]</code></pre><p>Only scalar <code>42</code> in the data vector has a corresponding predicate <code>int?</code> in the specification vector, so the validation report contains only one entry. The second and third scalars, <code>"abc"</code> and <code>22/7</code>, are ignored.</p><p>What about the other way around? More predicates in the specification than scalars in the data?</p><pre><code>;; data vector containing one scalar, an integer</code><br><code>(all-paths [42]) ;; => [{:path [], :value [42]} {:path [0], :value 42}]</code><br><br><code>;; specification vector containing three predicates</code><br><code>(all-paths [int? string? ratio?])
;; => [{:path [], :value [int? string? ratio?]}
;;     {:path [0], :value int?}
;;     {:path [1], :value string?}
;;     {:path [2], :value ratio?}]</code></pre><p>Motto #3 reminds us that validation ignores un-paired predicates. Only the predicate <code>int?</code> at path <code>[0]</code> in the specification vector shares its path with a scalar in the data vector, so that's the only scalar+predicate pair that <code>validate-scalars</code> processes.</p><pre><code>(validate-scalars [42]
                  [int? string? ratio?])
;; => [{:datum 42,
;;      :path [0],
;;      :predicate int?,
;;      :valid? true}]</code></pre><p><code>validate-scalars</code> ignores both <code>string?</code> and <code>ratio?</code> within the specification vector because the data vector does not contain scalars at their respective paths.</p><p>Validating scalars contained within a map proceeds similarly. Let's send this map, our data, to <code>all-paths</code>.</p><pre><code>(all-paths {:x 42, :y "abc", :z 22/7})
;; => [{:path [], :value {:x 42, :y "abc", :z 22/7}}
;;     {:path [:x], :value 42}
;;     {:path [:y], :value "abc"}
;;     {:path [:z], :value 22/7}]</code></pre><p>Four elements: the root collection (a map), and three scalars. Then we'll do the same for this map, our specification, which mimics the shape of the data (Motto #2), by also being a map with the same keys.</p><pre><code>(all-paths {:x int?, :y string?, :z ratio?})
;; => [{:path [], :value {:x int?, :y string?, :z ratio?}}
;;     {:path [:x], :value int?}
;;     {:path [:y], :value string?}
;;     {:path [:z], :value ratio?}]</code></pre><p>Again four elements: the root collection (a map), and three predicates. Note that each predicate shares a path with one of the scalars in the data map. Invoking <code>validate-scalars</code> with the data map followed by the specification map…</p><pre><code>(validate-scalars {:x 42, :y "abc", :z 22/7}
                  {:x int?, :y string?, :z ratio?})
;; => [{:datum 42,
;;      :path [:x],
;;      :predicate int?,
;;      :valid? true}
;;     {:datum "abc",
;;      :path [:y],
;;      :predicate string?,
;;      :valid? true}
;;     {:datum 22/7,
;;      :path [:z],
;;      :predicate ratio?,
;;      :valid? true}]</code></pre><p>…we can see that <ul><li><code>42</code> at path <code>[:x]</code> in the data satisfies <code>int?</code> at path <code>[:x]</code> in the specification, </li><li><code>"abc"</code> at path <code>[:y]</code> in the data satisfies <code>string?</code> at path <code>[:y]</code> in the specification, and</li><li><code>22/7</code> at path <code>[:z]</code> in the data satisfies <code>ratio?</code> at path <code>[:z]</code> in the specification. </li></ul>Because the specification mimics the shape of the data (i.e., the specification is a map with the same keys), <code>validate-scalars</code> is able to infer how to apply each predicate to the intended datum.</p><p><code>validate-scalars</code> can only operate with complete scalar+predicate pairs. It ignores un-paired scalars and un-paired predicates. Since maps are not sequential, we can illustrate both scenarios with one example.</p><pre><code>;; data with keys :x and :q</code><br><code>(all-paths {:x 42, :q "foo"})
;; => [{:path [], :value {:q "foo", :x 42}}
;;     {:path [:x], :value 42}
;;     {:path [:q], :value "foo"}]</code><br><br><code>;; specification with keys :x and :s</code><br><code>(all-paths {:x int?, :s decimal?})
;; => [{:path [], :value {:s decimal?, :x int?}}
;;     {:path [:x], :value int?}
;;     {:path [:s], :value decimal?}]</code></pre><p>Notice that the two maps contain only a single scalar/predicate that share a path, <code>[:x]</code>. The other two elements, scalar <code>"foo"</code> at path <code>[:q]</code> in the data map and predicate <code>decimal?</code> at path <code>[:s]</code> in the specification map, do not share a path with an element of the other. Those later two will be ignored.</p><pre><code>(validate-scalars {:x 42, :q "foo"}
                  {:x int?, :s decimal?})
;; => [{:datum 42,
;;      :path [:x],
;;      :predicate int?,
;;      :valid? true}]</code></pre><p><code>validate-scalars</code> found only a single complete scalar+predicate pair located at path <code>[:x]</code>, so it applied <code>int?</code> to <code>42</code>, which returns satisfied.</p><hr><p>I am curious to know whether the features to this point are sufficient for Clojure programmers to get 40% of their specification and validation work done. 50%? </p><p>Onward…</p><hr><p>Scalars contained in nested collections are treated accordingly: predicates from the specification are only applied to scalars in the data which share their path. Non-scalars are ignored. Here are the paths for a simple nested data vector with some scalars.</p><pre><code>(all-paths [42 ["abc" [22/7]]])
;; => [{:path [], :value [42 ["abc" [22/7]]]}
;;     {:path [0], :value 42}
;;     {:path [1], :value ["abc" [22/7]]}
;;     {:path [1 0], :value "abc"}
;;     {:path [1 1], :value [22/7]}
;;     {:path [1 1 0], :value 22/7}]</code></pre><p>Six total elements: three vectors, which <code>validate-scalars</code> will ignore, and three scalars. And here are the paths for a similarly-shaped nested specification.</p><pre><code>;;                         v --- char? predicate will be notable during validation in a moment</code><br><code>(all-paths [int? [string? [char?]]])
;; => [{:path [], :value [int? [string? [char?]]]}
;;     {:path [0], :value int?}
;;     {:path [1], :value [string? [char?]]}
;;     {:path [1 0], :value string?}
;;     {:path [1 1], :value [char?]}
;;     {:path [1 1 0], :value char?}]</code></pre><p>Again, six total elements: three vectors that will be ignored, plus three predicates. When we validate…</p><pre><code>(validate-scalars [42 ["abc" [22/7]]]
                  [int? [string? [char?]]])
;; => [{:datum 42,
;;      :path [0],
;;      :predicate int?,
;;      :valid? true}
;;     {:datum "abc",
;;      :path [1 0],
;;      :predicate string?,
;;      :valid? true}
;;     {:datum 22/7,
;;      :path [1 1 0],
;;      :predicate char?,
;;      :valid? false}]</code></pre><p>Three complete pairs of scalars and predicates.<ul><li><code>42</code> at path <code>[0]</code> in the data satisfies predicate <code>int?</code> at path <code>[0]</code> in the specification,</li><li><code>"abc"</code> at path <code>[1 0]</code> in the data satisfies predicate <code>string?</code> at path <code>[1 0]</code> in the specification,</li><li><code>22/7</code> at path <code>[1 1 0]</code> in the data <strong>does not satisfy</strong> predicate <code>char?</code> at path <code>[1 1 0]</code> in the specification.</li></ul><a href="#valid-thorough">Later</a>, we'll see that the lone, unsatisfied <code>char?</code> predicate would cause an entire <code>valid?</code> operation to return <code>false</code>.</p><p>When the data contains scalars that are not paired with predicates in the specification, they are not validated.</p><pre><code>(validate-scalars [42 ["abc" [22/7]]]
                  [int? [string?]])
;; => [{:datum 42,
;;      :path [0],
;;      :predicate int?,
;;      :valid? true}
;;     {:datum "abc",
;;      :path [1 0],
;;      :predicate string?,
;;      :valid? true}]</code></pre><p>Only the <code>42</code> and <code>"abc"</code> are paired with predicates, so <code>validate-scalars</code> only validated those two scalars. <code>22/7</code> is unpaired, and therefore ignored. Likewise…</p><pre><code>(validate-scalars [42]
                  [int? [string? [char?]]])
;; => [{:datum 42,
;;      :path [0],
;;      :predicate int?,
;;      :valid? true}]</code></pre><p>…<code>string?</code> and <code>char?</code> are not paired, and therefore ignored. When the data contains only one scalar, but the specification contains more predicates, <code>validate-scalars</code> only validates the complete scalar+predicate pairs.</p><p>Mis-matched, nested maps sing the same song. Here are the paths for all elements in a nested data map and a nested specification map.</p><pre><code>;; data</code><br><code>(all-paths {:x 42, :y {:z 22/7}})
;; => [{:path [], :value {:x 42, :y {:z 22/7}}}
;;     {:path [:x], :value 42}
;;     {:path [:y], :value {:z 22/7}}
;;     {:path [:y :z], :value 22/7}]</code><br><br><code>;; specification</code><br><code>(all-paths {:x int?, :y {:q string?}})
;; => [{:path [], :value {:x int?, :y {:q string?}}}
;;     {:path [:x], :value int?}
;;     {:path [:y], :value {:q string?}}
;;     {:path [:y :q], :value string?}]</code></pre><p>Notice that only the scalar <code>42</code> in the data and the predicate <code>int?</code>  in the specification share a path <code>[:x]</code>. <code>22/7</code> in the data and <code>string?</code> in the specification are un-paired.</p><pre><code>(validate-scalars {:x 42, :y {:z 22/7}}
                  {:x int?, :y {:q string?}})
;; => [{:datum 42,
;;      :path [:x],
;;      :predicate int?,
;;      :valid? true}]</code></pre><p><code>validate-scalars</code> dutifully applies the only scalar+predicate pair, and tells us that <code>42</code> is indeed an integer.</p><p>One final illustration: what happens if there are zero scalar+predicate pairs.</p><pred><code>(validate-scalars {:x 42} {:y int?}) ;; => []</code></pred><p>The only scalar, at the path <code>[:x]</code> in the data, does not share a path with the only predicate, at path <code>[:y]</code> in the specification. No validations were performed.</p><p>A Speculoos scalar specification says <em>This data element may or may not exist, but if it does, it must satisfy this predicate.</em> See <a href="#valid-thorough"> this later section</a> for functions that return high-level <code>true/false</code> validation summaries and for functions that ensure validation of <em>every</em> scalar element.</p></section><section id="collection-validation"><h2>Collection Validation</h2><p>You may have been uncomfortably shifting in your chair while reading through the examples above. Every example we've seen so far shows Speculoos validating individual scalars, such as integers, strings, booleans, etc.</p><pre><code>(valid-scalars? [99 "qwz" -88]
                [int? string? neg-int?])
;; => true</code></pre><p>However, we might need to specify some property of a collection itself, such as a vector's length, the presence of a key in a map, relationships <em>between</em> datums, etc. That is <em>collection validation</em>.</p><p>One way to visualize the difference is this.</p><pre><code> v----v-------v------v---- scalar validation targets these things</code><br><code>[42   \z {:x 'foo :y 22.7}]</code></pre><p>In contrast…</p><pre><code>v -------v---------------v-v---- collection validation targets these things</code><br><code>[42   \z {:x 'foo :y 22.7} ]</code></pre><p>One of Speculoos' main concepts is that scalars are specified and validated explicitly separately from collections. You perhaps noticed that the function name we have been using wasn't <code>validate</code> but instead <code>validate-scalars</code>. Speculoos provides a parallel group of functions to validate the properties of collections, independent of the scalar values they contain. Let's examine why and how they're separated.</p><p>Imagine we wanted to specify that our data vector was exactly three elements long. The paths of that data might look like this.</p><pre><code>(all-paths [42 "abc" 22/7])
;; => [{:path [], :value [42 "abc" 22/7]}
;;     {:path [0], :value 42}
;;     {:path [1], :value "abc"}
;;     {:path [2], :value 22/7}]</code></pre><p>Since we're now interested in specifying collections, we'll discard the <em>scalars</em> and focus only on the <em>collections</em>. In this case, there's only one collection, the vector at path <code>[]</code>, which signifies that it's the root collection.</p><p>We could try to write a specification with a bare predicate, like this.</p><pre><code>;; a predicate that returns true if the collection has three elements</code><br><code>(def len-3? #(= 3 (count %)))</code></pre><p>Then we could imagine some function might do this.</p><pre><code>;; this fn doesn't actually exist</code><br><code>(imaginary-validate-collection [42 'foo \z] len-3?) ;; => true</code></pre><p>Okay, that scenario maybe kinda could work. But what about this scenario: <em>A three-element vector nested within a two-element vector</em>. The paths would look like this.</p><pre><code>(all-paths [11 [22 33 44]])
;; => [{:path [], :value [11 [22 33 44]]}
;;     {:path [0], :value 11}
;;     {:path [1], :value [22 33 44]}
;;     {:path [1 0], :value 22}
;;     {:path [1 1], :value 33}
;;     {:path [1 2], :value 44}]</code></pre><p>Oh. Still ignoring the scalars, there are now two vectors which would be targets for our predicate, one at the root, and one at path <code>[1]</code>. We can't merely supply a pair of bare predicates to our <code>imaginary-validate-collection</code> function and have it magically know how to apply the predicates to the correct vector.</p><p>It quickly becomes apparent that we need to somehow arrange our collection predicates inside some kind of structure that will instruct the validation function where to apply the predicates. One of Speculoos' principles is <em>Make the specification shaped like the data</em>. Let me propose this structure.</p><pre><code>[len-3? [len-3?]]</code></pre><p>What do the paths of that thing look like?</p><pre><code>(all-paths [len-3? [len-3?]])
;; => [{:path [], :value [len-3? [len-3?]]}
;;     {:path [0], :value len-3?}
;;     {:path [1], :value [len-3?]}
;;     {:path [1 0], :value len-3?}]</code></pre><p>Hmm. In the previous <a href="#scalar-validation">section</a>, when we were validating scalars, we followed the principle that validation only proceeds when a predicate in the specification shares the exact path as the scalar in the data. However, we can now see an issue if we try to apply that principle here. The nested vector of the data is located at path <code>[1]</code>. The nested predicate in the specification is located at path <code>[1 0]</code>, nearly same except for the trailing <code>0</code>. The root vector of the data is located at path <code>[]</code> while the predicate is located at path <code>[0]</code> of the specification, again, nearly the same except for the trailing zero. Clojure has a nice core function that performs that transformation.</p><pre><code>(drop-last [1 0]) ;; => (1)</code><br><code>(drop-last [0]) ;; => ()</code></pre><p>The slightly modified rule for validating collections is <em>Collection predicates in the specification are applied to the collection in the data that correspond to their parent.</em> In other words, the predicate at path <code>pth</code> in the collection specification is applied to the collection at path <code>(drop-last pth)</code> in the data.</p><p>The modified algorithm for validating collections is as follows:<ol><li>Run <code>all-paths</code> on the data, then the specification.</li><li>Remove <em>scalar</em> elements from the data, keeping only the collection elements.</li><li>Remove <em>non-predicate</em> elements from the collection specification.</li><li>Pair predicates at path <code>pth</code> in the specification with collections at path <code>(drop-last pth)</code> in the data. Discard all other un-paired collections and un-paired predicates.</li><li>For each remaining collection+predicate pair, apply the predicate to the collection.</li></ol></p><p>Speculoos provides a function, <code>validate-collections</code>, that does that for us. Let's see.</p><pre><code>(require '[speculoos.core :refer [validate-collections]])</code><br><br><code>(validate-collections [11 [22 33 44]]
                      [len-3? [len-3?]])
;; => ({:datum [11 [22 33 44]],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate len-3?,
;;      :valid? false}
;;     {:datum [22 33 44],
;;      :ordinal-path-datum [0],
;;      :path-datum [1],
;;      :path-predicate [1 0],
;;      :predicate len-3?,
;;      :valid? true})</code></pre><p>Much of that looks familiar. <code>validate-collections</code> returns a validation entry for each to the two collections+predicate pairs. The <code>:datum</code> stuff represent the things being tested and the <code>:predicate</code>s report the predicate functions, and similarly, <code>valid?</code> reports whether that predicate was satisfied.</p><p>There are now three things that involve the concept of a path: the predicate was found at <code>:path-predicate</code> in the specification and the datum was found at <code>:ordinal-path-datum</code> in the data, which is also presented in a more friendly format as the literal path <code>:path-datum</code>. (We'll explain the terms embodied by these keywords as the discussion progresses.) In this example, the nested vector contains three elements, so its predicate was satisfied, while the root vector contains only two elements, and thus failed to satisfy its predicate.</p><p>Let's take a look at validating nested maps. Here are the paths of some example data.</p><pre><code>(all-paths {:x 11, :y {:z 22}})
;; => [{:path [], :value {:x 11, :y {:z 22}}}
;;     {:path [:x], :value 11}
;;     {:path [:y], :value {:z 22}}
;;     {:path [:y :z], :value 22}]</code></pre><p>Two scalars, which <code>validate-collections</code> ignores, and two collections. Let's apply our rule: the predicate in the specification applies to the collection in the data whose path is one element shorter. The two collections are located at paths <code>[]</code> and <code>[:y]</code>. To write a collection specification, we'd mimic the shape of the data, inserting predicates that apply to the parent. We can't simply write</p><pre><code>{map? {map?}}</code></pre><p>because maps must contain an even number of forms. So we're going to need to add some keys in there. Technically, you could key your collection predicates however you want, but I strongly recommend choosing a key that doesn't appear in the data. This example shows why. We could put a predicate at key <code>:y</code> of the specification, and <code>validate-collections</code> will merrily chug along.</p><pre><code>(validate-collections {:x 11, :y {:z 22}}
                      {:y map?})
;; => ({:datum {:x 11, :y {:z 22}},
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [:y],
;;      :predicate map?,
;;      :valid? true})</code></pre><p>We can see that the singular <code>map?</code> predicate located at specification path <code>[:y]</code> was indeed applied to the root container at data path <code>(drop-last [:y])</code> which evaluates to path <code>[]</code>. But now we've consumed that key, and it cannot be used to target the nested map <code>{:z 22}</code> at <code>[:y]</code> in the data.</p><p>If we had instead invented a synthetic key, <code>drop-last</code> would trim it off the right end and the predicate would still be applied to the root container, while key <code>:y</code> remains available to target the nested map. In practice, I like to invent keys that are descriptive of the predicate so the validation results are easier to scan by eye.</p><pre><code>(validate-collections {:x 11, :y {:z 22}}
                      {:is-a-map? map?, :y {:is-a-set? set?}})
;; => ({:datum {:x 11, :y {:z 22}},
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [:is-a-map?],
;;      :predicate map?,
;;      :valid? true}
;;     {:datum {:z 22},
;;      :ordinal-path-datum [:y],
;;      :path-datum [:y],
;;      :path-predicate [:y :is-a-set?],
;;      :predicate set?,
;;      :valid? false})</code></pre><p>Notice that <code>validate-collections</code> completely ignored the scalars <code>11</code> and <code>22</code> at data keys <code>:x</code> and <code>:z</code>. It only applied predicate <code>map?</code> to the root of data and predicate <code>set?</code> to the nested map at key <code>:y</code>, which failed to satisfy.</p><p>Let me emphasize: within a collection specification, the name of the predicate keys targeting a nested map have <em>absolutely no bearing on the operation of the validation</em>; they get truncated by the <code>drop-last</code> operation. We could have used something misleading like this.</p><pre><code>;;             this keyword… ---v         v--- …gives the wrong impression about this predicate</code><br><code>(validate-collections {:x 11} {:is-a-map? vector?})
;; => ({:datum {:x 11},
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [:is-a-map?],
;;      :predicate vector?,
;;      :valid? false})</code></pre><p>Despite the key suggesting that we're testing for a map, the actual predicate tests for a vector, and returns <code>false</code>.</p><p>Here's something interesting.</p><pre><code>(validate-collections [42]
                      [vector? map?])
;; => ({:datum [42],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate vector?,
;;      :valid? true}
;;     {:datum [42],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [1],
;;      :predicate map?,
;;      :valid? false})</code></pre><p>If we focus on the paths of the two predicates in the specification, we see that both <code>vector?</code> and <code>map?</code> target the root container because <code>(drop-last [0])</code> and <code>(drop-last [1])</code> both evaluate to the same path in the data. So we have another consideration: <em>Every</em> predicate in a specification's collection applies to the parent collection in the data. This means that we can apply an unlimited number of predicates to each collection.</p><pre><code>(validate-collections [42]
                      [vector? map? list? set? coll?])
;; => ({:datum [42],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate vector?,
;;      :valid? true}
;;     {:datum [42],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [1],
;;      :predicate map?,
;;      :valid? false}
;;     {:datum [42],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [2],
;;      :predicate list?,
;;      :valid? false}
;;     {:datum [42],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [3],
;;      :predicate set?,
;;      :valid? false}
;;     {:datum [42],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [4],
;;      :predicate coll?,
;;      :valid? true})</code></pre><p>If <strong>any</strong> number of predicates apply to the parent collection, there might be zero to infinity predicates before we encounter a nested collection in that sequence. How, then, does <code>validate-collections</code> determine where to apply the predicate inside a nested collection?</p><p>The rule <code>validate-collections</code> follows is <em>Apply nested collection predicates in the order which they appear, ignoring scalars.</em> Let's see that in action. First, we'll make some example data composed of a parent vector, containing a nested map, list, and set, with a couple of interleaved integers.</p><pre><code>[{:a 11} 22 (list 33) 44 #{55}]</code></pre><p>Now we need to compose a collection specification. Motto #2 reminds us to make the specification mimic the shape of the data. I'm going to copy-paste the data and mash the delete key to remove the scalar datums.</p><pre><code>[{     }    (       )    #{  }]</code></pre><p>Just to emphasize how they align, here are the data (top) and the collection specification (bottom) with some spaced formatting.</p><pre><code>[{:a 11} 22 (list 33) 44 #{55}] ;; <--- data</code><br><code>[{     }    (       )    #{  }] ;; <--- collection specification</code><br><code> ^--- 1st   ^--- 2nd     ^--- 3rd collection</code></pre><p>The first thing to note is that our collection specification looks a lot like our data with all the scalars removed. The second thing to notice is that even though it contains zero predicates, that's a legitimate collection specification which <code>validate-collections</code> can consume. Check this out.</p><pre><code>(validate-collections [{:a 11} 22 (list 33) 44 #{55}] [{} () #{}]) ;; => ()</code></pre><p>Validation ignores collections in the data that are not paired with a predicate in the specification.</p><p>Okay, let's add a predicate. Let's specify that the second nested collection is a list. Predicates apply to their container, so we'll insert <code>list?</code> into the corresponding collection.</p><pre><code>(validate-collections [{:a 11} 22 (list 33) 44 #{55}]
                      [{} (list list?) #{}])
;; => ({:datum (33),
;;      :ordinal-path-datum [1],
;;      :path-datum [2],
;;      :path-predicate [1 0],
;;      :predicate list?,
;;      :valid? true})</code></pre><p>One predicate in the specification pairs with one collection in the data, so we receive one validation result. The <code>list?</code> predicate at path <code>[1 0]</code> in the specification was applied to the collection located at path <code>[2]</code> in the data. That nested collection is indeed a list, so <code>:valid?</code> is <code>true</code>.</p><p> Notice how <code>validate-collections</code> did some tedious and boring calculations to achieve the general effect of <em>The predicate in the second nested collection of the specification applies to the second nested collection of the data.</em> It kinda skipped over that <code>22</code> because it ignores scalars, and we're validating collections.</p><p>Let's clear the slate and specify that nested set at the end.</p><pre><code>(validate-collections [{:a 11} 22 (list 33) 44 #{55}]
                      [{} () #{set?}])
;; => ({:datum #{55},
;;      :ordinal-path-datum [2],
;;      :path-datum [4],
;;      :path-predicate [2 set?],
;;      :predicate set?,
;;      :valid? true})</code></pre><p>One predicate applied to one collection, one validation result. And again, collection validation skipped right over the intervening scalars <code>22</code> and <code>44</code> in the data. <code>validate-collections</code> applied the predicate in the specification's third nested collection to the data's third nested collection.</p><p>We might as well specify that nested map now. Recall that collection predicates targeting a map require a sham key. Removing the <code>set?</code> predicate from the previous example, we'll insert a <code>map?</code> predicate at a key in the specification that doesn't appear in the data's nested map.</p><pre><code>(validate-collections [{:a 11} 22 (list 33) 44 #{55}]
                      [{:is-map? map?} () #{}])
;; => ({:datum {:a 11},
;;      :ordinal-path-datum [0],
;;      :path-datum [0],
;;      :path-predicate [0 :is-map?],
;;      :predicate map?,
;;      :valid? true})</code></pre><p>Unlike the previous two validations, <code>validate-collections</code> didn't have to skip over any scalars. It merely applied the predicate in the specification's first nested collection to the data's first nested collection, which is indeed a map.</p><p>We've now seen how to specify and validate each of those three nested collections, so for completeness' sake, let's specify the root. Predicates apply to their container, so for clarity, we'll insert it at the beginning.</p><pre><code>(validate-collections [{:a 11} 22 (list 33) 44 #{55}]
                      [vector? {} () #{}])
;; => ({:datum [{:a 11} 22 (33) 44 #{55}],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate vector?,
;;      :valid? true})</code></pre><p>Technically, we could put that particular predicate anywhere in the top-level vector as long <code>(drop-last path)</code> evaluates to <code>[]</code>. All the following yield substantially the same results.</p><pre><code>(validate-collections [{:a 11} 22 (list 33) 44 #{55}] [vector? {} () #{}])</code><br><code>(validate-collections [{:a 11} 22 (list 33) 44 #{55}] [{} vector? () #{}])</code><br><code>(validate-collections [{:a 11} 22 (list 33) 44 #{55}] [{} () vector? #{}])</code><br><code>(validate-collections [{:a 11} 22 (list 33) 44 #{55}] [{} () #{} vector?])</code></pre><p>In practice, I find it visually clearer to insert the predicates at the front.</p><p>Let's do one final, all-up demonstration.</p><pre><code>(validate-collections [{:a 11} 22 (list 33) 44 #{55}]
                      [vector? {:is-map? map?} sequential? (list list?) coll? #{set?} any?])
;; => ({:datum [{:a 11} 22 (33) 44 #{55}],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate vector?,
;;      :valid? true}
;;     {:datum {:a 11},
;;      :ordinal-path-datum [0],
;;      :path-datum [0],
;;      :path-predicate [1 :is-map?],
;;      :predicate map?,
;;      :valid? true}
;;     {:datum [{:a 11} 22 (33) 44 #{55}],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [2],
;;      :predicate sequential?,
;;      :valid? true}
;;     {:datum (33),
;;      :ordinal-path-datum [1],
;;      :path-datum [2],
;;      :path-predicate [3 0],
;;      :predicate list?,
;;      :valid? true}
;;     {:datum [{:a 11} 22 (33) 44 #{55}],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [4],
;;      :predicate coll?,
;;      :valid? true}
;;     {:datum #{55},
;;      :ordinal-path-datum [2],
;;      :path-datum [4],
;;      :path-predicate [5 set?],
;;      :predicate set?,
;;      :valid? true}
;;     {:datum [{:a 11} 22 (33) 44 #{55}],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [6],
;;      :predicate any?,
;;      :valid? true})</code></pre><p><code>validate-collections</code> applied to the data's root four predicates — <code>vector?</code>, <code>sequential?</code>, <code>coll?</code>, and <code>any?</code> — which we interleaved among the nested collections. In addition, it validated each of the three nested collections, skipping over the intervening scalars.</p><p>Collections nested within a map do not involve that kind of skipping because they're not sequential. Let's make this our example data.</p><pre><code>{:a [99] :b (list 77)}</code></pre><p>Now, we copy-paste the data, then delete the scalars.</p><pre><code>{:a [  ] :b (list   )}</code></pre><p>That becomes the template for our collection specification. Let's pretend we want to specify something about those two nested collections at keys <code>:a</code> and <code>:b</code>. We stuff the predicates <em>directly inside those collections</em>.</p><pre><code>{:a [vector?] :b (list list?)}</code></pre><p>This becomes our collection specification. Let's see what happens.</p><pre><code>(validate-collections {:a [99], :b (list 77)}
                      {:a [vector?], :b (list list?)})
;; => ({:datum [99],
;;      :ordinal-path-datum [:a],
;;      :path-datum [:a],
;;      :path-predicate [:a 0],
;;      :predicate vector?,
;;      :valid? true}
;;     {:datum (77),
;;      :ordinal-path-datum [:b],
;;      :path-datum [:b],
;;      :path-predicate [:b 0],
;;      :predicate list?,
;;      :valid? true})</code></pre><p>Checklist time.<ul><li>Specification shape mimics data? <em>Check.</em></li><li>Validating collections, ignoring scalars? <em>Check.</em></li><li>Two paired predicates, two validations? <em>Check.</em></li></ul></p><p>There's a subtlety to pay attention to: the <code>vector?</code> and <code>list?</code> predicates are contained within a vector and list, respectively. Those two predicates apply to their <em>immediate</em> parent container. <code>validate-collections</code> needs those <code>:a</code> and <code>:b</code> keys to find that vector and that list. You only use a sham key when validating the map immediately above your head.</p><p>Let's re-use that validation and tack on a sham key with a predicate aimed at the root map.</p><pre><code>(validate-collections {:a [99], :b (list 77)}
                      {:a [vector?], :b (list list?), :howdy map?})
;; => ({:datum [99],
;;      :ordinal-path-datum [:a],
;;      :path-datum [:a],
;;      :path-predicate [:a 0],
;;      :predicate vector?,
;;      :valid? true}
;;     {:datum (77),
;;      :ordinal-path-datum [:b],
;;      :path-datum [:b],
;;      :path-predicate [:b 0],
;;      :predicate list?,
;;      :valid? true}
;;     {:datum {:a [99], :b (77)},
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [:howdy],
;;      :predicate map?,
;;      :valid? true})</code></pre><p>We've got the vector and list validations as before, and then, at the end, we see that <code>map?</code> at the sham <code>:howdy</code> key was applied to the root.</p><p>One more example to illustrate this point. Again, here's our data.</p><pre><code>{:a [99] :b (list 77)}</code></pre><p>And again, we'll copy-paste the data, then delete the scalars. That'll be our template for our collection specification.</p><pre><code>{:a [  ] :b (list   )}</code></pre><p>Now, we'll go even further and delete the <code>:b</code>  key and its value, the nested list.</p><pre><code>{:a [  ]             }</code><br><br><code>;; without :b, won't be able to validate the list</code></pre><p>Insert old reliable <code>vector?</code>. That predicate is paired with its immediate parent vector, so we need to keep the <code>:a</code> key.</p><pre><code>{:a [vector?]        }</code></pre><p>Finally, we'll add in a wholly different key, with a <code>coll?</code> predicate nested in a collection at the new key.</p><pre><code>{:a [vector?] :flamingo [coll?]}</code></pre><p>Test yourself: How many validations will occur?</p><pre><code>(validate-collections {:a [99], :b (list 77)}
                      {:a [vector?], :flamingo [coll?]})
;; => ({:datum [99],
;;      :ordinal-path-datum [:a],
;;      :path-datum [:a],
;;      :path-predicate [:a 0],
;;      :predicate vector?,
;;      :valid? true})</code></pre><p>In this example, there is only one predicate+collection pair. <code>vector?</code> applies to the vector at <code>:a</code>. We might have expected <code>coll?</code> to be applied somewhere because <code>:flamingo</code> doesn't appear in the map, but notice that <code>coll?</code> is <em>contained</em> in a vector. It would only ever apply to the thing that contained it. Since the data's root doesn't contain a collection at that key, the predicate is unpaired, and thus ignored. If we wanted to apply <code>coll?</code> to the root, we peel off its immediate container.</p><pre><code>(validate-collections {:a [99], :b (list 77)}
                      {:a [vector?], :emu coll?})
;; => ({:datum [99],
;;      :ordinal-path-datum [:a],
;;      :path-datum [:a],
;;      :path-predicate [:a 0],
;;      :predicate vector?,
;;      :valid? true}
;;     {:datum {:a [99], :b (77)},
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [:emu],
;;      :predicate coll?,
;;      :valid? true})</code></pre><p><em>Now, </em><code>coll?</code>'s immediate container is the root. Since it is now properly paired with a collection, it participates in validation. </p></section><section id="valid-thorough"><h2>Validation Summaries and Thorough Validations</h2><p>Up until now, we've been using <code>validate-scalars</code> and <code>validate-collections</code>, because they're verbose. For teaching and learning purposes (and for <a href="#troubleshooting">diagnosing problems</a>), it's useful to see all the information considered by the validators. However, in production, once we've got our specification shape nailed down, we'll want a cleaner <em>yes</em> or <em>no</em> answer on whether the data satisfied the specification. We could certainly pull out the non-truthy, invalid results ourselves…</p><pre><code>(filter #(not (:valid? %))
  (validate-scalars [42 "abc" 22/7]
                    [int? symbol? ratio?]))
;; => ({:datum "abc",
;;      :path [1],
;;      :predicate symbol?,
;;      :valid? false})</code></pre><p>…and then check for invalids ourselves…</p><pre><code>(empty? *1) ;; => false</code></pre><p>…but Speculoos provides a function that does exactly that, both for scalars…</p><pre><code>(require '[speculoos.core :refer [valid-scalars? valid-collections?]])</code><br><br><code>(valid-scalars? [42 "abc" 22/7]
                [int? symbol? ratio?])
;; => false</code></pre><p>…and for collections.</p><pre><code>(valid-collections? [42 ["abc"]]
                    [vector? [vector?]])
;; => true</code></pre><p>Whereas the <code>validate-…</code> functions return a detailed validation report of every predicate+datum pair they see, the <code>valid-…?</code> variants provide a plain <code>true/false</code>.</p><p>Beware: Validation only considers paired predicates+datums (Motto #3). If your datum doesn't have a paired predicate, then it won't be validated. Observe.</p><pre><code>(valid-scalars? {:a 42}
                {:b string?}) ;; => true</code><br><br><code>(validate-scalars {:a 42}
                  {:b string?}) ;; => []</code></pre><p><code>42</code> does not share a path with <code>string?</code>, the lone predicate in the specification. Since there are zero invalid results, <code>valid-scalars?</code> returns <code>true</code>.</p><p><strong>» Within the Speculoos library, <code>valid?</code> means <em> zero invalids. «</em></strong></p><h3 id="thorough">Thorough validation</h3><p>Motto #3 reminds us that data elements not paired with a predicate are ignored. For some tasks, we may want to ensure that all elements in the data are subjected to at least one predicate. Plain <code>valid?</code>  only reports if all datum+predicate pairs are <code>true</code>.</p><pre><code>(valid-scalars? [42 "abc" 22/7]
                [int?]) ;; => true</code></pre><p>In this example, only <code>42</code> and <code>int?</code> form a pair that is validated. <code>"abc"</code> and <code>22/7</code> are not paired with predicates, and therefore ignored.</p><p>The <em>thorough</em> function <a href="#fn-terminology">variants</a> require that all data elements be specified, otherwise, they return <code>false</code>. Thoroughly validating that same data with that same specification shows the difference.</p><pre><code>(require '[speculoos.utility :refer [thoroughly-valid-scalars?]])</code><br><br><code>(thoroughly-valid-scalars? [42 "abc" 22/7]
                           [int?])
;; => false</code></pre><p>Whereas <code>valid-scalars?</code> ignored the un-paired <code>"abc"</code> and <code>22/7</code>, <code>thoroughly-valid-scalars?</code> notices that neither have a predicate. Even though <code>42</code> satisfied <code>int?</code>, the un-paired scalars mean that this validation is not thorough, and thus <code>thoroughly-valid-scalars?</code> returns <code>false</code>.</p><p>The <code>utility</code> <a href="#utilities">namespace</a> provides a thorough variant for collections, as well as a variant for <a href="#combo">combo</a> validations. <code>thoroughly-valid-collections?</code> works analogously to what we've just seen.</p><p>Let's look at a combo example. First, the 'plain' version.</p><pre><code>(valid? [42 "abc" 22/7]
        [int?]
        [vector?]) ;; => true</code></pre><p>We validated the single vector, and only one out of the three scalars. <code>valid?</code> only considers paired elements+predicates, so it only validated <code>42</code> and the root vector. <code>valid?</code> ignored <code>"abc"</code> and <code>22/7</code>.</p><p>The thorough variant, <code>thoroughly-valid?</code>, however, does not ignore un-paired data elements.</p><pre><code>(require '[speculoos.utility :refer [thoroughly-valid?]])</code><br><br><code>(thoroughly-valid? [42 "abc" 22/7]
                   [int?]
                   [vector?])
;; => false</code></pre><p>Even though both predicates, <code>int?</code> and <code>vector?</code>, were satisfied, <code>thoroughly-valid?</code> requires that all data elements be validated. Since <code>42</code> and <code>22/7</code> are un-paired, the entire validation returns <code>false</code>.</p><p>Note: Thoroughly validating does not ensure any measure of correctness or rigor. 'Thorough' merely indicates that each element was exposed to <em>some</em> kind of predicate. That predicate could actually be trivially permissive. In the next example, <code>any?</code> returns <code>true</code> for all values.</p><pre><code>(thoroughly-valid? [42 "abc" 22/7]
                   [any? any? any?]
                   [any?])
;; => true</code></pre><p>The only thing <code>thoroughly-valid?</code> tells us in this example is that the one vector and all three scalars were paired with a predicate, and that all four data elements satisfied a guaranteed-to-be-satisfied predicate.</p><p>Validation is only as good as the predicate. It's our responsibility to write a proper predicate.</p><h3 id="combo">Combo validation</h3><p>Validating scalars separately from validating collections is a core principle embodied by the Speculoos library. I believe that separating the two into distinct processes carries solid advantages because the specifications are more straightforward, the mental model is clearer, the implementation code is simpler, and it makes validation <em>à la carte</em>. Much of the time, you can probably get away with just a scalar specification.</p><p>All that said, it is not possible to specify and validate every aspect of your data with only scalar validation or only collection validation. When we really need to be strict and validate both scalars and collections, we could manually combine like this.</p><pre><code>(and (valid-scalars? [42] [int?])
     (valid-collections? [42] [vector?]))
;; => true</code></pre><p>Speculoos provides a pre-made utility that does exactly that. We supply some data, then a scalar specification, then a collection specification.</p><pre><code>(require '[speculoos.core :refer [valid? validate]])</code><br><br><code>(valid? [42]
        [int?]
        [vector?]) ;; => true</code></pre><p>Let me emphasize what <code>valid?</code> is doing here, because it is <em>not</em> violating the first Motto about separately validating scalars and collections. First, <code>valid?</code> performs a scalar validation on the data, and puts that result on the shelf. Then, in a completely distinct operation, it performs a collection validation. <code>valid?</code> then pulls the scalar validation results off the shelf and combines it with the collection validation results, and returns a singular <code>true/false</code>.  (Look back at the first example of this sub-section to see the separation.)</p><p>I reserved the shortest, most mnemonic function name, <code>valid?</code>, to signal how important it is to separate scalar and collection validation.</p><p>Speculoos also provides a variant that returns detailed validation results after performing distinct scalar validation and collection validation.</p><pre><code>(validate [42 "abc" 22/7]
          [int? symbol? ratio?]
          [vector?])
;; => ({:datum 42,
;;      :path [0],
;;      :predicate int?,
;;      :valid? true}
;;     {:datum "abc",
;;      :path [1],
;;      :predicate symbol?,
;;      :valid? false}
;;     {:datum 22/7,
;;      :path [2],
;;      :predicate ratio?,
;;      :valid? true}
;;     {:datum [42 "abc" 22/7],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate vector?,
;;      :valid? true})</code></pre><p><code>validate</code> gives us the exact results as if we had run <code>validate-scalars</code> and then immediately thereafter <code>validate-collections</code>. <code>validate</code> merely gives us the convenience of quickly running both in succession without having to re-type the data. With one invocation, we can validate <em>all</em> aspects of our data, both scalars and collections, and we never violated Motto #1.</p><h3 id="fn-terminology">Function Naming Conventions</h3><p>Here are the general patterns regarding the function names.<ul><li><strong><code>validate-…</code></strong> functions return a detailed report for every datum+predicate pair.</li><li><strong><code>valid-…?</code></strong> functions return <code>true</code> if the predicate+datum pairs produce zero falsey results, <code>false</code> otherwise.</li><li><strong><code>…-scalars</code></strong> functions consider only non-collection datums.</li><li><strong><code>…-collections</code></strong> functions consider only non-scalar datums.</li><li><strong><code>thoroughly-…</code></strong> functions return <code>true</code> only if every element (scalar or collection, as the case may be) is paired with a predicate, and every element satisfies its predicate.</li></ul>'Plain' functions (i.e., <code>validate</code>, <code>valid?</code>, and <code>thoroughly-valid?</code>) perform a scalar validation, followed by performing a distinct collection validation, and returns a single comprehensive response that merges the results of both.</p><p>Here's how those terms are put together, and what they do.</p><table><tr><th>function</th><th>checks…</th><th>returns…</th><th>note</th></tr><tr><td><code>validate-scalars</code></td><td>scalars only</td><td>detailed validation report</td><td></td></tr><tr><td><code>valid-scalars?</code></td><td>scalars only</td><td><code>true/false</code></td><td></td></tr><tr><td><code>thoroughly-valid-scalars?</code></td><td>scalars only</td><td><code>true/false</code></td><td>only <code>true</code> if all scalars paired with a predicate</td></tr><tr><td><code>validate-collections</code></td><td>collections only</td><td>detailed validation report</td><td></td></tr><tr><td><code>valid-collections?</code></td><td>collections only</td><td><code>true/false</code></td><td></td></tr><tr><td><code>thoroughly-valid-collections?</code></td><td>collections only</td><td><code>true/false</code></td><td>only <code>true</code> if all collections paired with a predicate</td></tr><tr><td><code>validate</code></td><td>scalars, then collections, separately</td><td>detailed validation report</td><td></td></tr><tr><td><code>valid?</code></td><td>scalars, then collections, separately</td><td><code>true/false</code></td><td></td></tr><tr><td><code>thoroughly-valid?</code></td><td>scalars, then collections separately</td><td><code>true/false</code></td><td>only <code>true</code> if all datums paired with a predicate</td></tr></table></section><section id="function-validation"><h2>Specifying and Validating Functions</h2><p>Being able to validate Clojure data enables us to check the usage and behavior of functions.</p><ol><li><strong>Validating arguments</strong> Speculoos can validate any property of the arguments passed to a function when it is invoked. We can ask questions like <em>Is the argument passed to the function a number?</em>, a scalar validation, and <em>Are there an even number of arguments?</em>, a collection validation.</li><li><strong>Validating return values</strong> Speculoos can validate any property of the value returned by a function. We can ask questions like <em>Does the function return a four-character string?</em>, a scalar validation, and <em>Does the function return a map containing keys <code>:x</code> and <code>:y</code></em>, a collection validation.</li><li><strong>Validating function correctness</strong> Speculoos can validate the correctness of a function in two ways.<ul><li>Speculoos can validate the <em>relationships</em> between the arguments and the function's return value. We can ask questions like <em>Is each of the three integers in the return value larger than the three integers in the arguments?</em>, a scalar validation, and <em>Is the return sequence the same length as the argument sequence, and are all the elements in reverse order?</em>, a collection validation.</li><li>Speculoos can <em>exercise</em> a function. This allows us to check <em>If we give this function one thousand randomly-generated valid inputs, does the function always produce a valid return value?</em> Exercising functions with randomly-generated samples is described in the </li><a href="#exercising">next section</a>.</ul></li></ol><p>None of those six checks are strictly required. Speculoos will happily validate using only the specifications we provide.</p><h3 id="fn-args">1. Validating Function Arguments</h3><p>When we invoke a function with a series of arguments, that series of values forms a sequence, which Speculoos can validate like any other heterogeneous, arbitrarily-nested data structure. Speculoos offers <a href="#explicit">a trio</a> of function-validating functions with differing levels of explicitness. We'll be primarily using <code>validate-fn-with</code> because it is the most explicit of the trio, and we can most easily observe what's going on.</p><p>Let's pretend we want to validate the arguments to a function <code>sum-three</code> that expects three integers and returns their sum.</p><pre><code>(require '[speculoos.function-specs :refer [validate-fn-with]])</code><br><br><code>(defn sum-three [x y z] (+ x y z))</code><br><br><code>(sum-three 1 20 300) ;; => 321</code></pre><p>The argument list is a <em>sequence</em> of values, in this example, a sequential thing of three integers. We can imagine a scalar specification for just such as sequence.</p><pre><code>[int? int? int?]</code></pre><p>When using <code>validate-fn-with</code>, we supply the function name, a map containing zero or more specifications, and some trailing <code>&-args</code> as if they had been supplied directly to the function. Speculoos can validate five aspects of a function using up to five specifications, each specification associated in that map to a particular key. We'll cover each of those five aspects in turn. To start, we want to specify the <em>argument scalars</em>.</p><p>Instead of individually passing each of those five specifications to <code>validate-fn-with</code> and putting <code>nil</code> placeholders where don't wish to supply a specification, we organize the specifications. To do so, we associate the arguments' scalar specification to the qualified key <code>:speculoos/arg-scalar-spec</code>.</p><pre><code>{:speculoos/arg-scalar-spec [int? int? int?]}</code></pre><p>Then, we validate the arguments to <code>sum-three</code> like this.</p><pre><code>(validate-fn-with sum-three
                  {:speculoos/arg-scalar-spec [int? int? int?]}
                  1
                  20
                  300)
;; => 321</code></pre><p>The arguments conformed to the scalar specification, so <code>validate-fn-with</code> returns the value produced by <code>sum-three</code>. Let's intentionally invoke <code>sum-three</code> with one invalid argument by swapping integer <code>1</code> with a floating-point <code>1.0</code>.</p><pre><code>(validate-fn-with sum-three
                  {:speculoos/arg-scalar-spec [int? int? int?]}
                  1.0
                  20
                  300)
;; => ({:datum 1.0,
;;      :fn-spec-type :speculoos/argument,
;;      :path [0],
;;      :predicate int?,
;;      :valid? false})</code></pre><p>Hey, that kinda <a href="#scalar-validation">looks familiar</a>. It looks a lot like something <code>validate-scalars</code> would emit if we filtered to keep only the invalids. We see that <code>1.0</code> at path <code>[0]</code> failed to satisfy its <code>int?</code> scalar predicate. We can also see that the function specification type is <code>:speculoos/argument</code>. Since Speculoos can validate scalars and collections of both arguments and collections, that key-val is a little signpost to help us pinpoint exactly what and where. Let's invoke <code>sum-three</code> with a second invalid argument, a ratio <code>22/7</code> instead of integer <code>300</code>.</p><pre><code>(validate-fn-with sum-three
                  {:speculoos/arg-scalar-spec [int? int? int?]}
                  1.0
                  20
                  22/7)
;; => ({:datum 1.0,
;;      :fn-spec-type :speculoos/argument,
;;      :path [0],
;;      :predicate int?,
;;      :valid? false}
;;     {:datum 22/7,
;;      :fn-spec-type :speculoos/argument,
;;      :path [2],
;;      :predicate int?,
;;      :valid? false})</code></pre><p>In addition to the invalid <code>1.0</code> at path <code>[0]</code>, we see that <code>22/7</code> at path <code>[2]</code> also fails to satisfy its <code>int?</code> scalar predicate. The scalar predicate's path in the scalar specification is the same as the path of the <code>22/7</code> in the <code>[1.0 20 22/7]</code> sequence of arguments. Roughly, <code>validate-fn-with</code> is doing something like this…</p><pre><code>(speculoos.core/only-invalid
  (validate-scalars [1.0 20 22/7]
                    [int? int? int?]))
;; => ({:datum 1.0,
;;      :path [0],
;;      :predicate int?,
;;      :valid? false}
;;     {:datum 22/7,
;;      :path [2],
;;      :predicate int?,
;;      :valid? false})</code></pre><p>…validating scalars with <code>validate-scalars</code> and keeping only the invalids.</p><p>Okay, we see that term <em>scalar</em> buzzing around, so there must be something else about validating collections. Yup. We can also validate collection properties of the argument sequence. Let's specify that the argument sequence must contain three elements, using a custom collection predicate.</p><pre><code>(defn count-3? [v] (= 3 (count v)))</code></pre><p>Let's simulate the collection validation first. Remember, collection predicates are applied to their parent containers, so <code>count-3?</code> must appear within a collection so that it'll be paired with the data's containing collection.</p><pre><code>(validate-collections [1 20 30]
                      [count-3?])
;; => ({:datum [1 20 30],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate count-3?,
;;      :valid? true})</code></pre><p>That result fits with <a href="#collection-validation">our discussion</a> about validating collections.</p><p>Next, we'll associate that collection specification into our function specification map at <code>:speculoos/arg-collection-spec</code> and invoke <code>validate-fn-with</code> with three valid arguments.</p><pre><code>(validate-fn-with sum-three
                  {:speculoos/arg-collection-spec [count-3?]}
                  1
                  20
                  300)
;; => 321</code></pre><p>The argument sequence satisfies our collection specification, so <code>sum-three</code> returns the expected value. Now let's repeat, but with an additional argument that causes the argument list to violate its collection predicate.</p><pre><code>(validate-fn-with sum-three
                  {:speculoos/arg-collection-spec [count-3?]}
                  1 20
                  300 4000)
;; => ({:datum [1 20 300 4000],
;;      :fn-spec-type :speculoos/argument,
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate count-3?,
;;      :valid? false})</code></pre><p>This four-element argument list, <code>[1 20 300 4000]</code>, failed to satisfy our <code>count-3?</code> collection predicate, so <code>validate-fn-with</code> emitted a validation report.</p><p>Note #1: Invoking <code>sum-three</code> with four arguments would normally trigger an arity exception. <code>validate-fn-with</code> catches the exception and validates as much as it can.</p><p>Note #2: Don't specify and validate the <em>type</em> of the arguments container, i.e., <code>vector?</code>. That's an implementation detail and not guaranteed.</p><p>Let's get fancy and combine an argument scalar specification and an argument collection specification. Outside of the context of checking a function, that <a href="#combo">combo validation</a> would look like this.</p><pre><code>(speculoos.core/only-invalid
  (validate [1.0 20 22/7 4000]
            [int? int? int?]
            [count-3?]))
;; => ({:datum 1.0,
;;      :path [0],
;;      :predicate int?,
;;      :valid? false}
;;     {:datum 22/7,
;;      :path [2],
;;      :predicate int?,
;;      :valid? false}
;;     {:datum [1.0 20 22/7 4000],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate count-3?,
;;      :valid? false})</code></pre><p>Let's remember: scalars and collections are <em>always</em> validated separately. <code>validate</code> is merely a convenience function that does both a scalar validation, then a collection validation, in discrete processes, with a single function invocation. Each of the first three scalars that paired with a scalar predicate were validated as scalars. The first and third scalars failed to satisfy their respective predicates. The fourth argument, <code>4000</code>, was not paired with a scalar predicate and was therefore ignored. Then, the argument sequence as a whole was validated against the collection predicate <code>count-3?</code>.</p><p><code>validate-fn-with</code> performs substantially that combo validation. We'll associate the <strong>arg</strong>ument <strong>scalar</strong> <strong>spec</strong>ification with <code>:speculoos/arg-scalar-spec</code> and the <strong>arg</strong>ument <strong>collection</strong> <strong>spec</strong>fication with <code>:speculoos/arg-collection-spec</code> and pass the invalid argument sequence.</p><pre><code>(validate-fn-with sum-three
                  {:speculoos/arg-scalar-spec [int? int? int?],
                   :speculoos/arg-collection-spec [count-3?]}
                  1.0 20
                  22/7 4000)
;; => ({:datum 1.0,
;;      :fn-spec-type :speculoos/argument,
;;      :path [0],
;;      :predicate int?,
;;      :valid? false}
;;     {:datum 22/7,
;;      :fn-spec-type :speculoos/argument,
;;      :path [2],
;;      :predicate int?,
;;      :valid? false}
;;     {:datum [1.0 20 22/7 4000],
;;      :fn-spec-type :speculoos/argument,
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate count-3?,
;;      :valid? false})</code></pre><p>Just as in the <code>validate</code> simulation, we see three items fail to satisfy their predicates. Scalars <code>1.0</code> and <code>22/7</code> are not integers, and the argument sequence as a whole, <code>[1.0 20 22/7 4000]</code>, does not contain exactly three elements, as required by its collection predicate.</p><h3 id="fn-ret">2. Validating Function Return Values</h3><p>Speculoos can also validate values returned by a function. Reusing our <code>sum-three</code> function, and going back to valid inputs, we can associate a <strong>ret</strong>urn <strong>scalar</strong> <strong>spec</strong>ification into <code>validate-fn-with</code>'s specification map to key <code>:speculoos/ret-scalar-spec</code>. Let's stipulate that the function returns an integer. Here's how we pass that specification to <code>validate-fn-with</code>.</p><pre><code>{:speculoos/ret-scalar-spec int?}</code></pre><p>And now, the function return validation.</p><pre><code>(validate-fn-with sum-three
                  {:speculoos/ret-scalar-spec int?}
                  1
                  20
                  300)
;; => 321</code></pre><p>The return value <code>321</code> satisfies <code>int?</code>, so <code>validate-fn-with</code> returns the computed sum.</p><p>What happens when the return value is invalid? Instead of messing up <code>sum-three</code>'s definition, we'll merely alter the scalar predicate. Instead of an integer, we'll stipulate that <code>sum-three</code> returns a string with scalar predicate <code>string?</code>.</p><pre id="nil"><code>(validate-fn-with sum-three
                  {:speculoos/ret-scalar-spec string?}
                  1
                  20
                  300)
;; => ({:datum 321,
;;      :fn-spec-type :speculoos/return,
;;      :path nil,
;;      :predicate string?,
;;      :valid? false})</code></pre><p>Very nice. <code>sum-three</code> computed, quite correctly, the sum of the three arguments. But we gave it a bogus return scalar specification that claimed it ought to be a string, which integer <code>321</code> fails to satisfy.</p><p>Did you happen to notice the <code>path</code>? We haven't yet encountered a case where a path is <code>nil</code>. In this situation, the function returns a 'bare' scalar, not contained in a collection. Speculoos can validate a bare scalar when that bare scalar is a function's return value.</p><p>Let's see how to validate a function when the return value is a collection of scalars. We'll write a new function that returns four scalars: the three arguments and their sum.</p><pre><code>(defn enhanced-sum-three [x y z] [x y z (+ x y z)])</code><br><br><code>(enhanced-sum-three 1 20 300) ;; => [1 20 300 321]</code></pre><p>Our enhanced function now returns a vector of four elements. Let's remind ourselves how we'd manually validate that return value. If we decide we want <code>enhanced-sum-three</code> to return four integers, the scalar specification would look like this.</p><pre><code>[int? int? int? int?]</code></pre><p>And the manual validation would look like this.</p><pre><code>(validate-scalars [1 20 300 321]
                  [int? int? int? int?])
;; => [{:datum 1,
;;      :path [0],
;;      :predicate int?,
;;      :valid? true}
;;     {:datum 20,
;;      :path [1],
;;      :predicate int?,
;;      :valid? true}
;;     {:datum 300,
;;      :path [2],
;;      :predicate int?,
;;      :valid? true}
;;     {:datum 321,
;;      :path [3],
;;      :predicate int?,
;;      :valid? true}]</code></pre><p>Four paired scalars and scalar predicates yield four validation results. Let's see what happens when we validate the function return scalars.</p><pre><code>(validate-fn-with enhanced-sum-three
                  {:speculoos/ret-scalar-spec [int? int? int? int?]}
                  1
                  20
                  300)
;; => [1 20 300 321]</code></pre><p>Since we fed <code>validate-fn-with</code> a specification that happens to agree with those arguments, <code>enhanced-sum-three</code> returns its computed value, <code>[1 20 300 321]</code>.</p><p>Let's stir things up. We'll change the return scalar specification to something we know will fail: The first scalar a character, the final scalar a boolean.</p><pre><code>(validate-fn-with enhanced-sum-three
                  {:speculoos/ret-scalar-spec [char? int? int? boolean?]}
                  1
                  20
                  300)
;; => ({:datum 1,
;;      :fn-spec-type :speculoos/return,
;;      :path [0],
;;      :predicate char?,
;;      :valid? false}
;;     {:datum 321,
;;      :fn-spec-type :speculoos/return,
;;      :path [3],
;;      :predicate boolean?,
;;      :valid? false})</code></pre><p><code>enhanced-sum-three</code>'s function body remained the same, and we fed it the same integers as before, but we fiddled with the return scalar specification so that we returned two invalid scalars. <code>1</code> at path <code>[0]</code> does not satisfy its wonky scalar predicate <code>char?</code> at the same path. And <code>321</code> at path <code>[3]</code> does not satisfy fraudulent scalar predicate <code>boolean?</code> that shares its path.</p><p>Let's set aside validating scalars for a moment and validate a facet of <code>enhanced-sum-three</code>'s return collection. First, we'll do a manual demonstration with <code>validate-collections</code>. Remember: Collection predicates apply to their immediate parent container. We wrote <code>enhanced-sum-three</code> to return a vector, but to make the validation produce something interesting to look at, we'll pretend we're expecting a list.</p><pre><code>(validate-collections [1 20 300 321]
                      [list?])
;; => ({:datum [1 20 300 321],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate list?,
;;      :valid? false})</code></pre><p>That collection validation aligns with our understanding. <code>[1 20 300 321]</code> is not a list. The <code>list?</code> collection predicate at path <code>[0]</code> in the specification was paired with the thing found at path <code>(drop-last [0])</code> in the data, which in this example is the root collection. We designed <code>enhanced-sum-three</code> to yield a vector.</p><p>Let's toss that collection specification at <code>validate-with-fn</code> and have it apply to <code>enhanced-sum-three</code>'s return value, which won't satisfy. We pass the <strong>ret</strong>urn <strong>collection spec</strong>ification by associating it to the key <code>:speculoos/ret-collection-spec</code>.</p><pre><code>(validate-fn-with enhanced-sum-three
                  {:speculoos/ret-collection-spec [list?]}
                  1
                  20
                  300)
;; => ({:datum [1 20 300 321],
;;      :fn-spec-type :speculoos/return,
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate list?,
;;      :valid? false})</code></pre><p>Similarly to the manual collection validation we previously performed with <code>validate-collections</code>, we see that <code>enhanced-sum-three</code>'s return vector <code>[1 20 300 321]</code> fails to satisfy its <code>list?</code> collection predicate.</p><p>A scalar validation followed by an independent collection validation allows us to check every possible aspect that we could want. Now we that we've seen how to individually validate <code>enhance-sum-three</code>'s return scalars and return collections, we know how to do both with one invocation.</p><p>Remember Motto #1: Validate scalars separately from validating collections. Speculoos will only ever do one or the other, but <code>validate</code> is a <a href="#combo">convenience function</a> that performs a scalar validation immediately followed by a collection validation. We'll re-use the scalar specification and collection specification from the previous examples.</p><pre><code>(speculoos.core/only-invalid
  (validate [1 20 300 321]
            [char? int? int? boolean?]
            [list?]))
;; => ({:datum 1,
;;      :path [0],
;;      :predicate char?,
;;      :valid? false}
;;     {:datum 321,
;;      :path [3],
;;      :predicate boolean?,
;;      :valid? false}
;;     {:datum [1 20 300 321],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate list?,
;;      :valid? false})</code></pre><p><code>only-invalid</code> discards the validations where the predicates are satisfied, leaving only the invalids. Two scalars failed to satisfy their scalar predicates. Integer <code>1</code> at path <code>[0]</code> in the data fails to satisfy scalar predicate <code>char?</code> at path <code>[0]</code> in the scalar specification. Integer <code>321</code> fails to satisfy scalar predicate <code>boolean?</code> at path <code>[3]</code> in the scalar specification. Finally, our root vector <code>[1 20 300 321]</code> located at path <code>[]</code> fails to satisfy the collection predicate <code>list?</code> at path <code>[0]</code>.</p><p>Now that we've seen the combo validation done manually, let's validate <code>enhanced-sum-three</code>'s return in the same way. Here's where we see why to organize the specifications in a container instead of passing them as individual arguments: it keeps our invocation neater.</p><pre><code>(validate-fn-with enhanced-sum-three
                  {:speculoos/ret-scalar-spec [char? int? int? boolean?],
                   :speculoos/ret-collection-spec [list?]}
                  1
                  20
                  300)
;; => ({:datum 1,
;;      :fn-spec-type :speculoos/return,
;;      :path [0],
;;      :predicate char?,
;;      :valid? false}
;;     {:datum 321,
;;      :fn-spec-type :speculoos/return,
;;      :path [3],
;;      :predicate boolean?,
;;      :valid? false}
;;     {:datum [1 20 300 321],
;;      :fn-spec-type :speculoos/return,
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate list?,
;;      :valid? false})</code></pre><p><code>validate-fn-with</code>'s validation is substantially the same as the one <code>validate</code> produced in the previous example, except, now, the data comes from invoking <code>enhanced-sum-three</code>. Two scalar invalids and one collection invalid. Integer <code>1</code> fails to satisfy scalar predicate <code>char?</code>, integer <code>321</code> fails to satisfy scalar predicate <code>boolean?</code>, and the entire return vector <code>[1 20 300 321]</code> fails to satisfy collection predicate <code>list?</code>.</p><p>Okay. I think we're ready to put together all four different function validations we've so far seen. We've seen…</p><ul><li>a function argument scalar validation,</li><li>a function argument collection validation,</li><li>a function return scalar validation, and</li><li>a function return collection validation.</li></ul><p>And we've seen how to combine both function argument validations, and how to combine both function return validations. Now we'll combine all four validations into one <code>validate-fn-with</code> invocation.</p><p>Let's review our ingredients. Here's our <code>enhanced-sum-three</code> function.</p><pre><code>(defn enhanced-sum-three [x y z] [x y z (+ x y z)])</code></pre><p><code>enhanced-sum-three</code> accepts three number arguments and returns a vector of those three numbers with their sum appended to the end of the vector. Technically, Clojure would accept any numeric thingy for <code>x</code>, <code>y</code>, and <code>z</code>, but for illustration purposes, we'll make our scalar predicates something non-numeric so we can see something interesting in the validation reports.</p><p>With that in mind, we pretend that we want to validate the function's argument sequence as a string, followed by an integer, followed by a symbol. The function scalar specification will be…</p><pre><code>[string? int? symbol?]</code></pre><p>To allow <code>enhanced-sum-three</code> to calculate a result, we'll supply three numeric values, two of which will not satisfy that argument scalar specification. So that it produces something interesting, we'll make our function argument collection specification also complain.</p><pre><code><code>(defn length-2? [v] (= 2 (count v)))</code></code><br><br><code>;; collection predicates apply to the path of the parent container</code><br><code>[length-2?]</code></pre><p>We know for sure that the argument sequence will contain three values, so that particular argument collection predicate will produce something interesting.</p><p>Jumping to <code>enhanced-sum-three</code>'s output side, we expect a vector of four numbers. Again, we'll craft our function return scalar specification to contain two predicates that we know won't be satisfied because those scalar predicates are looking for something non-numeric.</p><pre><code>[char? int? int? boolean?]</code></pre><p>Finally, since we defined <code>enhanced-sum-three</code> to return a vector, we'll make the function return collection specification look for a list.</p><pre><code>[list?]</code></pre><p>Altogether, those four specification are organized like this.</p><pre><code>{:speculoos/arg-scalar-spec     [string? int? symbol?]
 :speculoos/arg-collection-spec [#(= 2 (count %))]
 :speculoos/ret-scalar-spec     [char? int? int? boolean?]
 :speculoos/ret-collection-spec [list?]}</code></pre><p>It's time to see what we've assembled.</p><pre><code>(validate-fn-with enhanced-sum-three
                  {:speculoos/arg-scalar-spec [string? int? symbol?],
                   :speculoos/arg-collection-spec [length-2?],
                   :speculoos/ret-scalar-spec [char? int? int? boolean?],
                   :speculoos/ret-collection-spec [list?]}
                  1
                  20
                  300)
;; => ({:datum 1,
;;      :fn-spec-type :speculoos/argument,
;;      :path [0],
;;      :predicate string?,
;;      :valid? false}
;;     {:datum 300,
;;      :fn-spec-type :speculoos/argument,
;;      :path [2],
;;      :predicate symbol?,
;;      :valid? false}
;;     {:datum [1 20 300],
;;      :fn-spec-type :speculoos/argument,
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate length-2?,
;;      :valid? false}
;;     {:datum 1,
;;      :fn-spec-type :speculoos/return,
;;      :path [0],
;;      :predicate char?,
;;      :valid? false}
;;     {:datum 321,
;;      :fn-spec-type :speculoos/return,
;;      :path [3],
;;      :predicate boolean?,
;;      :valid? false}
;;     {:datum [1 20 300 321],
;;      :fn-spec-type :speculoos/return,
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate list?,
;;      :valid? false})</code></pre><p>We've certainly made a mess of things. But it'll be understandable if we examine the invalidation report piece by piece. The first thing to know is that we have already seen each of those validations before in the previous examples, so we could always scroll back to those examples above and see the validations in isolation.</p><p>We see six non-satisfied predicates:<ul><li>Scalar <code>1</code> in the arguments sequence fails to satisfy scalar predicate <code>string?</code> in the argument scalar specification.</li><li>Scalar <code>300</code> in the arguments sequence fails to satisfy scalar predicate <code>symbol?</code> in the argument scalar specification.</li><li>The argument sequence <code>[1 20 300]</code> fails to satisfy collection predicate <code>length-2?</code> in the argument collection specification.</li><li>Scalar <code>1</code> in the return vector fails to satisfy scalar predicate <code>char?</code> in the return scalar specification.</li><li>Scalar <code>321</code> in the return vector fails to satisfy scalar predicate <code>boolean?</code> in the return scalar specification.</li><li>The return vector <code>[1 20 300 321]</code> fails to satisfy collection predicate <code>list?</code> in the return collection specification.</li></ul></p><p>Also note that the validation entries have a <code>:fn-spec-type</code> entry associated to either <code>:speculoos/return</code> or <code>:speculoos/argument</code>, which tells us where a particular invalid was located. There may be a situation where indistinguishable invalid datums appear in both the arguments and returns. In this case, integer <code>1</code> was an invalid datum at path <code>[0]</code> for both the argument sequence and the return vector. Keyword <code>:fn-spec-type</code> helps resolve the ambiguity.</p><h3 id="fn-correctness">3. Validating Function Correctness</h3><p>So far, we've seen how to validate function argument sequences and function return values, both their scalars, and their collections. Validating function argument sequences allows us to check if the function was invoked properly. Validating function return values gives a limited ability to check the internal operation of the function.</p><p> If we want another level of thoroughness for checking correctness, we can specify and validate the relationships between the functions arguments and return values. Perhaps we'd like to be able to express <em>The return value is a collection, with all the same elements as the input sequence.</em> Or <em>The return value is a concatenation of the even indexed elements of the input sequence.</em> Speculoos' term for this action is <em>validating function argument and return value relationship</em>.</p><p>Let's pretend I wrote a reversing function, which accepts a sequential collection of elements and returns those elements in reversed order. If we give it…</p><pre><code>[11 22 33 44 55]</code></pre><p>…my reversing function ought to return…</p><pre><code>[55 44 33 22 11]</code></pre><p>Here are some critical features of that process that relate the reversing function's arguments to its return value.</p><ul><li>The return collection is the same length as the input collection.</li><li>The return collection contains all the same elements as the input collection.</li><li>The elements of the return collection appear in reverse order from their positions in the input collection.</li></ul><p>Oops. I must've written it before I had my morning coffee.</p><pre><code>(defn broken-reverse [v] (conj v 9999))</code><br><br><code>(broken-reverse [11 22 33 44 55]) ;; => [11 22 33 44 55 9999]</code></pre><p>Pitiful. We can see by eye that <code>broken-reverse</code> fulfilled none of the three relationships. The return collection is not the same length, contains additional elements, and is not reversed. Let's codify that pitifulness.</p><p>First, we'll write three <a href="#relationship">relationship functions</a>. Relationship functions are a lot like predicates. They return a truthy or falsey value, but instead consume two things instead of one. The function's argument sequence is passed as the first thing and the function's return value is passed as the second thing.</p><pre><code>(defn same-length? [v1 v2] (= (count v1) (count v2)))</code><br><br><code>(same-length? [11 22 33 44 55]
              [11 22 33 44 55]) ;; => true</code><br><br><code>(same-length? [11 22]
              [11 22 33 44 55]) ;; => false</code><br><br><br><br><code>(defn same-elements? [v1 v2] (= (sort v1) (sort v2)))</code><br><br><code>(same-elements? [11 22 33 44 55]
                [55 44 33 22 11]) ;; => true</code><br><br><code>(same-elements? [11 22 33 44 55]
                [55 44 33 22 9999]) ;; => false</code><br><br><br><br><code>(defn reversed? [v1 v2] (= v1 (reverse v2)))</code><br><br><code>(reversed? [11 22 33 44 55]
           [55 44 33 22 11]) ;; => true</code><br><br><code>(reversed? [11 22 33 44 55]
           [11 22 33 44 55]) ;; => false</code></pre><p><code>same-length?</code>, <code>same-element?</code>, <code>reversed?</code> all consume two sequential things and test a relationship between the two. If their relationship is satisfied, they signal <code>true</code>, if not, then they signal <code>false</code>. They are all three gonna have something unkind to say about <code>broken-reverse</code>.</p><p>Now that we've established a few relationships, we need to establish <em>where</em> to apply those relationship tests. Checking <code>broken-reverse</code>'s argument/return relationships with <code>same-length?</code>, <code>same-elements?</code>, and <code>reversed?</code> will be fairly straightforward: For each, there's a single argument collection of elements, and a single return collection of elements. But we might someday want to check a more sophisticated relationship that needs to extract some slice of the argument or return value. Therefore, we must declare a path to the slices we want to check. Of the return value, we'd like to check the root collection, so the return value's path is merely <code>[]</code>.</p><p>When we consider how to extract the arguments, there's one tricky detail we must accommodate. The <code>[11 22 33 44 55]</code> vector we're going to pass to <code>broken-reverse</code> is itself contained in the argument sequence. Take a look.</p><pre><code>(defn arg-passthrough [& args] args)</code><br><br><code>(arg-passthrough [11 22 33 44 55]) ;; => ([11 22 33 44 55])</code></pre><p>To extract <code>[11 22 33 44 55]</code>, the path will need to be <code>[0]</code>.</p><pre><code>(nth (arg-passthrough [11 22 33 44 55]) 0) ;; => [11 22 33 44 55]</code></pre><p>When invoked, <code>validate-argument-return-relationship</code> does something like this.</p><pre><code>(same-length? (get-in [[11 22 33 44 55]] [0])
              (get-in [11 22 33 44 55 9999] []))
;; => false</code></pre><p>So here are the components to a single argument/return relationship validation.</p><ul><li>A path to the interesting slice of the arguments. Example: <code>[0]</code></li><li>A path to the interesting slice of the return value. Example: <code>[]</code></li><li>A relationship function. Example: <code>same-length?</code></li></ul><p>We stuff all three of those items into a map, which will be used for a single relationship validation.</p><pre><code>{:path-argument [0]
 :path-return []
 :relationship-fn same-length?}</code></pre><p>Within that map, both <code>:path-…</code> entries govern what slices of the argument and return are given to the relationship function. In this example, we want to extract the first item, at path <code>[0]</code>, of the argument sequence and the entire return value, at path <code>[]</code>.</p><p>We've written three argument/function relationships to test <code>broken-reverse</code>, so we'll need to somehow feed them to <code>validate-fn-with</code>. We do that by associating them into the organizing map with keyword <code>:speculoos/argument-return-relationships</code>. Notice the plural <em>s</em>. Since there may be more than one relationship, we collect them into a vector. For the moment, let's insert only the <code>same-length?</code> relationship.</p><pre><code>{:speculoos/argument-return-relationships [{:path-argument [0]
                                            :path-return []
                                            :relationship-fn same-length?}]}</code></pre><p>Eventually, we'll test all three relationships, but for now, we'll focus on <code>same-length?</code>.</p><p>We're ready to validate.</p><pre><code>(validate-fn-with
  broken-reverse
  {:speculoos/argument-return-relationships
     [{:path-argument [0],
       :path-return [],
       :relationship-fn same-length?}]}
  [11 22 33 44 55])
;; => ({:datum-argument [11 22 33 44 55],
;;      :datum-return [11 22 33 44 55 9999],
;;      :fn-spec-type :speculoos/argument-return-relationship,
;;      :path-argument [0],
;;      :path-return [],
;;      :relationship-fn same-length?,
;;      :valid? false})</code></pre><p>We supplied <code>broken-reverse</code> with a five-element vector, and it returned a six-element vector, failing to satisfy the specified <code>same-length?</code> relationship.</p><p>We wrote two other relationship functions, but <code>same-elements?</code> and <code>reversed?</code> are merely floating around in the current namespace. We did not send them to <code>validate-fn-with</code>, so it checked only <code>same-length?</code>, which we explicitly supplied. Remember Motto #3: Un-paired predicates (or, relationships in this instance) are ignored.</p><p>Let's check all three relationships now.</p><pre><code>(validate-fn-with
  broken-reverse
  {:speculoos/argument-return-relationships
     [{:path-argument [0],
       :path-return [],
       :relationship-fn same-length?}
      {:path-argument [0],
       :path-return [],
       :relationship-fn same-elements?}
      {:path-argument [0],
       :path-return [],
       :relationship-fn reversed?}]}
  [11 22 33 44 55])
;; => ({:datum-argument [11 22 33 44 55],
;;      :datum-return [11 22 33 44 55 9999],
;;      :fn-spec-type :speculoos/argument-return-relationship,
;;      :path-argument [0],
;;      :path-return [],
;;      :relationship-fn same-length?,
;;      :valid? false}
;;     {:datum-argument [11 22 33 44 55],
;;      :datum-return [11 22 33 44 55 9999],
;;      :fn-spec-type :speculoos/argument-return-relationship,
;;      :path-argument [0],
;;      :path-return [],
;;      :relationship-fn same-elements?,
;;      :valid? false}
;;     {:datum-argument [11 22 33 44 55],
;;      :datum-return [11 22 33 44 55 9999],
;;      :fn-spec-type :speculoos/argument-return-relationship,
;;      :path-argument [0],
;;      :path-return [],
;;      :relationship-fn reversed?,
;;      :valid? false})</code></pre><p><code>broken-reverse</code> is truly broken. The <code>same-length?</code> result appears again, and then we see the two additional unsatisfied relationships because we added <code>same-elements?</code> and <code>reversed?</code>. <code>broken-reverse</code> returns a vector with more and different elements, and the order is not reversed.</p><p>Just for amusement, let's see what happens when we validate <code>clojure.core/reverse</code> with the exact same relationship specifications.</p><pre><code>(reverse [11 22 33 44 55]) ;; => (55 44 33 22 11)</code><br><br><code>(validate-fn-with
  reverse
  {:speculoos/argument-return-relationships
     [{:path-argument [0],
       :path-return [],
       :relationship-fn same-length?}
      {:path-argument [0],
       :path-return [],
       :relationship-fn same-elements?}
      {:path-argument [0],
       :path-return [],
       :relationship-fn reversed?}]}
  [11 22 33 44 55])
;; => (55 44 33 22 11)</code></pre><p><code>clojure.core/reverse </code> satisfies all three argument/return relationships, so <code>validate-fn-with</code> passes through the correctly-reversed output.</p><p>Not every function consumes a collection. Some functions consume a scalar value. Some functions return a scalar. And some functions have the audacity to do both. <code>validate-fn-with</code> can validate that kind of argument/return relationship. </p><p>I'll warn you now, I'm planning on writing a buggy increment function. We could express two ideas about the argument/return relationship. First, a correctly-working increment function, when supplied with a number, <code>n</code>, ought to return a number that is larger than <code>n</code>. Second, a correctly-working return value ought to be <code>n</code> plus one. Let's specify those relationships.</p><pre><code>(defn larger-than? [n1 n2] (< n1 n2))</code><br><br><code>(larger-than? 99 100) ;; => true</code><br><code>(larger-than? 99 -99) ;; => false</code><br><br><br><code>(defn plus-one? [n1 n2] (= (+ n1 1) n2))</code><br><br><code>(plus-one? 99 100) ;; => true</code><br><code>(plus-one? 99 -99) ;; => false</code></pre><p>Validating argument/return relationships requires us to declare which parts of the argument sequence and which parts of the return value to send to the relationship function. When we invoke the increment function with a single number, the number lives in the first spot of the argument sequence, so it will have a path of <code>[0]</code>. The increment function will return a 'bare' number, so a path is not really an applicable concept. We <a href="#nil">previously saw</a> how a <code>nil</code> path indicates a bare scalar, so now we can assemble the two relationship maps, one each for <code>larger-than?</code> and <code>plus-one?</code>.</p><pre><code>{:path-argument [0]
 :path-return nil
 :relationship-fn larger-than?}</code><br><br><code>{:path-argument [0]
 :path-return nil
 :relationship-fn plus-one?}</code></pre><p>Now is a good time to write the buggy incrementing function.</p><pre><code>(defn buggy-inc [n] (- n))</code><br><br><code>(buggy-inc 99) ;; => -99</code></pre><p>Looks plenty wrong. Let's see exactly how wrong.</p><pre><code>(validate-fn-with
  buggy-inc
  {:speculoos/argument-return-relationships
     [{:path-argument [0],
       :path-return nil,
       :relationship-fn larger-than?}
      {:path-argument [0],
       :path-return nil,
       :relationship-fn plus-one?}]}
  99)
;; => ({:datum-argument 99,
;;      :datum-return -99,
;;      :fn-spec-type
;;        :speculoos/argument-return-relationship,
;;      :path-argument [0],
;;      :path-return nil,
;;      :relationship-fn larger-than?,
;;      :valid? false}
;;     {:datum-argument 99,
;;      :datum-return -99,
;;      :fn-spec-type
;;        :speculoos/argument-return-relationship,
;;      :path-argument [0],
;;      :path-return nil,
;;      :relationship-fn plus-one?,
;;      :valid? false})</code></pre><p><code>buggy-inc</code>'s return value failed to satisfy both relationships with its argument. <code>-99</code> is not larger than <code>99</code>, nor is it what we'd get by adding one to <code>99</code>.</p><p>Just to verify that our relationships are doing what we think they're doing, let's run the same thing on <code>clojure.core/inc</code>.</p><pre><code>(validate-fn-with
  inc
  {:speculoos/argument-return-relationships
     [{:path-argument [0],
       :path-return nil,
       :relationship-fn larger-than?}
      {:path-argument [0],
       :path-return nil,
       :relationship-fn plus-one?}]}
  99)
;; => 100</code></pre><p><code>inc</code> correctly returns <code>100</code> when invoked with <code>99</code>, so both <code>larger-than?</code> and <code>plus-one?</code> relationships are satisfied. Since all relationships were satisfied, the return value <code>100</code> passes through.</p><p>So far, the <code>:path-argument</code>s and the <code>path-return</code>s have been similar between relationship specifications, but they don't need to be. I'm going to invent a really contrived example. <code>pull-n-put</code> and <code>pull-n-whoops</code> are both intended to pull out emails and phone numbers and stuff them into some output vectors. <code>pull-n-put</code> is correct, <code>pull-n-whoops</code> is incorrect.</p><p>First, this is the intended result, produced by <code>pull-n-put</code>.</p><pre><code>(def person-1 {:email "aragorn@sonofarath.org", :phone "867-5309"})</code><br><code>(def person-2 {:email "vita@meatavegam.info", :phone "123-4567"})</code><br><code>(def person-3 {:email "jolene@justbecauseyou.com", :phone "555-FILK"})</code><br><br><code>;; correct implementation</code><br><code>(defn pull-n-put
  [p1 p2 p3]
  {:email-addresses [(p1 :email) (p2 :email) (p3 :email)],
   :phone-numbers [(p1 :phone) (p2 :phone) (p3 :phone)]})</code><br><br><code>;; intended results</code><br><code>(pull-n-put person-1 person-2 person-3)
;; => {:email-addresses ["aragorn@sonofarath.org"
;;                       "vita@meatavegam.info"
;;                       "jolene@justbecauseyou.com"],
;;     :phone-numbers ["867-5309" "123-4567" "555-FILK"]}</code></pre><p><code>pull-n-put</code> pulls out the email addresses and phone numbers and properly puts them in place. However…</p><pre><code>;; incorrect implementation</code><br><code>(defn pull-n-whoops
  [p1 p2 p3]
  {:email-addresses [(p1 :phone) (p2 :phone) (p3 :phone)],
   :phone-numbers [:apple :banana :mango]})</code><br><br><code>;; wrong results</code><br><code>(pull-n-whoops person-1 person-2 person-3)
;; => {:email-addresses ["867-5309" "123-4567" "555-FILK"],
;;     :phone-numbers [:apple :banana :mango]}</code></pre><p>…<code>pull-n-whoops</code> does neither. It puts the phone numbers where the email addresses ought to be and inserts completely bogus phone numbers.</p><p>We can specify a couple of relationships to show that <code>pull-n-whoops</code> produces a return value that does not validate. In a correctly-working implementation, the scalars aren't transformed, <em>per se</em>, merely moved to another location. So our relationship function will merely be equality, and the paths will do all the work.</p><p>Phone number <code>555-FILK</code> at argument path <code>[2 :phone]</code> ought to appear at return path <code>[:phone-numbers 2]</code>. That relationship specification looks like this.</p><pre><code>{:path-argument [2 :phone]
 :path-return [:phone-numbers 2]
 :relationship-fn =}</code></pre><p>Similarly, email address <code>aragorn@sonofarath.org</code> at argument path <code>[0 :email]</code> ought to appear at return path <code>[:email-addresses 0]</code>. That relationship specification looks like this.</p><pre><code>{:path-argument [0 :email]
 :path-return [:phone-numbers 0]
 :relationship-fn =}</code></pre><p>Now, we insert those two specifications into a vector and associate that vector into the organizing map.</p><pre><code>{:speculoos/argument-return-relationships [{:path-argument [2 :phone]
                                             :path-return [:phone-numbers 2]
                                             :relationship-fn =}]}
                                            {:path-argument [0 :email]
                                             :path-return [:email-addresses 0]
                                             :relationship-fn =}</code></pre><p>All that remains is to consult <code>validate-fn-with</code> to see if the relationships are satisfied. First, we'll do <code>pull-n-put</code>, which should yield the intended results.</p><pre><code>(validate-fn-with pull-n-put
                  {:speculoos/argument-return-relationships
                     [{:path-argument [2 :phone],
                       :path-return [:phone-numbers 2],
                       :relationship-fn =}
                      {:path-argument [0 :email],
                       :path-return [:email-addresses 0],
                       :relationship-fn =}]}
                  person-1
                  person-2
                  person-3)
;; => {:email-addresses
;;       ["aragorn@sonofarath.org"
;;        "vita@meatavegam.info"
;;        "jolene@justbecauseyou.com"],
;;     :phone-numbers ["867-5309" "123-4567"
;;                     "555-FILK"]}</code></pre><p>Yup. <code>pull-n-put</code>'s return value satisfied both equality relationships with the arguments we supplied, so <code>validate-fn-with</code> passed on that return value.</p><p>Now we'll validate <code>pull-n-whoops</code>, which does not produce correct results.</p><pre><code>(validate-fn-with pull-n-whoops
                  {:speculoos/argument-return-relationships
                     [{:path-argument [2 :phone],
                       :path-return [:phone-numbers 2],
                       :relationship-fn =}
                      {:path-argument [0 :email],
                       :path-return [:email-addresses 0],
                       :relationship-fn =}]}
                  person-1
                  person-2
                  person-3)
;; => ({:datum-argument "555-FILK",
;;      :datum-return :mango,
;;      :fn-spec-type
;;        :speculoos/argument-return-relationship,
;;      :path-argument [2 :phone],
;;      :path-return [:phone-numbers 2],
;;      :relationship-fn =,
;;      :valid? false}
;;     {:datum-argument
;;        "aragorn@sonofarath.org",
;;      :datum-return "867-5309",
;;      :fn-spec-type
;;        :speculoos/argument-return-relationship,
;;      :path-argument [0 :email],
;;      :path-return [:email-addresses 0],
;;      :relationship-fn =,
;;      :valid? false})</code></pre><p><code>validate-fn-with</code> tells us that <code>pull-n-whoops</code>'s output satisfies neither argument/return relationship. Where we expected phone number <code>555-FILK</code>, we see <code>:mango</code>, and where we expected email <code>aragorn@sonofarath.org</code>, we see phone number <code>867-5309</code>.</p><p>The idea to grasp from validating <code>pull-n-put</code> and <code>pull-n-whoops</code> is that even though the relationship function was a basic equality <code>=</code>, the relationship validation is precise, flexible, and powerful because we used paths to focus on exactly the relationship we're interested in. On the other hand, whatever function we put at <code>:relationship-fn</code> is completely open-ended, and can be similarly sophisticated.</p><p>Before we finish this subsection, I'd like to demonstrate how to combine all five types of validation: argument scalars, argument collections, return scalars, return collections, and argument/return relationship. We'll rely on our old friend <code>broken-reverse</code>. Let's remember what <code>broken-reverse</code> actually does.</p><pre><code>(broken-reverse [11 22 33 44 55]) ;; => [11 22 33 44 55 9999]</code></pre><p>Instead of properly reversing the argument collection, it merely appends a spurious <code>9999</code>.</p><p>We'll pass a vector as the first and only argument. Within that vector, we pretend to not care about the first two elements, so we'll use <code>any?</code> predicates as placeholders.  We'll specify the third element of that vector to be a decimal with a <code>decimal?</code> scalar predicate. The entire <em>argument sequence</em> is validated, so we must make sure the shape of the scalar specification mimics the shape of the data.</p><pre><code>:speculoos/arg-scalar-spec [[any? any? decimal?]]</code></pre><p>Just so we see an invalid result, we'll make the argument collection specification expect a list, even though we know we'll be passing a vector. And again, we must make the collection specification's shape mimic the data, so to mimic the argument sequence, it looks like this.</p><pre><code>:speculoos/arg-collection-spec [[list?]]</code></pre><p>We know that <code>broken-reverse</code> returns the input collection with <code>9999</code> conjoined. We'll write the return scalar specification to expect a string in the fourth slot, just so we'll see <code>44</code> fail to satisfy.</p><pre><code>:speculoos/ret-scalar-spec [any? any? any? string?]</code></pre><p>And since we're expecting <code>broken-reverse</code> to return a vector, we'll write the return collection specification to expect a set.</p><pre><code>:speculoos/ret-collection-spec [set?]</code></pre><p>Finally, we've previously demonstrated that <code>broken-reverse</code> fails to satisfy the <code>reversed?</code> argument/return relationship specification. We'll pass <code>reversed?</code> the first argument and the entire return.</p><pre><code>:speculoos/argument-return-relationships [{:path-argument [0]
                                           :path-return []
                                           :relationship-fn reversed?}]</code></pre><p id="messy">We assemble all five of those specifications into the organizing map, and invoke <code>validate-fn-with</code>.</p><pre><code>(validate-fn-with
  broken-reverse
  {:speculoos/arg-scalar-spec [[any? any? decimal?]],
   :speculoos/arg-collection-spec [[list?]],
   :speculoos/ret-scalar-spec [any? any? any? string?],
   :speculoos/ret-collection-spec [set?],
   :speculoos/argument-return-relationships
     [{:path-argument [0], :path-return [], :relationship-fn reversed?}]}
  [11 22 33 44 55])
;; => ({:datum 33,
;;      :fn-spec-type :speculoos/argument,
;;      :path [0 2],
;;      :predicate decimal?,
;;      :valid? false}
;;     {:datum [11 22 33 44 55],
;;      :fn-spec-type :speculoos/argument,
;;      :ordinal-path-datum [0],
;;      :path-datum [0],
;;      :path-predicate [0 0],
;;      :predicate list?,
;;      :valid? false}
;;     {:datum 44,
;;      :fn-spec-type :speculoos/return,
;;      :path [3],
;;      :predicate string?,
;;      :valid? false}
;;     {:datum [11 22 33 44 55 9999],
;;      :fn-spec-type :speculoos/return,
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate set?,
;;      :valid? false}
;;     {:datum-argument [11 22 33 44 55],
;;      :datum-return [11 22 33 44 55 9999],
;;      :fn-spec-type
;;        :speculoos/argument-return-relationship,
;;      :path-argument [0],
;;      :path-return [],
;;      :relationship-fn reversed?,
;;      :valid? false})</code></pre><p>We supplied five specifications, five datums failed to satisfy those specifications, and we receive five invalidation entries.<ul><li>Argument scalar <code>33</code> did not satisfy <code>decimal?</code>.</li><li>Argument collection <code>[11 22 33 44 55]</code> did not satisfy <code>list?</code>.</li><li>Return scalar <code>44</code> did not satisfy <code>string?</code>.</li><li>Return collection <code>[11 22 33 4  55 9999]</code> did not satisfy <code>set?</code>.</li><li>Argument <code>[11 22 33 44 55]</code> and return <code>[11 22 33 44 55 9999]</code> did not satisfy relationship <code>reversed?</code>.</li></ul></p><h3 id="recognized-metadata-keys">Recognized metadata specification keys</h3><p>Speculoos consults the following defined group of keys in a specification map when it validates.</p><pre><code>speculoos.function-specs/recognized-spec-keys
;; => [:speculoos/arg-scalar-spec
;;     :speculoos/arg-collection-spec
;;     :speculoos/ret-scalar-spec
;;     :speculoos/ret-collection-spec
;;     :speculoos/argument-return-relationships
;;     :speculoos/canonical-sample
;;     :speculoos/predicate->generator
;;     :speculoos/hof-specs]</code></pre><h3 id="explicit">Function Metadata Specifications</h3><p>Speculoos offers three patterns of function validation.<ol><li><code>validate-fn-with</code> performs explicit validation with a specification supplied in a separate map. The function var is not altered.</li><li><code>validate-fn</code> performs explicit validation with specifications contained in the function's metadata.</li><li><code>instrument</code> provides implicit validation with specifications contained in the function's metadata.</li></ol></p><p>Up until this point, we've been using the most explicit variant, <code>validate-fn-with</code> because its behavior is the most readily apparent. <code>validate-fn-with</code> is nice when we want to quickly validate a function <em>on-the-fly</em> without messing with the function's metadata. We merely supply the function's name, a map of specifications, and a sequence of arguments as if we were directly invoking the function.</p><p>Speculoos function specifications <a href="https://clojure.org/about/spec#_dont_further_add_tooverload_the_reified_namespaces_of_clojure">differ</a> from <code>spec.alpha</code> in that they are stored and retrieved directly from the function's metadata. Speculoos is an experiment, so I thought it would be nice if I could hand you one single thing and say </p><blockquote><p><em>Here's a Clojure function you can use. Its name suggests what it does, its docstring tells you how to use it, and human- and machine-readable specifications check the validity of the inputs, and tests that it's working properly. All in one neat, tidy </em>S-expression.</p></blockquote><p>To validate a function with metadata specifications, we use <code>validate-fn</code> (or as we'll <a href="#instrument">discuss later</a>, <code>instrument</code>). Speculoos offers a pair convenience functions to add and remove specifications from a function's metadata. To add, use <code>inject-specs!</code>. Let's inject a couple of function specifications to <code>sum-three</code> which we <a href="#fn-args">saw earlier</a>.</p><pre><code>(require '[speculoos.function-specs :refer
           [validate-fn inject-specs! unject-specs!]])</code><br><br><code>(inject-specs! sum-three
               {:speculoos/arg-scalar-spec [int? int? int?],
                :speculoos/ret-scalar-spec int?})
;; => nil</code></pre><p>We can observe that the specifications indeed live in the function's metadata. There's a lot of metadata, so we'll use <code>select-keys</code> to extract only the key-values associated by <code>inject-specs!</code>.</p><pre><code>(select-keys (meta #'sum-three) speculoos.function-specs/recognized-spec-keys)
;; => #:speculoos{:arg-scalar-spec [int? int? int?],
;;                :ret-scalar-spec int?}</code></pre><p>We see that <code>inject-specs!</code> injected both an argument scalar specification and a return scalar specification.</p><p>If we later decided to undo that, <code>unject-specs!</code> removes all recognized Speculoos specification entries, regardless of how they got there. For the upcoming demonstrations, though, we'll keep those specifications in <code>sum-three</code>'s metadata.</p><p>Now that <code>sum-three</code> holds the specifications in its metadata, we can try the second pattern of explicit validation pattern, using <code>validate-fn</code>. It's similar to <code>validate-fn-with</code>, except we don't have to supply the specification map; it's already waiting in the metadata. Invoked with valid arguments, <code>sum-three</code> returns a valid value.</p><pre><code>(validate-fn sum-three 1 20 300) ;; => 321</code></pre><p>Invoking <code>sum-three</code> with an invalid floating-point number, Speculoos interrupts with a validation report.</p><pre><code>(validate-fn sum-three 1 20 300.0)
;; => ({:datum 300.0,
;;      :fn-spec-type :speculoos/argument,
;;      :path [2],
;;      :predicate int?,
;;      :valid? false}
;;     {:datum 321.0,
;;      :fn-spec-type :speculoos/return,
;;      :path nil,
;;      :predicate int?,
;;      :valid? false})</code></pre><p>Scalar argument <code>300.0</code> failed to satisfy its paired scalar predicate <code>int?</code>. Also, scalar return <code>321.0</code> failed to satisfy its paired scalar predicate <code>int?</code>.</p><p>The metadata specifications are passive and have no effect during normal invocation.</p><pre><code>(sum-three 1 20 300.0) ;; => 321.0</code></pre><p>Even though <code>sum-three</code> currently holds a pair of scalar specifications within its metadata, directly invoking <code>sum-three</code> does not initiate any validation.</p><p><code>validate-fn</code> only interrupts when a predicate paired with a datum is not satisfied. If we remove all the specifications, there won't be any predicates. Let's remove <code>sum-three</code>'s metadata specifications with <code>unject-specs!</code>.</p><pre><code>(unject-specs! sum-three) ;; => nil</code><br><br><code>;; all recognized keys are removed</code><br><code>(select-keys (meta #'sum-three) speculoos.function-specs/recognized-spec-keys)
;; => {}</code></pre><p>Now that <code>sum-three</code>'s metadata no longer contains specifications, <code>validate-fn</code> will not perform any validations.</p><pre><code>(validate-fn sum-three 1 20 300.0) ;; => 321.0</code></pre><p>The return value <code>321.0</code> merely passes through because there were zero predicates.</p><p>We can try a more involved example. Let's inject that <a href="#messy">messy ball</a> of metadata specifications into <code>broken-reverse</code>.</p><pre><code>(inject-specs!
  broken-reverse
  {:speculoos/arg-scalar-spec [[any? any? decimal?]],
   :speculoos/arg-collection-spec [[list?]],
   :speculoos/ret-scalar-spec [any? any? any? string?],
   :speculoos/ret-collection-spec [set?],
   :speculoos/argument-return-relationships
     [{:path-argument [0], :path-return [], :relationship-fn reversed?}]})
;; => nil</code></pre><p>Now we double-check.</p><pre><code>(select-keys (meta #'broken-reverse)
             speculoos.function-specs/recognized-spec-keys)
;; => #:speculoos{:arg-collection-spec [[list?]],
;;                :arg-scalar-spec [[any? any? decimal?]],
;;                :argument-return-relationships [{:path-argument [0],
;;                                                 :path-return [],
;;                                                 :relationship-fn reversed?}],
;;                :ret-collection-spec [set?],
;;                :ret-scalar-spec [any? any? any? string?]}</code></pre><p>We see all five function specifications in <code>broken-reverse</code>'s metadata. <code>validate-fn</code> can now find those specifications.</p><p>Finally, we validate <code>broken-reverse</code>.</p><pre><code>(validate-fn broken-reverse [11 22 33 44 55])
;; => ({:datum 33,
;;      :fn-spec-type :speculoos/argument,
;;      :path [0 2],
;;      :predicate decimal?,
;;      :valid? false}
;;     {:datum [11 22 33 44 55],
;;      :fn-spec-type :speculoos/argument,
;;      :ordinal-path-datum [0],
;;      :path-datum [0],
;;      :path-predicate [0 0],
;;      :predicate list?,
;;      :valid? false}
;;     {:datum 44,
;;      :fn-spec-type :speculoos/return,
;;      :path [3],
;;      :predicate string?,
;;      :valid? false}
;;     {:datum [11 22 33 44 55 9999],
;;      :fn-spec-type :speculoos/return,
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate set?,
;;      :valid? false}
;;     {:datum-argument [11 22 33 44 55],
;;      :datum-return [11 22 33 44 55 9999],
;;      :fn-spec-type
;;        :speculoos/argument-return-relationship,
;;      :path-argument [0],
;;      :path-return [],
;;      :relationship-fn reversed?,
;;      :valid? false})</code></pre><p>Notice, this is the exact same validation <a href="#messy">as before</a>, but because all the messy specifications were already tucked away in the metadata, the validation invocation was a much cleaner one-liner, <br><code>(validate-fn broken-reverse [11 22 33 44 55])</code>.</p><p>Again, metadata specification have no effect when the function is directly invoked.</p><pre><code>(broken-reverse [11 22 33 44 55]) ;; => [11 22 33 44 55 9999]</code></pre><p>We never <em>unjected</em> the specifications from <code>broken-reverse</code>'s metadata, but they have no influence outside of Speculoos' function validation.</p><h3 id="instrument">Instrumenting Functions</h3><p><strong>Beware: </strong><code>instrument</code>-style function validation is very much a work in progress. The current implementation is sensitive to invocation order and can choke on multiple calls.</p><p>Until this point in our discussion, Speculoos has only performed function validation when we explicitly called either <code>validate-fn-with</code> or <code> validate-fn</code>. With those two utilities, the specifications in the metadata are passive and produce no effect, even when invoking with arguments that would otherwise fail to satisfy the specification's predicates.</p><p>Speculoos' third pattern of function validation <em>instruments</em> the function using the metadata specifications. Every direct invocation of the function itself automatically validates arguments and returns using any specification in the metadata. Let's explore function instrumentation using <code>sum-three</code> <a href="#fn-args">from earlier</a>. <code>instrument</code> will only validate with metadata specifications. First, we need to inject our specifications.</p><pre><code>(inject-specs! sum-three
               {:speculoos/arg-scalar-spec [int? int? int?],
                :speculoos/ret-scalar-spec int?})
;; => nil</code></pre><p><code>sum-three</code> now holds two scalar specifications within its metadata, but those specifications are merely sitting there, completely passive.</p><pre><code>;; valid args and return value</code><br><code>(sum-three 1 20 300) ;; => 321</code><br><br><code>;; invalid arg 300.0 and invalid return value 321.0</code><br><code>(sum-three 1 20 300.0) ;; => 321.0</code></pre><p>That second invocation above supplied an invalid argument and produced an invalid return value, according to the metadata specifications. But we didn't explicitly validate with <code>validate-fn</code>, and <code>sum-three</code> is not yet instrumented, so <code>sum-three</code> returns the computed value <code>321.0</code> without interruption.</p><p>Let's instrument <code>sum-three</code> and see what happens.</p><pre><code>(require '[speculoos.function-specs :refer [instrument unstrument]])</code><br><br><code>(instrument sum-three)</code></pre><p>Not much. We've only added the specifications to the metadata and instrumented <code>sum-three</code>. An instrumented function is only validated when it is invoked.
</p><pre><code>(sum-three 1 20 300) ;; => 321</code></pre><p>We just invoked <code>sum-three</code>, but all three integer arguments and the bare scalar return value satisfied all their predicates, so <code>321</code> passes through. Let's invoke with two integer arguments and one non-integer argument.</p><pre><code>;; arg 300.0 does not satisfy its paired predicate in the argument scalar specification,</code><br><code>;; but `sum-three` is capable of computing a return with those given inputs</code><br><br><code>(sum-three 1 20 300.0) ;; => 321.0</code></pre><p>That's interesting. In contrast to <code>validate-fn-with</code> and <code>validate-fn</code>, an instrumented function is not interrupted with an invalidation report when predicates are not satisfied. The invalidation report is instead written to <code>*out*</code>.</p><pre><code>;; validation report is written to *out*</code><br><code>(with-out-str (sum-three 1 20 300.0))</code><br><code>;; => ({:path [2], :datum 300.0, :predicate int?, :valid? false, :fn-spec-type :speculoos/argument}
</code><code>;;     {:path nil, :datum 321.0, :predicate int?, :valid? false, :fn-spec-type :speculoos/return})</code></pre><p>Speculoos will implicitly validate any instrumented function with any permutation of <a href="#recognized-metadata-keys">specifications within its metadata</a>.</p><p>When we want to revert <code>sum-three</code> back to normal, we <code>unstrument</code> it.</p><pre><code>(unstrument sum-three)</code></pre><p>Now that it's no longer instrumented, <code>sum-three</code> will yield values as normal, even if the arguments and return value do not satisfy the metadata specifications.</p><pre><code>;; valid arguments and return value</code><br><code>(sum-three 1 20 300) ;; => 321</code><br><br><code>;; one invalid argument, invalid return value</code><br><code>(sum-three 1 20 300.0) ;; => 321.0</code><br><br><code>;; nothing written to *out*</code><br><code>(with-out-str (sum-three 1 20 300.0)) ;; => ""</code></pre><h3 id="hof">Validating Higher-Order Functions</h3><p>Speculoos has a story about validating higher-order functions, too. It uses very similar patterns to first-order function validation: Put some specifications in the function's metadata with the <a href="#recognized-metadata-keys">proper, qualified keys</a>, then invoke the function with some sample arguments, then Speculoos will validate the results.</p><p>The classic <span class="small-caps">hof</span> is something like <code>(defn adder [x] #(+ x %))</code>. To make things a tad more interesting, we'll add a little flourish.</p><pre><code>(require '[speculoos.function-specs :refer [validate-higher-order-fn]])</code><br><br><code>(defn addder [x] (fn [y] (fn [z] (+ x (+ y z)))))</code><br><br><code>(((addder 7) 80) 900) ;; => 987</code></pre><p><code>addder</code> returns a function upon each of its first two invocations, and only on its third invocation does <code>addder</code> return a scalar. Specifying and validating a function object does not convey much meaning: it would merely satisfy <code>fn?</code> which isn't very interesting. So to validate a <span class="small-caps">hof</span>, Speculoos requires it to be invoked until it produces a value. So we'll supply the validator with a series of argument sequences that, when fed in order to the <span class="small-caps">hof</span>, will produce a result. For the example above, it will look like <code>[7] [80] [900]</code>.</p><p>The last task we must do is create the specification. <span class="small-caps">hof</span> specifications live in the function's metadata at key <code>:speculoos/hof-specs</code>, which is a series of nested specification maps, one nesting for each returned function. For this example, we might create this <span class="small-caps">hof</span> specification.</p><pre><code>(def addder-spec
  {:speculoos/arg-scalar-spec [string?],
   :speculoos/hof-specs {:speculoos/arg-scalar-spec [boolean?],
                         :speculoos/hof-specs
                           {:speculoos/arg-scalar-spec [char?],
                            :speculoos/ret-scalar-spec keyword?}}})</code></pre><p>Once again, for illustration purposes, we've crafted a specification composed of predicates that we know will invalidate, but will permit the function stack to evaluate to completion. (Otherwise, validation halts on exceptions.</p><p><span class="small-caps">hof</span> validation requires that the function's metadata hold the specifications. So we inject them.</p><pre><code>(inject-specs! addder addder-spec) ;; => nil</code></pre><p>And finally, we execute the validation with <code>validate-higher-order-fn</code></p><pre><code>(require '[speculoos.function-specs :refer [validate-higher-order-fn]])</code><br><br><code>(validate-higher-order-fn addder [7] [80] [900])
;; => ({:datum 7,
;;      :fn-tier :speculoos/argument,
;;      :path [0 0],
;;      :predicate string?,
;;      :valid? false}
;;     {:datum 80,
;;      :fn-tier :speculoos/argument,
;;      :path [1 0],
;;      :predicate boolean?,
;;      :valid? false}
;;     {:datum 900,
;;      :fn-tier :speculoos/argument,
;;      :path [2 0],
;;      :predicate char?,
;;      :valid? false}
;;     {:datum 987,
;;      :evaled-result 987,
;;      :fn-spec-type :speculoos/return,
;;      :fn-tier :speculoos/return,
;;      :path nil,
;;      :predicate keyword?,
;;      :valid? false})</code></pre><p>Let's step through the validation results. Speculoos validates <code>7</code> against scalar predicate <code>string?</code> and then invokes <code>addder</code> with argument <code>7</code>. It then validates <code>80</code> against scalar predicate <code>boolean?</code> and then invokes the returned function with argument <code>80</code>. It then validates <code>900</code> against scalar predicate <code>char?</code> and invokes the previously returned function with argument <code>900</code>. Finally, Speculoos validates the ultimate return value <code>987</code> against scalar predicate <code>keyword?</code>. If all the predicates were satisfied, <code>validate-higher-order-fn</code> would yield the return value of the function call. In this case, all three arguments and the return value are invalid, and Speculoos yields a validation report.</p></section><section id="exercising"><h2>Generating Random Samples and Exercising</h2><p>Before we have some fun with random samples, we must create random sample generators and put them in particular spots. Random sample generators are closely related to predicates. A predicate is a thing that can answer <em>Is the value you put in my hand an even, positive integer between ninety and one-hundred?</em> A random sample generator is a thing that says <em>I'm putting in your hand an even, positive integer between ninety and one-hundred</em>.</p><p>Starting with a quick demonstration, Speculoos can generate valid data when given a scalar specification.</p><pre><code>(require '[speculoos.utility :refer [data-from-spec]])</code><br><br><code>(data-from-spec [int? string? keyword?] :random) ;; => [107 "" :etn+Y]</code></pre><p>When dealing with the basic <code>clojure.core</code> predicates, such as <code>int?</code>, <code>string?</code>, <code>keyword?</code>, etc., Speculoos provides pre-made random sample generators that satisfy those predicates. (There are a few exceptions, due to the fact that there is not a one-to-one-to-one correspondence between scalar data types, <code>clojure.core</code> predicates, and <code>clojure.test.check</code> generators.)</p><p>Speculoos can also generate random scalar samples from predicate-like things, such as regular expressions and sets.</p><pre><code>      built-in               v--- regex        v--- set-as-a-predicate</code><br><code>      predicate ----v</code><br><code>(data-from-spec {:x int?, :y #"fo{3,6}bar", :z #{:red :green :blue}} :random)
;; => {:x -510, :y "fooobar", :z :red}</code></pre><p>When we use either a 'basic' scalar predicate, such as <code>int?</code>, a regex, or a set-as-a-predicate, Speculoos should know how to generate a valid random sample that satisfies that predicate-like thing. Within the context of generating samples or exercising, basic predicate <code>int?</code> elicits an integer, regular expression <code>#fo{3,6}</code> generates a valid string, and set-as-a-predicate <code>#{:red :green :blue}</code> emits a sample randomly drawn from that set.</p><h3 id="create-gen">Creating Sample Generators</h3><p>This document often uses 'basic' predicates like <code>int?</code> and <code>string?</code> because they're short to type and straightforward to understand. In real life, we'll want to specify our data with more precision. Instead of merely <em>An integer</em>, we'll often want to express <em>An even positive integer between ninety and one-hundred.</em> To do that, we need to create custom generators.</p><p><code>clojure.test.check</code> provides a group of powerful, flexible, generators.</p><pre><code>(require '[clojure.test.check.generators :as gen])</code><br><br><code>(gen/generate (gen/large-integer* {:min 700, :max 999})) ;; => 701</code><br><br><code>(gen/generate gen/keyword) ;; => :C*36</code><br><br><code>(gen/generate gen/string-alphanumeric) ;; => "CPh707t393"</code></pre><h3 id="access-gen">Storing and Accessing Sample Generators</h3><p>The custom generators we discussed in the previous subsection are merely floating around in the ether. To use them for exercising, we need to put those generators in a spot that Speculoos knows: the predicate's metadata.</p><p>Let's imagine a scenario. We want a predicate that specifies an integer between ninety (inclusive) and one-hundred (exclusive) and a corresponding random sample generator. First, we write the predicate, something like this.</p><pre><code>(fn [n] (and (int? n) (<= 90 n 99)))</code></pre><p>Second, we write our generator.</p><pre><code>;; produce ten samples</code><code>(gen/sample (gen/large-integer* {:min 90, :max 99}))
;; => (90 90 91 90 92 91 95 94 90 97)</code><br><br><code>;; produce one sample</code><br><code>(gen/generate (gen/large-integer* {:min 90, :max 99})) ;; => 95</code></pre><p>To make the generator invocable, we'll wrap it in a function.</p><pre><code>(defn generate-nineties
  []
  (gen/generate (gen/large-integer* {:min 90, :max 99})))</code><br><br><code>;; invoke the generator</code><br><code>(generate-nineties) ;; => 90</code></pre><p>Third, we need to associate that generator into the predicate's metadata. We have a couple of options. The manual option uses <code>with-meta</code> during binding a name to the function body. We'll associate <code>generate-nineties</code> to the predicate's <a href="#recognized-metadata-keys">metadata key</a> <code>:speculoos/predicate->generator</code>.</p><pre><code>(def nineties?
  (with-meta (fn [n] (and (int? n) (<= 90 n 99)))
    {:speculoos/predicate->generator generate-nineties}))</code><br><br><code>(nineties? 92) ;; => true</code><br><br><code>(meta nineties?) ;; => #:speculoos{:predicate->generator generate-nineties}</code></pre><p>That gets the job done, but the manual option is kinda cluttered. The other option involves a Speculoos utility, <code>defpred</code>, that <strong>def</strong>ines a <strong>pred</strong>icate much the same as <code>defn</code>, but associates the generator with less keyboarding than the <code>with-meta</code> option. Supply a symbol, a predicate function body, and a random sample generator.</p><pre><code>(require '[speculoos.utility :refer [defpred]])</code><br><br><code>(defpred NINEties? (fn [n] (and (int? n) (<= 90 n 99))) generate-nineties)</code><br><br><code>(NINEties? 97) ;; => true</code><br><br><code>(meta NINEties?)
;; => #:speculoos{:canonical-sample :NINEties?-canonical-sample,
;;                :predicate->generator generate-nineties}</code></pre><p><code>defpred</code> automatically puts <code>generate-nineties</code> into the predicate <code>NINEties?</code> metadata. <a href="#auto-sample">Soon</a>, we'll discuss another couple of benefits to using <code>defpred</code>. Whichever way we accomplished getting the generator into the metadata at <code>:speculoos/predicate->generator</code>, Speculoos can now find it.</p><p>Speculoos uses function metadata for two purposes, and it's important to keep clear in our minds which is which.<ul><li><p>Store <em>function specifications</em> in the metadata for that function. For example, if we have a <code>reverse</code> function, we put the specification to test <code>equal-lengths?</code> in the metadata at <code>:speculoos/argument-return-relationships</code>.</p></li><li><p>Store <em>random sample generators</em> in the metadata for that predicate. If we have a <code>nineties?</code> predicate, we put the random sample generator <code>generate-nineties</code> in the metadata at <code>:speculoos/predicate->generator</code>.</p></li></ul></p><h3 id="auto-sample">Creating Sample Generators Automatically</h3><p><code>defpred</code> does indeed relieve us of some tedious keyboarding, but it offers another benefit. If we arrange the predicate definition according to <code>defpred</code>'s expectations, it can automatically create a random sample generator for that predicate. Let's see it in action and then we'll examine the details.</p><pre><code>(defpred auto-nineties? (fn [n] (and (int? n) (<= 90 n 99))))</code><br><br><code>(meta auto-nineties?)
;; => #:speculoos{:canonical-sample :auto-nineties?-canonical-sample,
                  :predicate->generator #fn--88795}</code></pre><p>Well, there's certainly <em>something</em> at <code>:speculoos/predicate->generator</code>, but is it anything useful?</p><pre><code>(binding [speculoos.utility/*such-that-max-tries* 1000]
  (let [possible-gen-90 (:speculoos/predicate->generator (meta auto-nineties?))]
    (possible-gen-90)))
;; => 94</code></pre><p>Yup! Since it is not-so-likely that a random integer generator would produce a value in the nineties, we bound the <code>max-tries</code> to a high count to give the generator lots of attempts. We then pulled out the generator from predicate <code>auto-nineties?</code>'s metadata and bound it to <code>possible-gen-90</code>. Then we invoked <code>possible-gen-90</code> and, in fact, it generated an integer in the nineties that satisfies the original predicate we defined as <code>auto-nineties</code>.<code>defpred</code> automatically created a random sample generator whose output satisfies the predicate.</p><p>For <code>defpred</code> to do its magic, the predicate definition must follow a few patterns.</p><ul><li>We must provide the textual representation of the definition. We can't merely assign another already-defined function.</li><li>The first symbol must be <code>and</code>, <code>or</code>, or a basic predicate for a Clojure built-in scalar, such as <code>int?</code>, that is registered at <code>speculoos.utility/predicate->generator</code>.<pre><code>(and (...)) ;; okay</code><br><code>(or (...)) ;; okay</code><br><code>(int? ...) ;; okay</code><br><code>(let ...) ;; not okay</code><br></pre></li><li>The first clause after <code>and</code> and all immediate descendants of <code>or</code> must start with a basic predicate described above.</li></ul><p>Subsequent clauses of <code>and</code> will be used to create <code>test.check.generators/such-that</code> modifiers. Direct descendants of a top-level <code>or</code> will produce<code>n</code> separate random sample generators, each with <code>1/n</code> probability.</p><p>Speculoos exposes the internal tool <code>defpred</code> uses to create a generator, so we can inspect how it works. (I've lightly edited the output for clarity.)</p><pre><code>(require '[speculoos.utility :refer [inspect-fn]])</code><br><br><code>(inspect-fn '(fn [i] (int? i)))</code><br><code>;; => gen/small-integer</code></pre><p>We learn that <code>inspect-fn</code> examines the textual representation of the predicate definition, extracts <code>int?</code> and infers that the base generator ought to be <code>gen/small-integer</code>. Next, we'll add a couple of modifiers with <code>and</code>. <code>int?</code> is in the first clause. (Again, lightly edited.)</p><pre><code>(inspect-fn '(fn [i] (and (int? i) (even? i) (pos? i))))</code><br><code>;; => (gen/such-that (fn [i] (and (even? i) (pos? i)))
;;       gen/small-integer {:max-tries speculoos.utility/*such-that-max-tries*}) </code></pre><p><code>int?</code> elicits a small-integer generator. <code>inspect-fn</code> then uses the subsequent clauses of the <code>and</code> expression to create a <code>such-that</code> modifier that generates only positive, even numbers.</p><p>Let's see what happens with an <code>or</code>.</p><pre><code>(inspect-fn '(fn [x] (or (int? x) (string? x))))</code><br><code>;; => (gen/one-of [gen/small-integer gen/string-alphanumeric])</code></pre><p>Our predicate definition is satisfied with either an integer or a string. <code>inspect-fn</code> therefore creates a generator that will produce either an integer or a string with equal probability.</p><p>When automatically creating random sample generators, <code>defpred</code> handles nesting up to two levels deep. Let's see how we might combine both <code>or</code> and <code>and</code>. We'll define a predicate that tests for either an odd integer, a string of at least three characters, or a ratio greater than one-ninth.</p><pre><code>(defpred combined-pred
         #(or (and (int? %) (odd? %))
              (and (string? %) (<= 3 (count %)))
              (and (ratio? %) (< 1/9 %))))</code><br><br><code>(data-from-spec {:a combined-pred,
                 :b combined-pred,
                 :c combined-pred,
                 :d combined-pred,
                 :e combined-pred,
                 :f combined-pred,
                 :g combined-pred,
                 :h combined-pred,
                 :i combined-pred}
                :random)
;; => {:a -27,
;;     :b 1/2,
;;     :c "V393nGGMdz0oMHdAW9m5eF7Sr0",
;;     :d "NCv66N5RI5Nl5f53jnPX",
;;     :e 15/16,
;;     :f 17,
;;     :g "uEiM0ACx0FZc5my8NR6BBX5j",
;;     :h "G7es3z6z4688X52gQ4Yku896VYy",
;;     :i "DaPiQf4SMp6IyLH"}</code></pre><p>We're kinda abusing <code>data-from-spec</code> here to generate nine samples. Inferring from <code>combined-pred</code>'s predicate structure, <code>defpred</code>'s automatically-created random sample generator emits one of three elements with equal probability: an odd integer, a string of at least three characters, or a ratio greater than one-ninth. All we had to do was write the predicate; <code>defpred</code> wrote all three random sample generators.</p><h3 id="test-gen">Testing Sample Generators Residing in Metadata</h3><p>Some scenarios block us from using <code>defpred</code>'s automatic generators. We may not have access to the textual representation of the predicate definition. Or, sometimes we must hand-write a generator because a naive generator would be unlikely to find a satisfying value (e.g., a random number that must fall within a narrow range).</p><p>The Write-generator-then-Apply-to-metadata-then-Test loop can be tedious, so the <code>utility</code> namespace provides a tool to help. <code>validate-predicate->generator</code> accepts a predicate function we supply, extracts the random sample generator residing in its metadata, generates a sample, and then feeds that sample back into the predicate to see if it satisfies.</p><pre><code>(require '[speculoos.utility :refer [validate-predicate->generator]])</code><br><br><code>(defpred pred-with-incorrect-generator
         (fn [i] (int? i))
         #(gen/generate gen/ratio))</code><br><br><code>(validate-predicate->generator pred-with-incorrect-generator)
;; => ([19/28 false]
;;     [-24/13 false]
;;     [-11/29 false]
;;     [-1 true]
;;     [-1/5 false]
;;     [10/19 false]
;;     [5/2 false])</code></pre><p>We defined scalar predicate <code>pred-with-incorrect-generator</code> to require an integer, but, using <code>defpred</code>, we manually created a generator that emits ratio values. Each of the generated samples fails to satisfy the <code>int?</code> predicate.</p><p>With help from <code>validate-predicate->generator</code>, we can hop back and forth to adjust the hand-made generator.</p><pre><code>(defpred pred-with-good-generator
         (fn [i] (int? i))
         #(gen/generate gen/small-integer))</code><br><br><code>(validate-predicate->generator pred-with-good-generator)
;; => ([-2 true]
;;     [5 true]
;;     [15 true]
;;     [-29 true]
;;     [16 true]
;;     [6 true]
;;     [-26 true])</code></pre><p>In this particular case, we could have relied on <code>defpred</code> to <a href="#auto-sample">create a sample generator</a> for us.</p><p>Pretend somebody hands us a specification. It might be useful to know if we need to write a random sample generator for any of the predicates it contains, or if Speculoos can find a generator for all of them, either in the collection of known predicates-to-generators associations, or in the predicates' metadata. <code>unfindable-generators</code> tells us this information.</p><p>Let's compose a scalar specification containing <code>int?</code>, a set-as-a-predicate <code>#{:red :green :blue}</code>, and a regular expression <code>#"fo{2,5}"</code>.</p><pre><code>(require '[speculoos.utility :refer [unfindable-generators]])</code><br><br><code>(unfindable-generators [int? #{:red :green :blue} #"fo{2,5}"]) ;; => []</code></pre><p>Speculoos knows how to create random samples from all three of those predicate-like things, so <code>unfindable-generators</code> returns an empty vector, <em>nothing unfindable</em>. Now, let's make a scalar specification with three predicates that intentionally lack generators.</p><pre><code>(def a? (fn [] 'a))</code><br><code>(def b? (fn [] 'b))</code><br><code>(def c? (fn [] 'c))</code><br><br><code>(unfindable-generators [a? b? c?])
;; => [{:path [0], :value a?}
;;     {:path [1], :value b?}
;;     {:path [2], :value c?}]</code></pre><p><code>unfindable-generators</code> informs us that if we had tried to do a task that <a href="#using-gen">uses a sample generator</a>, we'd have failed. With this knowledge, we could go back and add random sample generators to <code>a?</code>, <code>b?</code>, and <code>c?</code>.</p><h3 id="using-gen">Using Sample Generators</h3><p>Speculoos can do three things with random sample generators.<ul><li>Create a heterogeneous, arbitrarily-nested data structure when given a scalar specification.</li><li>Exercise a scalar specification.</li><li>Exercise a function with a scalar specification.</li></ul></p><p>The first, creating a valid set of data from a given scalar specification, provides the foundation of the later two exercising functions, so we'll begin with <code>data-from-spec</code>.</p><p>Imagine we'd like to specify the scalars contained within a vector to be an integer, followed by a ratio, followed by a double-precision floating-point number. We've seen <a href="#scalar-validation">how to compose that scalar specification</a>. Let's give that scalar specification to <code>data-from-spec</code>.</p><pre><code>(require '[speculoos.utility :refer [data-from-spec]])</code><br><br><code>(data-from-spec [int? ratio? double?] :random) ;; => [-882 17/28 2.984375]</code></pre><p>That scalar specification contains three predicates, and each of those predicates targets a basic Clojure numeric type, so Speculoos automatically refers to <code>test.check</code>'s generators to produce a random sample.</p><p>Let's try another example. The scalar specification will be a map with three keys associated with predicates for a character, a set-as-a-predicate, and a regex-predicate.</p><pre><code>(data-from-spec {:x char?,
                 :y #{:red :green :blue},
                 :z #"fo{3,5}bar"}
                :random)
;; => {:x \g,
;;     :y :red,
;;     :z "fooooobar"}</code></pre><p>Again, without any further assistance, <code>data-from-spec</code> knew how to find or create a random sample generator for each predicate in the scalar specification. <code>char?</code> targets a basic Clojure type, so it generated a random character. Sets in a scalar specification, in this context, are considered a membership predicate. The random sample generator is merely a random selection of one of the members. Finally, Speculoos regards a regular expression as a predicate for validating strings. <code>data-from-spec</code> consults the <a href="https://github.com/weavejester/re-rand"><code>re-rand</code></a> library to generate a random string from the regular expression.</p><p>If our scalar specification contains custom predicates, we'll have to provide a little more information. We'll make another scalar specification containing a positive, even integer…</p><pre><code>(defpred pos-even-int? (fn [i] (and (int? i) (pos? i) (even? i))))</code></pre><p>…relying on <code>defpred</code>'s predicate inspection machinery to infer a generator. After making our <code>pos-even-int?</code> predicate, we'll make a predicate satisfied by a three-character string, <code>(fn [s] (and (string? s) (= 3 (count s))))</code>. The generator which <code>defpred</code> would create for that predicate is kinda naive.</p><pre><code>(inspect-fn '(fn [s] (and (string? s) (= 3 (count s)))))</code><br><code>;; => (gen/such-that (fn [s] (and (= 3 (count s)))) gen/string-alphanumeric)</code><br><code>;; …output elided…</code></pre><p>That naive generator would produce random strings of random lengths until it found one exactly three characters long. It's possible it would fail to produce a valid value before hitting the <code>max-tries</code> limit. However, we can explicitly write a generator and attach it with <code>defpred</code>.</p><pre><code>(defpred three-char-string?
         (fn [s] (and (string? s) (= 3 (count s))))
         #(clojure.string/join (gen/sample gen/char-alphanumeric 3)))</code></pre><p>Now that we have two scalar predicates with custom sample generators — one created by <code>defpred</code>, one created by us — we'll bring them together into a single scalar specification and invoke <code>data-from-spec</code>.</p><pre><code>(data-from-spec [pos-even-int? three-char-string?] :random) ;; => [20 "J4c"]</code></pre><p><code>data-from-spec</code> generates a valid data set whose randomly-generated scalars satisfy the scalar specification. In fact, we can feed the generated data back into the specification and it ought to validate <code>true</code>.</p><pre><code>(speculoos.core/valid-scalars? (data-from-spec [int? ratio? double?])
                               [int? ratio? double?])
;; => true</code></pre><p>Perhaps it would be nice to do that multiple times in a row: generate some random data from a specification and feed it back into the specification to see if it validates. Don't go off and write your own utility. Speculoos can <em>exercise</em> a scalar specification.</p><pre><code>(require '[speculoos.utility :refer [exercise]])</code><br><br><code>(exercise [int? ratio? double?])
;; => ([[-870 -13/5 -1.1201171875] true]
;;     [[56 29/3 1.573028564453125] true]
;;     [[-263 31/7 47.453967571258545] true]
;;     [[578 -12/23 0.00439453125] true]
;;     [[-832 13/28 0.04587364196777344] true]
;;     [[-624 -8/13 5.6435546875] true]
;;     [[-379 7/3 117.0] true]
;;     [[-113 -1/7 0.014893312356434762] true]
;;     [[-313 11/8 0.0625] true]
;;     [[-252 -7/15 -0.026168928248807788] true])</code></pre><p>Ten times, <code>exercise</code> generated a vector containing an integer, ratio, and double-precision numbers, then performed a scalar validation using those random samples as the data and the original scalar specification. In each of those ten runs, we see that <code>exercise</code> generated valid, <code>true</code> data.</p><p>So now we've seen that Speculoos can repeatedly generate random valid data from a scalar specification and run a validation of that random data. If we have injected an argument scalar specification into a function's metadata, Speculoos can repeatedly generate specification-satisfying arguments and repeatedly invoke that function.</p><p>We revisit our friend, <code>sum-three</code>, a function which accepts three numbers and sums them. That scalar specification we've been using mimics the shape of the argument sequence, so let's inject it into <code>sum-three</code>'s metadata.</p><pre><code>(defn sum-three [x y z] (+ x y z))</code><br><br><code>(inject-specs! sum-three {:speculoos/arg-scalar-spec [int? ratio? double?]})
;; => nil</code></pre><p><code>sum-three</code> is certainly capable of summing any three numbers we feed it, but just for fun, we specify that the arguments ought to be an integer, a ratio, and a double-precision number. Now that we've defined our function and added an argument scalar specification, let's exercise <code>sum-three</code>.</p><pre><code>(require '[speculoos.function-specs :refer [exercise-fn]])</code><br><br><code>(exercise-fn sum-three)
;; => ([[-772 26/5 ##-Inf] ##-Inf]
;;     [[-971 -25/31 -2.625] -974.4314516129032]
;;     [[-383 9/11 128.0] -254.1818181818182]
;;     [[872 -11/4 30.225574016571045] 899.475574016571]
;;     [[727 1/3 1.8125] 729.1458333333333]
;;     [[686 29/24 0.0302734375] 687.2386067708333]
;;     [[-19 8/3 41.3503839969635] 25.017050663630172]
;;     [[131 3/13 -0.04653525352478027] 131.18423397724442]
;;     [[-66 -13/6 4.9375] -63.22916666666667]
;;     [[-831 -2/29 -0.39720791578292847] -831.4661734330243])</code></pre><p><code>int?</code>, <code>ratio?</code>, and <code>double?</code> all have built-in generators, so we didn't have to create any custom generators. <code>exercise-fn</code> extracted <code>sum-three</code>'s argument scalar specification, then, ten times, generated a data set from random sample generators, then invoked the function with those arguments.</p><h3 id="canonical">Canonical Samples</h3><p>Sometimes it might be useful that a generated value be predictable. Perhaps we're writing documentation, or making a presentation, and we'd like the values to be aesthetically pleasing. Or, sometimes during development, it's nice to be able to quickly eyeball a known value.</p><p>Speculoos provides a canonical sample for many of Clojure's fundamental scalars when the relevant functions are invoked with the <code>:canonical</code> option. Here we use <code>data-from-spec</code> to illustrate the built-in canonical values of six of the basic scalars.</p><pre><code>(data-from-spec {:x int?,
                 :y char?,
                 :z string?,
                 :w double?,
                 :q ratio?,
                 :v keyword?}
                :canonical)
;; => {:q 22/7,
;;     :v :kw,
;;     :w 1.0E32,
;;     :x 42,
;;     :y \c,
;;     :z "abc"}</code></pre><p>The two exercising functions, <code>exercise</code> and <code>exercise-fn</code> both accept the <code>:canonical</code> option, as well.</p><pre><code>(exercise [int? ratio? double?] :canonical) ;; => ([[42 22/7 1.0E32] true])</code><br><br><code>(exercise-fn sum-three :canonical) ;; => ([[42 22/7 1.0E32] 1.0E32])</code></pre><p>Since the canonical values don't vary, it doesn't make much sense to exercise more than once.</p><p>Beyond the built-in canonical values, we can supply canonical values of our own choosing when we define a predicate. We can manually add the canonical values via <code>with-meta</code> or we can add a canonical value using <code>defpred</code> as an argument following a custom generator.</p><pre><code>(defpred neg-odd-int?
         (fn [i] (and (int? i) (neg? i) (odd? i)))
         (constantly :ignored)
         -33)</code><br><br><code>(defpred happy-string?
         (fn [s] (string? s))
         (constantly :ignored)
         "Hello Clojure!")</code><br><br><code>(defpred pretty-number? (fn [n] (number? n)) (constantly :ignored) 123.456)</code><br><br><br><code>(data-from-spec [neg-odd-int? happy-string? pretty-number?] :canonical)
;; => [-33 "Hello Clojure!" 123.456]</code></pre><p>We see that <code>data-from-spec</code> found the custom canonical values for each of the three predicates: <code>-33</code> for <code>neg-odd-int?</code>, <code>"Hello Clojure!"</code> for <code>happy-string?</code>, and <code>123.456</code> for <code>pretty-number?</code>. Notice that <em>exercising</em> a function does not validate the arguments or returns. Function argument and return validation only occurs when we explicitly invoke <code>validate-fn-with</code>, <code>validate-fn</code>, or we intentionally instrument it.</p></section><section id="utilities"><h2>Utility Functions</h2><p>You won't miss any crucial piece of Speculoos' functionality if you don't use this namespace, but perhaps something here might make your day a little nicer. Nearly every function takes advantage of <code>speculoos.core/all-paths</code>, which decomposes a heterogeneous, arbitrarily-nested data structure into a sequence of paths and datums. With that in hand, these not-clever functions churn through the entries and give you back something useful.</p><pre><code>(require '[speculoos.utility :refer
           [scalars-without-predicates predicates-without-scalars
            collections-without-predicates predicates-without-collections
            sore-thumb spec-from-data data-from-spec
            basic-collection-spec-from-data]])</code></pre><p>Recall that Speculoos only validates using elements in the data and predicates in the specification located at identical paths. This duo of utilities tells us where we have unmatched scalars or unmatched predicates. The first of the duo tells us about un-paired scalars.</p><pre><code>(scalars-without-predicates [42 ["abc" 22/7]]
                            [int?])
;; => #{{:path [1 0], :value "abc"}
;;      {:path [1 1], :value 22/7}}</code></pre><p>With this information, we can see if the specification was ignoring scalars that we were expecting to validate, and adjust our specification for better coverage. (The <code>thoroughly-…</code> <a href="#thorough"> group of functions</a> would strictly enforce all datums be paired with predicates.)</p><p>The second utility of that duo performs the complementary operation by telling us about un-paired predicates.</p><pre><code>(predicates-without-scalars [42] [int? string? ratio?])
;; => ({:path [1], :value string?}
;;     {:path [2], :value ratio?})</code></pre><p>It is especially helpful for <a href="#troubleshooting">diagnosing surprising results</a>. Just because we put a predicate into the scalar specification doesn't force validation of a scalar that doesn't exist.</p><pre><code>(predicates-without-scalars [42 "abc"]
                            [int? [string? ratio?]])
;; => ({:path [1 0], :value string?}
;;     {:path [1 1], :value ratio?})</code></pre><p>Now we can see two un-paired predicates. <code>ratio?</code> simply doesn't have a scalar to pair with, and <code>string?</code> doesn't share a path with <code>"abc"</code> so it wasn't used during validation.</p><p>It's not difficult to neglect a predicate for a nested element within a collection specification, so Speculoos offers analogous utilities to highlight those possible issues.</p><pre><code>(collections-without-predicates [11 [22 {:a 33}]]
                                [vector? [{:is-a-map? map?}]])
;; => #{{:path [1], :value [22 {:a 33}]}}</code></pre><p>Yup, we didn't specify that inner vector whose first element is <code>22</code>. That's okay, though. Maybe we don't care to specify it. But now we're aware.</p><p>Maybe we put a predicate into a collection specification that clearly ought to be unsatisfied, but for some reason, <code>validate-collections</code> isn't picking it up.</p><pre><code>(predicates-without-collections {:a 42}
                                {:is-map? map?, :b [set?]})
;; => #{{:path [:b 0], :value set?}}</code></pre><p>Aha. <code>set?</code> in the collection specification isn't paired with an element in the data, so it is unused during validation.</p><p>Taking those ideas further, the <a href="#thorough"><em>thorough validation variants</em></a> return <code>true</code> only if every scalar and every collection in data have a corresponding predicate in the scalar specification and the collection specification, respectively, and all those predicates are satisfied.</p><p>This next utility is probably only useful during development. Given data and a scalar specification, <code>sore-thumb</code> prints back both, but with only the invalid scalars and predicates showing.</p><div class="no-display">#'speculoos-project-readme-generator/sore-thumb-example#'speculoos-project-readme-generator/sore-thumb-example-eval</div><pre><code>(sore-thumb [42 {:a true, :b [22/7 :foo]} 1.23]
            [int? {:a boolean?, :b [ratio? string?]} int?])</code><br><br><code>;; to *out*</code><br><code>data: [_ {:a _, :b [_ :foo]} 1.23]
spec: [_ {:a _, :b [_ string?]} int?]
</code></pre><p>I've found it handy for quickly pin-pointing the unsatisfied scalar-predicate pairs in a large, deeply-nested data structure.</p><p>I think of the next few utilities as <em>creative</em>, making something that didn't previously exist. We'll start with a pair of functions which perform complimentary actions.</p><pre><code>(spec-from-data [33 {:a :baz, :b [1/3 false]} '(3.14 \z)])
;; => [int?
;;     {:a keyword?,
;;      :b [ratio? boolean?]}
;;     (double? char?)]</code><br><br><code>(data-from-spec
  {:x int?, :y [ratio? boolean?], :z (list char? neg-int?)}
  :random)
;; => {:x 139,
;;     :y [-17/24 true],
;;     :z (\1 -17)}</code></pre><p>I hope their names give good indications of what they do. The generated specification contains only basic predicates, that is, merely <em>Is it an integer?</em>, not <em>Is it an even integer greater than 25, divisible by 3?</em>. But it's convenient raw material to start crafting a tighter specification. (Oh, yeah…they both round-trip.) A few <a href="#custom-generators">paragraphs down</a> we'll see some ways to create random sample generators for compound predicates.</p><p>Speaking of raw material, Speculoos also has a collection specification generator.</p><pre><code>(basic-collection-spec-from-data [55 {:q 33, :r ['foo 'bar]} '(22 44 66)])
;; => [{:r [vector?], :speculoos.utility/collection-predicate map?} (list?) vector?]</code></pre><p>Which produces a specification that is perhaps not immediately useful, but does provide a good starting template, because collection specifications can be tricky to get just right.</p><p id="custom-generators">The <code>utility</code> namespace contains a trio of functions to assist <a href="#exercising">writing, checking, and locating</a> compound predicates that can be used by <code>data-from-spec</code>, <code>validate-fn</code>, and <code>validate-fn-with</code> to generate valid random sample data. A compound predicate such as <code>#(and (int? %) (< % 100))</code> does not have built-in generator provided by <code>clojure.test.check.generators</code>. However, <code>data-from-spec</code> and friends can extract a generator residing in the predicate's metadata. The <code>defpred</code> utility <a href="#access-gen"> streamlines</a> that task.</p></section><section id="predicates"><h2>Predicates</h2><p>A predicate function returns a truthy or falsey value.</p><pre><code>(#(<= 5 %) 3) ;; => false</code><br><br><code>(#(= 3 (count %)) [1 2 3]) ;; => true</code></pre><p>Non-boolean returns work, too. For example, <a href="#sets">sets</a> make wonderful membership tests.</p><pre><code>;; truthy</code><br><code>(#{:blue :green :orange :purple :red :yellow} :green) ;; => :green</code><br><br><code>;; falsey</code><br><code>(#{:blue :green :orange :purple :red :yellow} :swim) ;; => nil</code></pre><p>Regular expressions come in handy for validating string contents.</p><pre><code>;; truthy</code><br><code>(re-find #"^Four" "Four score and seven years ago...") ;; => "Four"</code><br><br><code>;; falsey</code><br><code>(re-find #"^Four" "When in the course of human events...") ;; => nil</code></pre><p>Invoking a predicate when supplied with a datum — scalar or collection — is the core action of Speculoos' validation.</p><pre><code>(int? 42) ;; => true</code><br><br><code>(validate-scalars [42]
                  [int?])
;; => [{:datum 42,
;;      :path [0],
;;      :predicate int?,
;;      :valid? true}]</code></pre><p>Speculoos is fairly ambivalent about the predicate return value. The <code>validate…</code> <a href="#fn-terminology">family of functions</a> mindlessly churns through its sequence of predicate-datum pairs, evaluates them, and stuffs the results into <code>:valid?</code> keys. The <code>valid…?</code> family of functions rips through <em>that</em> sequence, and if none of the results are falsey, returns <code>true</code>, otherwise it returns <code>false</code>.</p><p>For most of this document, we've been using the built-in predicates offered by <code>clojure.core</code> such as <code>int?</code> and <code>vector?</code> because they're short, understandable, and they render clearly. But in practice, it's not terribly useful to validate an element with a mere <em>Is this scalar an integer?</em> or <em>Is this collection a vector?</em> Often, we'll want to combine multiple predicates to make the validation more specific. We could certainly use <code>clojure.core/and</code>…</p><pre><code>#(and (int? %) (pos? %) (even? %))</code></pre><p>…and <code>clojure.core/or</code>…</p><pre><code>#(or (string? %) (char? %))</code></pre><p>…which have the benefit of being universally understood. But Clojure also provides a pair of nice functions that streamline the expression and convey your intention. <code>every-pred</code> composes an arbitrary number of predicates with <code>and</code> semantics.</p><pre><code>((every-pred number? pos? even?) 100) ;; => true</code></pre><p>Similarly, <code>some-fn</code> composes predicates with <code>or</code> semantics.</p><pre><code>((some-fn number? string? boolean?) \z) ;; => false</code></pre><p>When Speculoos validates the scalars of a sequence, it consumes each element in turn. If we care only about validating some of the elements, we must include placeholders in the specification to maintain the sequence of predicates.</p><p>For example, suppose we only want to validate <code>\z</code>, the third element of <code>[42 :foo \z]</code>. The first two elements are irrelevant to us. We have a few options. We could write our own little always-true predicate. <code>#(true)</code> won't work because <code>true</code> is not invocable. <code>#(identity true)</code> loses the conciseness. This works…</p><pre><code>(fn [] true)</code></pre><p>…but Clojure already includes a couple of nice options.</p><pre><code>(valid-scalars? [42 :foo \z]
                [(constantly true) (constantly true) char?])
;; => true</code></pre><p><code>constantly</code> is nice because it accepts any number of args. But for my money, nothing tops <code>any?</code>.</p><pre><code>(valid-scalars? [42 :foo \z]
                [any? any? char?]) ;; => true</code></pre><p><code>any?</code> is four characters, doesn't require typing parentheses, and the everyday usage of <em>any</em> aligns well with its technical purpose.</p><p>A word of warning about <code>clojure.core/contains?</code>. It might seem natural to use <code>contains?</code> to check if a collection contains an item, but it doesn't do what its name suggests. Observe.</p><pre><code>(contains? [97 98 99] 1) ;; => true</code></pre><p><code>contains?</code> actually tells you whether a collection contains a key. For a vector, it tests for an index. If you'd like to check whether a value is contained in a collection, you can use this pattern.</p><pre><code>(defn in? [coll item] (some #(= item %) coll))</code><br><br><code>;; integer 98 is a value found in the vector</code><br><code>(in? [97 98 99] 98) ;; => true</code><br><br><code>;; integer 1 is not a value found in the vector</code><br><code>(in? [97 98 99] 1) ;; => false</code></pre><p>(Check out <code>speculoos.utility/in?</code>.)</p><p>I've been using the <code>#(…)</code> form because it's compact, but it does have a drawback when Speculoos renders the function in a validation report.</p><pre><code>[{:path [0],
  :datum 42,
  :predicate #function[documentation/eval94717/fn--94718],
  :valid? false}]</code></pre><p>The function rendering is not terribly informative when the validation displays the predicate. Same problem with <code>(fn [v] (…))</code>.</p><p>One solution to this issue is to define your predicates with an informative name.</p><pre><code>(def greater-than-50? #(< 50 %))</code><br><br><code>(validate-scalars [42]
                  [greater-than-50?])
;; => [{:datum 42,
;;      :path [0],
;;      :predicate greater-than-50?,
;;      :valid? false}]</code></pre><p>Now, the predicate entry carries a bit more meaning.</p><p>Regular expressions check the content of strings.</p><pre><code>(def re #"F\dQ\d")</code><br><br><code>(defn re-pred [s] (re-matches re s))</code><br><br><code>(validate-scalars ["F1Q5" "F2QQ"]
                  [re-pred re-pred])
;; => [{:datum "F1Q5", :path [0], :predicate re-pred, :valid? "F1Q5"}
;;     {:datum "F2QQ", :path [1], :predicate re-pred, :valid? nil}]</code></pre><p>Speculoos considers free-floating regexes in a scalar specification as predicates, so you can simply jam them in there.</p><pre><code>(valid-scalars? ["A1B2" "CDEF"]
                [#"(\w\d){2}" #"\w{4}"])
;; => true</code><br><br><code>(validate-scalars {:a "foo", :b "bar"}
                  {:a #"f.\w", :b #"^[abr]{0,3}$"})
;; => [{:datum "foo",
;;      :path [:a],
;;      :predicate #"f.\w",
;;      :valid? "foo"}
;;     {:datum "bar",
;;      :path [:b],
;;      :predicate #"^[abr]{0,3}$",
;;      :valid? "bar"}]</code></pre><p>Using bare regexes in your scalar specification has a nice side benefit in that the <code>data-from-spec</code>, <code>exercise</code>, and <code>exercise-fn</code> utilities can generate valid strings.</p><p>Beyond their critical role they play in validating data, predicate functions can also carry metadata that describes how to <a href="#exercising">generate valid, random samples</a>. To help with that task, the <a href="#utilities">utility namespace</a> provides <code>defpred</code>, a helper macro that streamlines <strong>def</strong>ing <strong>pred</strong>icates and associating random sample generators.</p><p>Instead of storing specifications in a dedicated <a href="https://clojure.org/guides/spec#_registry">registry</a>,  Speculoos takes a <em>laissez-faire</em> approach: specifications may live directly in whatever namespace you please. If you feel that some sort of registry would be useful, you could make your own <a href="https://github.com/clojure/spec.alpha/blob/c630a0b8f1f47275e1a476dcdf77507316bad5bc/src/main/clojure/clojure/spec/alpha.clj#L52">modeled after</a> <code>spec.alpha</code>'s.</p><p>Finally, when checking function correctness, <a href="#fn-correctness">validating the relationship</a> between the function's arguments and the function's return value uses a function that kinda looks like a predicate. In contrast to a typical predicate that accepts one argument, that relationship-checking function accepts exactly two elements: the function's argument sequence and the function's return value.</p></section><section id="non-terminating-sequences"><h2>Non-terminating sequences</h2><p>Speculoos absorbs lots of power from Clojure's infinite, lazy sequences. That power stems from the fact that Speculoos only validates complete pairs of datums and predicates. Datums without predicates are not validated, and predicates without datums are ignored. That policy provides optionality in our data. If a datum is present, it is validated against its corresponding predicate, but if that datum is non-existent, it is not required.</p><pre><code>;; un-paired scalar predicates</code><br><code>(validate-scalars [42]
                  [int? keyword? char?])
;; => [{:datum 42,
;;      :path [0],
;;      :predicate int?,
;;      :valid? true}]</code><br><br><code>;; un-paired scalar datums</code><br><code>(validate-scalars [42 :foo \z]
                  [int?])
;; => [{:datum 42,
;;      :path [0],
;;      :predicate int?,
;;      :valid? true}]</code></pre><p>In the first example, only the single integer <code>42</code> is validated, the rest of the predicates are ignored. In the second example, only the <code>42</code>  was validated because the specification implies that any trailing elements are un-specified. We can take advantage of this fact by intentionally making either the data or the specification <em>run off the end</em>.</p><p>First, if we'd like to validate a non-terminating sequence, specify as many datums as necessary to capture the pattern. <code>repeat</code> produces multiple instances of a single value, so we only need to specify one datum.</p><pre><code>(validate-scalars (repeat 3)
                  [int?])
;; => [{:datum 3,
;;      :path [0],
;;      :predicate int?,
;;      :valid? true}]</code></pre><p>Despite <code>(repeat 3)</code> producing a non-terminating sequence of integers, only the first integer was validated because that's the only predicate supplied by the specification.</p><p><code>cycle</code> can produce different values, so we ought to test for as many as appear in the definition.</p><pre><code>(validate-scalars (cycle [42 :foo 22/7])
                  [int? keyword? ratio?])
;; => [{:datum 42,
;;      :path [0],
;;      :predicate int?,
;;      :valid? true}
;;     {:datum :foo,
;;      :path [1],
;;      :predicate keyword?,
;;      :valid? true}
;;     {:datum 22/7,
;;      :path [2],
;;      :predicate ratio?,
;;      :valid? true}]</code></pre><p>Three unique datums. Only three predicates needed.</p><p>On the other side of the coin, non-terminating sequences serve a critical role in composing Speculoos specifications. They express <em>I don't know how many items there are in this sequence, but they all must satisfy these predicates</em>.</p><pre><code>(valid-scalars? [1] (repeat int?)) ;; => true</code><br><code>(valid-scalars? [1 2] (repeat int?)) ;; => true</code><br><code>(valid-scalars? [1 2 3] (repeat int?)) ;; => true</code><br><code>(valid-scalars? [1 2 3 4] (repeat int?)) ;; => true</code><br><code>(valid-scalars? [1 2 3 4 5] (repeat int?)) ;; => true</code></pre><p>Basically, this idiom serves the role of a regular expression <code>zero-or-more</code>. Let's pretend we'd like to validate an integer, then a string, followed by any number of characters. We compose our specification like this.</p><pre><code>;; use `concat` to append an infinite sequence of `char?`</code><br><code>(validate-scalars [99 "abc" \x \y \z]
                  (concat [int? string?] (repeat char?)))
;; => [{:datum 99,
;;      :path [0],
;;      :predicate int?,
;;      :valid? true}
;;     {:datum "abc",
;;      :path [1],
;;      :predicate string?,
;;      :valid? true}
;;     {:datum \x,
;;      :path [2],
;;      :predicate char?,
;;      :valid? true}
;;     {:datum \y,
;;      :path [3],
;;      :predicate char?,
;;      :valid? true}
;;     {:datum \z,
;;      :path [4],
;;      :predicate char?,
;;      :valid? true}]</code><br><br><code>(require '[speculoos.core :refer [only-invalid]])</code><br><br><code>;; string "y" will not satisfy scalar predicate `char?`; use `only-valid` to highlight invalid element</code><br><code>(only-invalid (validate-scalars [99 "abc" \x "y" \z]
                                (concat [int? string?] (repeat char?))))
;; => ({:datum "y",
;;      :path [3],
;;      :predicate char?,
;;      :valid? false})</code></pre><p>Or perhaps we'd like to validate a function's argument list composed of a ratio followed by <code>&-args</code> consisting of any number of alternating keyword-string pairs.</p><pre><code>;; zero &-args</code><br><code>(valid-scalars? [2/3]
                (concat [ratio?] (cycle [keyword string?])))
;; => true</code><br><br><code>;; two pairs of keyword+string optional args</code><br><code>(valid-scalars? [2/3 :opt1 "abc" :opt2 "xyz"]
                (concat [ratio?] (cycle [keyword string?])))
;; => true</code><br><br><code>;; one pair of optional args; 'foo does not satisfy `string?` scalar predicate</code><br><code>(only-invalid (validate-scalars [2/3 :opt1 'foo]
                                (concat [ratio?] (cycle [keyword string?]))))
;; => ({:datum foo,
;;      :path [2],
;;      :predicate string?,
;;      :valid? false})</code></pre><p>Using non-terminating sequences this way sorta replicates <code>spec.alpha</code>'s sequence regexes. I think of it as Speculoos' super-power.</p><p>Also, Speculoos can handle nested, non-terminating sequences.</p><pre><code>(valid-scalars? [[1] [2 "2"] [3 "3" :3]]
                (repeat (cycle [int? string? keyword?])))
;; => true</code></pre><p>This specification is satisfied with a <em>Possibly infinite sequence of arbitrary-length vectors, each vector containing a pattern of an integer, then a string, followed by a keyword</em>.</p><p>One detail that affects usage: A non-terminating sequence must not appear at the same path within both the data and specification. I am not aware of any method to inspect a sequence to determine if it is infinite, so Speculoos will refuse to validate a non-terminating data sequence at the same path as a non-terminating predicate sequence, and <em>vice versa</em>. However, feel free to use them in either data or in the specification, as long as they live at different paths.</p><pre><code>;; data's infinite sequence at :a, specification's infinite sequence at :b</code><br><code>(valid-scalars? {:a (repeat 42), :b [22/7 true]}
                {:a [int?], :b (cycle [ratio? boolean?])})
;; => true</code><br><br><code>;; demo of some invalid scalars</code><br><code>(only-invalid (validate-scalars {:a (repeat 42), :b [22/7 true]}
                                {:a [int? int? string?], :b (repeat ratio?)}))
;; => ({:datum 42,
;;      :path [:a 2],
;;      :predicate string?,
;;      :valid? false}
;;     {:datum true,
;;      :path [:b 1],
;;      :predicate ratio?,
;;      :valid? false})</code></pre><p>In both cases above, the data contains a non-terminating sequence at key <code>:a</code>, while the specification contains a non-terminating sequence at key <code>:b</code>. Since in both cases, the two infinite sequences do not share a path, validation can proceed to completion.</p><p>So what's going on? Internally, Speculoos finds all the potentially non-terminating sequences in both the data and the specification. For each of those hits, Speculoos looks into the other nested structure to determine how long the counterpart sequence is. Speculoos then <em>clamps</em> the non-terminating sequence to that length. Validation proceeds with the clamped sequences. Let's see the clamping in action.</p><pre><code>(require '[speculoos.core :refer [expand-and-clamp-1]])</code><br><br><code>(expand-and-clamp-1 (range) [int? int? int?]) ;; => [0 1 2]</code></pre><p><code>range</code> would have continued merrily on forever, but the clamp truncated it at three elements, the length of the second argument vector. That's why two non-terminating sequences at the same path are not permitted. Speculoos has no way of knowing how short or long the sequences ought to be, so instead of making a bad guess, it throws the issue back to us. The way <em>we</em> indicate how long it should be is by making the counterpart sequence a specific length. Where should Speculoos clamp that <code>(range)</code> in the above example? The answer is the length of the other sequential thing, <code>[int? int? int?]</code>, or three elements.</p><p>Speculoos' <a href="#utilities">utility</a> namespace provides a <code>clamp-in*</code> tool for us to clamp any sequence within a homogeneous, arbitrarily-nested data structure. We invoke it with a pattern of arguments similar to <code>clojure.core/assoc-in</code>.</p><pre><code>(require '[speculoos.utility :refer [clamp-in*]])</code><br><br><code>(clamp-in* {:a 42, :b ['foo 22/7 {:c (cycle [3 2 1])}]}
           [:b 2 :c]
           5)
;; => {:a 42, :b [foo 22/7 {:c [3 2 1 3 2]}]}</code></pre><p><code>clamp-in*</code> used the path <code>[:b 2 :c]</code> to locate the non-terminating <code>cycle</code> sequence, clamped it to <code>5</code> elements, and returned the new data structure with that terminating sequence. This way, if Speculoos squawks at us for having two non-terminating sequences at the same path, we have a way to clamp the data, specification, or both at any path, and validation can proceed.</p><p>Be sure to set your development environment's printing length</p><pre><code>(set! *print-length* 99) ;; => 99</code></pre><p>or you may jam up your session.</p></section><section id="sets"><h2>Sets</h2><p>Sets are…a handful. They enable some nice features, but they present some unique challenges compared to the other Clojure collections. <em>The elements in a set are addressed by their identities.</em> What does that even mean? Let's compare to Clojure's other collections to get some context.</p><p>The elements of a sequence are addressed by monotonically increasing integer indexes. Give a vector index <code>2</code> and it'll give you back the third element, if it exists.</p><pre><code>([11 22 33] 2) ;; => 33</code></pre><p>The elements of a map are addressed by its keys. Give a map a key <code>:howdy</code> and it'll give you back the value at that key, if it exists.</p><pre><code>({:hey "salut", :howdy "bonjour"} :howdy) ;; => "bonjour"</code></pre><p>Give a set some value, and it will give you back that value…</p><pre><code>(#{:index :middle :pinky :ring :thumb} :thumb) ;; => :thumb</code></pre><p>…but only if that element exists in the set.</p><pre><code>(#{:index :middle :pinky :ring :thumb} :bird) ;; => nil</code></pre><p>So the <a href="#path">paths</a> to elements of vectors, lists, and maps are composed of indexes or keys. The paths to members of a set are the thing themselves. Let's take a look at a couple of examples.</p><pre><code>(all-paths #{:foo 42 "abc"})
;; => [{:path [], :value #{42 :foo "abc"}}
;;     {:path ["abc"], :value "abc"}
;;     {:path [:foo], :value :foo}
;;     {:path [42], :value 42}]</code></pre><p>In the first example, the root element, a set, has a path <code>[]</code>. The remaining three elements, direct descendants of the root set have paths that consist of themselves. We find <code>42</code> at path <code>[42]</code> and so on. The second example applies the principle further.</p><pre><code>(all-paths #{11 {:a [22 #{33}]}})
;; => [{:path [], :value #{11 {:a [22 #{33}]}}}
;;     {:path [{:a [22 #{33}]}], :value {:a [22 #{33}]}}
;;     {:path [{:a [22 #{33}]} :a], :value [22 #{33}]}
;;     {:path [{:a [22 #{33}]} :a 0], :value 22}
;;     {:path [{:a [22 #{33}]} :a 1], :value #{33}}
;;     {:path [{:a [22 #{33}]} :a 1 33], :value 33}
;;     {:path [11], :value 11}]</code></pre><p>How would we navigate to that <code>33</code>? Again the root element set has a path <code>[]</code>. There are two direct descendants of the root set: <code>11</code> and a map. We've already seen that the integer's path is the value of the integer. The path to the map is the map itself, which appears as the first element of its path. That path may look unusual, but Speculoos handles it without skipping a beat.</p><p>Let's borrow a function from the <a href="https://github.com/blosavio/fn-in">fn-in project</a> to zoom in on what's going on. The first argument is our example set. The second argument is a path. We'll build up the path to <code>33</code> piece by piece.</p><pre><code>(require '[fn-in.core :refer [get-in*]])</code><br><br><code>(get-in* #{11 {:a [22 #{33}]}}
         [{:a [22 #{33}]}]) ;; => {:a [22 #{33}]}</code></pre><p>The map has one <code>MapEntry</code>, key <code>:a</code>, with an associated value, a two-element vector <code>[22 #{33}]</code>. A map value is addressed by its key, so the vector's path contains that key. Its path is that of its parent, with its key appended.</p><pre><code>(get-in* #{11 {:a [22 #{33}]}}
         [{:a [22 #{33}]} :a]) ;; => [22 #{33}]</code></pre><p>Paths into a vector are old hat by now. Our <code>33</code> is in a set at the second position, index <code>1</code> in zero-based land, which we append to the path.</p><pre><code>(get-in* #{11 {:a [22 #{33}]}}
         [{:a [22 #{33}]} :a 1]) ;; => #{33}</code></pre><p>We've now arrived at the little nested set which holds our <code>33</code>. Items in a set are addressed by their identity, and the identity of <code>33</code> is <code>33</code>. So we append that to the path so far.</p><pre><code>(get-in* #{11 {:a [22 #{33}]}}
         [{:a [22 #{33}]} :a 1 33]) ;; => 33</code></pre><p>And now we've finally fished out our <code>33</code>. Following this algorithm, we can get, change, and delete any element of any heterogeneous, arbitrarily-nested data structure, and that includes sets at any level of nesting. We could even make a path to a set, nested within a set, nested within a set.</p><p>When using Speculoos, we encounter sets in three scenarios. We'll briefly sketch the three scenarios, then later go into the details.</p><ol><li><em>Scalar validation, scalar in data, set in specification.</em><pre><code>(validate-scalars [42 :red]
                  [int? #{:red :green :blue}])</code></pre><p>In this scenario, we're validating scalars, so we're using a function with <code>scalar</code> in its name. We'll be testing properties of a scalar, in this example, the second element of a vector the keyword <code>:red</code>. The set in the specification is a predicate-like thing that tests membership.</p></li><li><em>Scalar validation, set in data, set in specification.</em><pre><code>(validate-scalars [42 #{:chocolate :vanilla :strawberry}]
                  [int? #{keyword?}])</code></pre><p>In this scenario, we're validating scalars, so we're using a scalar validation function, again <code>validate-scalars</code>. But this time, we're validating scalars <em>contained within a set</em> in the data, with scalar predicates contained within a set in the specification.</p></li><li><em>Collection validation, set in data, set in specification.</em><pre><code>(validate-collections [42 #{:puppy :kitten :goldfish}]
                      [vector? #{set?}])</code></pre><p>In this scenario, we're validating some property of a collection, so we're using <code>validate-collections</code>. Collection predicates — targeting the nested set in the data — are themselves contained in a set nested in the collection specification.</p></li></ol><h3>1. Set as Scalar Predicate</h3><p>Let's remember back to the beginning of this section where we saw that Clojure sets can serve as membership tests. Speculoos can therefore use sets as a nice shorthand for a membership predicate.</p><pre><code>(def color? #{:red :green :blue})</code><br><br><code>(ifn? color?) ;; => true</code><br><br><code>(color? :red) ;; => :red</code><br><br><code>(color? :plaid) ;; => nil</code></pre><p><code>color?</code> implements <code>IFn</code> and thus behaves like a predicate when invoked as a function. <code>:red</code> satisfies our <code>color?</code> predicate and returns a truthy value, whereas <code>:plaid</code> does not and returns a falsey value.</p><p>During scalar validation, when a scalar in our data shares a path with a set in the specification, Speculoos enters <em>set-as-a-predicate</em> mode. (<em>Mode</em> only in the casual sense.  There are no modes nor states. The algorithm merely branches to treat the set differently depending on the scenario.) We'll make our specification mimic the shape of our data, but instead of two predicate functions, we'll insert one scalar predicate function, followed by a set, which behaves like a membership predicate.</p><pre><code>;; data</code><br><code>(all-paths [42 :red])
;; => [{:path [], :value [42 :red]}
;;     {:path [0], :value 42}
;;     {:path [1], :value :red}]</code><br><br><code>;; scalar specification</code><br><code>(all-paths [int? #{:red :green :blue}])
;; => [{:path [], :value [int? #{:blue :green :red}]}
;;     {:path [0], :value int?}
;;     {:path [1], :value #{:blue :green :red}}
;;     {:path [1 :green], :value :green}
;;     {:path [1 :red], :value :red}
;;     {:path [1 :blue], :value :blue}]</code></pre><p>Our example data contains two scalar datums: <code>42</code> in the first spot and <code>:red</code>  in the second. Each of those datums shares a path with a predicate in the scalar specification. The <code>42</code> is paired with the <code>int?</code> scalar predicate because they both share the path <code>[0]</code>. Both <code>:red</code> and <code>#{:red :green :blue}</code> share a path <code>[1]</code>, Speculoos regards it as a <em>set-as-a-scalar-predicate</em>. Let's run that validation now.</p><pre><code>(validate-scalars [42 :red]
                  [int? #{:red :green :blue}])
;; => [{:datum :red,
;;      :path [1],
;;      :predicate #{:blue :green :red},
;;      :valid? :red}
;;     {:datum 42,
;;      :path [0],
;;      :predicate int?,
;;      :valid? true}]</code></pre><p>When Speculoos validates scalars, it treats the set in the specification as a predicate because the corresponding element in the data is a scalar, not a set. In this example, <code>:red</code> is a member of the <code>#{:red :green :blue}</code> set-predicate.</p><p>The same principles hold when validating elements of a map with a set-predicate. When a set in the specification contains a set that shares a path with a scalar in the data, that set is treated as a membership predicate.</p><pre><code>(validate-scalars {:x 42, :y :red}
                  {:x int?, :y #{:red :green :blue}})
;; => [{:datum :red,
;;      :path [:y],
;;      :predicate #{:blue :green :red},
;;      :valid? :red}
;;     {:datum 42,
;;      :path [:x],
;;      :predicate int?,
;;      :valid? true}]</code></pre><p>Scalar <code>42</code> pairs with predicate <code>int?</code> at path <code>[:x]</code> and scalar <code>:red</code> pairs with set-predicate <code>#{:red :green :blue}</code> at path <code>[:y]</code>.</p><h3>2. Validate Scalars within Set</h3><p>Sometimes the scalars in our data are contained in a set. Speculoos can validate scalars within a set during a scalar validation operation. Validating a set's scalar members follows all the same principles as validating a vector's scalar members, except for one wrinkle: Since elements of a set have no inherent location, i.e., sets are unordered, sets in our data are validated against <em>all</em> predicates contained in the corresponding set at the same path in the specification. An example shows this better than words.</p><pre><code>;; data, some scalars are contained within a set</code><br><code>(all-paths [42 #{:chocolate :vanilla :strawberry}])
;; => [{:path [], :value [42 #{:chocolate :strawberry :vanilla}]}
;;     {:path [0], :value 42}
;;     {:path [1], :value #{:chocolate :strawberry :vanilla}}
;;     {:path [1 :strawberry], :value :strawberry}
;;     {:path [1 :chocolate], :value :chocolate}
;;     {:path [1 :vanilla], :value :vanilla}]</code><br><br><code>;; scalar specification</code><code>(all-paths [int? #{keyword?}])
;; => [{:path [], :value [int? #{keyword?}]}
;;     {:path [0], :value int?}
;;     {:path [1], :value #{keyword?}}
;;     {:path [1 keyword?], :value keyword?}]</code></pre><p>Let's apply the Mottos. We intend to validate scalars, so we'll use <code>validate-scalars</code>, which only applies predicates to scalars. Next, we'll make our our specification mimic the shape of the data. In this example, both the data and the specification are a vector, with something in the first spot, and a set in the second spot. Finally, we'll make sure that all predicates are paired with a scalar.</p><pre><code>(validate-scalars [42 #{:glass :rubber :paper}]
                  [int? #{keyword?}])
;; => ({:datum 42,
;;      :path [0],
;;      :predicate int?,
;;      :valid? true}
;;     {:datums-set #{:glass :paper :rubber},
;;      :path [1],
;;      :predicate keyword?,
;;      :valid? true})</code></pre><p>First, notice how the scalar specification looks a lot like the data. Because the shapes are similar, <code>validate-scalars</code> is able to systematically apply predicates from the specification to scalars in the data. Speculoos validates <code>42</code> against predicate <code>int?</code> because they share paths in their respective vectors. At vector index <code>1</code> our data and specification both hold sets, so Speculoos enters <em>validate-scalars-within-a-set-mode</em>. Every predicate contained in the specification set is applied to every datum in the data's set. In this example, <code>keyword?</code> is individually applied to <code>:glass</code>, <code>:rubber</code>, and <code>:paper</code>, and since each satisfy the predicate, the validation returns <code>true</code>.</p><p>One of the defining features of Clojure sets is that they're amorphous bags of items, without any inherent ordering. Within the context of a set, it doesn't make sense to target one scalar predicate towards one particular scalar datum. Therefore, Speculoos validates scalars contained within a set more broadly. If our specification set contains more than one predicate, each of the predicates is applied to <em>all</em> the scalars in the data's set. In the next example, the specification set contains two predicates.</p><pre><code>(validate-scalars #{:chocolate}
                  #{keyword? qualified-keyword?})
;; => ({:datums-set #{:chocolate},
;;      :path [],
;;      :predicate qualified-keyword?,
;;      :valid? false}
;;     {:datums-set #{:chocolate},
;;      :path [],
;;      :predicate keyword?,
;;      :valid? true})</code></pre><p>Two scalar predicates in the specification applied to the one scalar datum. <code>:chocolate</code> is a keyword, but not a qualified keyword. Next, we'll see how to validate multiple scalars with multiple scalar predicates.</p><pre><code>(validate-scalars #{:chocolate :vanilla :strawberry}
                  #{keyword? qualified-keyword?})
;; => ({:datums-set #{:chocolate :strawberry :vanilla},
;;      :path [],
;;      :predicate qualified-keyword?,
;;      :valid? false}
;;     {:datums-set #{:chocolate :strawberry :vanilla},
;;      :path [],
;;      :predicate keyword?,
;;      :valid? true})</code></pre><p>Validation applies <code>keyword?</code> and <code>simple-keyword?</code>, in turn, to every scalar member of the data set. Speculoos tells us that all the scalars in the data are indeed keywords, but at least one of the data's scalars is not a qualified keyword. Notice how Speculoos condenses the validation results. Instead of a validation entry for each individual scalar in the data set, Speculoos combines all the results for all the scalars. Two scalar predicates, two validation results.</p><p>Again, the same principles apply for validating sets contained in a map.</p><pre><code>(validate-scalars {:x 42, :y #{"a" "b" "c"}}
                  {:x int?, :y #{string?}})
;; => ({:datum 42,
;;      :path [:x],
;;      :predicate int?,
;;      :valid? true}
;;     {:datums-set #{"a" "b" "c"},
;;      :path [:y],
;;      :predicate string?,
;;      :valid? true})</code></pre><p><code>int?</code> at <code>:x</code> applies to <code>42</code> also at <code>:x</code>. Then, <code>string?</code> at <code>:y</code> is applied to scalars <code>"a"</code>, <code>"b"</code>, and <code>"c"</code> at <code>:y</code>.</p><p>Speculoos performs the two modes in separate passes, so we may even use both <em>set-as-a-predicate-mode</em> and <em>validate-scalars-within-a-set-mode</em> during the same validation, as long as the predicates stay on their own side of the fence.</p><pre><code>(validate-scalars [42 #{:foo :bar :baz}]
                  [#{40 41 42} #{keyword?}])
;; => ({:datum 42,
;;      :path [0],
;;      :predicate #{40 41 42},
;;      :valid? 42}
;;     {:datums-set #{:bar :baz :foo},
;;      :path [1],
;;      :predicate keyword?,
;;      :valid? true})</code></pre><p>In this example, the predicate at index <code>0</code> of the specification is a set while the datum at same index of the data is <code>42</code>, a scalar. Speculoos uses the set-as-a-predicate mode. Since <code>42</code> is a member of <code>#{40 41 42}</code>, that datum validates as truthy. Because the data at index <code>1</code> is itself a set, Speculoos performs set-scalar-validation. The <code>keyword?</code> predicate is applied to each element of <code>#{:foo :bar :baz}</code> at index <code>1</code> and they all validate <code>true</code>.</p><h3>3. Validate Set as a Collection</h3><p>Let's discuss how collection validation works when a set is involved. During a collection validation operation, Speculoos will ignore all scalars in the data. It will only apply predicates to collections. The rules are identical to how the other collections are validated: predicates from the specification are applied to the parent container in the data. But let's not get bogged down in a textual description; let's look at some examples.</p><p>First, we'll start with some data that consists of a vector containing an integer, followed by a three element set. Let's generate all the paths.</p><pre><code>(all-paths [42 #{:puppy :kitten :goldfish}])
;; => [{:path [], :value [42 #{:goldfish :kitten :puppy}]}
;;     {:path [0], :value 42}
;;     {:path [1], :value #{:goldfish :kitten :puppy}}
;;     {:path [1 :puppy], :value :puppy}
;;     {:path [1 :goldfish], :value :goldfish}
;;     {:path [1 :kitten], :value :kitten}]</code></pre><p>Motto #1: Collection validation ignores scalars, so out of all those elements, validation will only consider the root at path <code>[]</code> and the nested set at path <code>[1]</code>.</p><p>A good strategy for creating a collection specification is to copy-paste the data and delete all the scalars…</p><pre><code>[        #{    }]</code></pre><p>…and insert some collection predicates near the opening bracket.</p><pre><code>[vector? #{set?}]</code></pre><p>Let's generate the paths for that collection specification.</p><pre><code>(all-paths [vector? #{set?}])
;; => [{:path [], :value [vector? #{set?}]}
;;     {:path [0], :value vector?}
;;     {:path [1], :value #{set?}}
;;     {:path [1 set?], :value set?}]</code></pre><p>Notice the paths to the two predicates. Now, let's run a collection validation.</p><pre><code>(validate-collections [42 #{:puppy :kitten :goldfish}]
                      [vector? #{set?}])
;; => ({:datum [42 #{:goldfish :kitten :puppy}],
;;      :ordinal-path-datum [],
;;      :path-datum [],
;;      :path-predicate [0],
;;      :predicate vector?,
;;      :valid? true}
;;     {:datum #{:goldfish :kitten :puppy},
;;      :ordinal-path-datum [0],
;;      :path-datum [1],
;;      :path-predicate [1 set?],
;;      :predicate set?,
;;      :valid? true})</code></pre><p><code>validate-collections</code> was able to pair two collections in the data with two predicates in the specification, and we received two validation results. Collection predicate <code>vector?</code> at path <code>[0]</code> in the specification was applied to whatever is at path <code>(drop-last [0])</code> in the data, which happens to be the root collection. Collection predicate <code>set?</code> at path <code>[1 set?]</code> in the specification was applied to path <code>(drop-last [1 set?])</code> in the data, which happens to be our nested set containing pet keywords.</p><p>Remember: Scalar predicates apply to the scalar at their exact location. Collection predicates apply to the collection directly above their head.</p></section><section id="troubleshooting"><h2>Troubleshooting</h2><p>If you see surprising results, try these ideas.</p><ul><li><p>Remember the Mottos, and follow them.<ol><li><strong>Validate scalars separately from validating collections.</strong><p>We should never have a collection predicate like <code>vector?</code> in a scalar specification. Similarly, scalar predicates like <code>int?</code> should only appear in a collection specification in the context of testing a collection, like…</p><pre><code>(defn all-ints? [v] (every? #(int? %) v))</code></pre><p>…or when validating some relationship <em>between</em> datums, like this.</p><pre><code>(defn b-greater-than-a? [m] (< (m :a) (m :b)))</code></pre><p>The function names <code>validate-scalars</code>, <code>validate-collections</code>, et. al., are strong beacons to remind you that you're either validating scalars, or validating collections.</p></li><li><strong>Make the specification mimic the shape of the data.</strong><p>The speculoos functions don't enforce any requirements on the data and specification. If we feed it data that's a map and a specification that's a vector, it will dutifully try to validate what it has.</p><pre><code>(validate-scalars {:a 99}
                  [int?]) ;; => []</code><br><br><code>;; No error nor exception with map data and vector specification</code></pre><p>One word of warning: Because sequential things are indexed by integers, and map elements may also be indexed by integers, we could certainly abuse that flexibility like this.</p><pre><code>;; data is a vector, specification is a map keyed with integers</code><br><br><code>(validate-scalars [42 "abc" 22/7]
                  {0 int?, 1 string?, 2 ratio?})
;; => [{:datum 42,
;;      :path [0],
;;      :predicate int?,
;;      :valid? true}
;;     {:datum "abc",
;;      :path [1],
;;      :predicate string?,
;;      :valid? true}
;;     {:datum 22/7,
;;      :path [2],
;;      :predicate ratio?,
;;      :valid? true}]</code></pre><p>Speculoos merely knows that it could successfully locate <code>42</code> and <code>int?</code> at <code>0</code>, etc. It 'worked' in this instance, but surprise lurks if we try to get to overly clever.</p></li><li><strong>Validation ignores un-paired predicates and un-paired datums.</strong><p>A decent number of surprising validations result from predicates pairing to unexpected datums or not being paired at all.</p><pre><code>;; Oops! specification contains un-paired key :c; string "abc" isn't validated</code><br><code>(valid-scalars? {:a 42, :b "abc"}
                {:a int?, :c symbol?})
;; => true</code><br><br><br>;; Oops! specification uses an extra level of nesting; [33] wasn't validated</br><code>(validate-collections [11 [22 [33]]] [[[[list?]]]]) ;; => ()</code></pre><p>Corollary: <strong><code>valid?</code> being <code>true</code> means there were zero non-true results.</strong> If the validation did not find any predicate+datum pairs, there would be zero invalid results, and thus return valid. Use the <code>thorough-…</code> function variants to require all datums to be validated.</p><p>See below for strategies and tools for diagnosing mis-pairing.</p></li></ol></p></li><li><p>Speculoos specifications are regular old data structures containing regular old functions. (I assume your data is, too.) If we're wrangling with something deep down in some nested mess, use our Clojure powers to dive in and pull out the relevant pieces.</p><pre><code>(let [data (get-in {:a {:b {:c [22/7]}}} [:a :b :c])
      spec (get-in {:a {:b {:c [int?]}}} [:a :b :c])]
  (validate-scalars data spec))
;; => [{:datum 22/7,
;;      :path [0],
;;      :predicate int?,
;;      :valid? false}]</code></pre></li><li><p>Use the verbose functions. If we're using the high-level <code>valid-…?</code> function variants, we'll only see <code>true/false</code>, which isn't helpful when troubleshooting. The <code>validate-…</code> variants are chatty and will display everything it considered during validation.</p></li><li><p>The <a href="https://blosavio.github.io/speculoos/speculoos.utility.html"><code>speculoos.utility</code></a> namespace provides many functions for creating, viewing, analyzing, and modifying both scalar and collection specifications.</p></li><li><p>When the going really gets tough, break out <code>speculoos.core/all-paths</code> and apply it to our data, then to our specification, and then step through the validation with our eyes.</p><pre><code>(all-paths {:a [99]})
;; => [{:path [], :value {:a [99]}}
;;     {:path [:a], :value [99]}
;;     {:path [:a 0], :value 99}]</code><br><br><code>(all-paths {:a 'int?})
;; => [{:path [], :value {:a int?}}
;;     {:path [:a], :value int?}]</code><br><br><code>;; Aha! The predicate int? at path [:a] and the integer 99 at path [:a 0] do not share a path!</code></pre></li><li><p>When validating a function's arguments, remember that arguments are contained in an implicit sequence.</p><pre><code>(defn arg-passthrough [& args] args)</code><br><br><code>(arg-passthrough [1 2 3]) ;; => ([1 2 3])</code><br><br><code>(arg-passthrough [1 2 3] [4 5 6]) ;; => ([1 2 3] [4 5 6])</code></pre><p>If we're passing only a single value, it's easy to forget that the single value is contained in the argument sequence. Validating a function's arguments validates the <em>argument sequence</em>, not just the first lonely element that happens to also be a sequence.</p><pre><code>;; seemingly single vector in, single integer out...</code><br><code>(first [1 2 3]) ;; => 1</code><br><br><code>;; shouldn't integer `1` fail to satisfy predicate `string?`</code><br><code>(validate-fn-with first {:speculoos/arg-scalar-spec [string?]} [1 2 3]) ;; => 1</code></pre><p><code>validate-fn-with</code> passes through the value returned by <code>first</code> because <code>validate-fn-with</code> did not find any invalid results. Why not? In this example, <code>1</code> and <code>string?</code> do not share a path, and therefore <code>validate-fn-with</code> preformed zero validations. Let's take a look.</p><pre><code>(all-paths [[1 2 3]])
;; => [{:path [], :value [[1 2 3]]}
;;     {:path [0], :value [1 2 3]}
;;     {:path [0 0], :value 1}
;;     {:path [0 1], :value 2}
;;     {:path [0 2], :value 3}]</code><br><br><code>(all-paths [string?])
;; => [{:path [], :value [string?]}
;;     {:path [0], :value string?}]</code></pre><p>We  find <code>1</code> at path <code>[0 0]</code> in the <em>argument sequence</em>, while scalar predicate <code>string?</code> is located at path <code>[0]</code> in the scalar specification. The two do not share paths are not paired, thus no validation. The fix is to make the specification mimic the shape of the data, the 'data' in this case being the <em>argument sequence</em>.</p><pre><code>(validate-fn-with first {:speculoos/arg-scalar-spec [[string?]]} [1 2 3])
;; => ({:datum 1,
;;      :fn-spec-type :speculoos/argument,
;;      :path [0 0],
;;      :predicate string?,
;;      :valid? false})</code></pre><p>Now that argument scalar specification mimics the shape of the <em>argument sequence</em>, scalar <code>1</code> and scalar predicate <code>string?</code> share a path <code>[0 0]</code>, and <code>validate-fn-with</code> performs a scalar validation. <code>1</code> fails to satisfy <code>string?</code>.</p><p>This also applies to validating arguments that are collections.</p></li></ul><p>Finally, if you hit a wall, file a <a href="https://github.com/blosavio/speculoos/issues">bug report</a> or <a href="https://github.com/blosavio"> email me</a>.</p></section><section id="alternatives"><h2>Alternatives</h2><ul><li>Staples SparX <a href="https://github.com/staples-sparx/clj-schema">clj-schema</a><p>Schemas for Clojure data structures and values. Delineates operations on maps, seqs, and sets. Contributors: Alex Baranosky, Laurent Petit, Punit Rathore</p><br></li><li>Steve Miner's <a href="https://github.com/miner/herbert">Herbert</a><p>A schema language for Clojure data for documenting and validating.</p><br></li><li>Metosin <a href="https://github.com/metosin/malli">Malli</a><p>Data-driven schemas incorporating the best parts of existing libs, mixed with their own tools.</p><br></li><li>Plumatic <a href="https://github.com/plumatic/schema">Schema</a><p>A Clojure(Script) library for declarative data description and validation.</p><br></li><li>Christophe Grand's <a href="https://github.com/cgrand/seqexp">seqexp</a><p>Regular expressions for sequences (and other sequables).</p><br></li><li>Jonathan Claggett's <a href="https://github.com/jclaggett/seqex">seqex</a><p>Sequence Expressions, similar to regular expressions but able to describe arbitrary sequences of values (not just characters).</p><br></li><li>Clojure's <a href="https://github.com/clojure/spec.alpha"><code>spec.alpha</code></a><p>[A] Clojure library to describe the structure of data and functions.</p><br></li><li>Clojure's <a href="https://github.com/clojure/spec-alpha2"><code>spec-alpha2</code> or <code>alpha.spec</code></a><p>[A]n evolution from spec.alpha as well as work towards several new features. Note: Alex Miller considers it <a href="https://ask.clojure.org/index.php/9397/clarify-usage-on-the-spec-alpha2-github-page?show=9398#a9398">a work in progress</a> as of 2020 June 20.</p><br></li><li>Jamie Brandon's <a href="https://github.com/jamii/strucjure">Strucjure</a><p>A <a href="https://www.scattered-thoughts.net/writing/strucjure-motivation/">library for describing stuff</a> in an executable manner.</p><br></li><li>Brian Marick's <a href="https://github.com/marick/structural-typing">structural-typing</a><p>A library that provides good error messages when checking the correctness of structures, and a way to define <a href="https://en.wikipedia.org/wiki/Structural_type_system">structural types</a> that are checked at runtime.</p><br></li><li>Peter Taoussanis' <a href="https://github.com/taoensso/truss">Truss</a><p>A tiny library that provides fast and flexible runtime assertions with terrific error messages.</p><br></li></ul></section><section id="glossary"><h2>Glossary</h2><dl><dt id="element">element</dt><dd><p>A thing contained within a collection, either a scalar value or another nested collection.</p></dd><dt id="HANDS">heterogeneous, arbitrarily-nested data structure</dt><dd><p>Exactly one Clojure collection (vector, map, list, sequence, or set) with zero or more <a href="#element">elements</a>, nested to any depth.</p></dd><dt id="non-term-seq">non-terminating sequence</dt><dd><p>One of <code>clojure.lang.{Cycle,Iterate,LazySeq,LongRange,Range,Repeat}</code> that may or may not be realized, and possibly infinite. (I am not aware of any way to determine if such a sequence is infinite, so Speculoos treats them as if they are.)</p></dd><dt id="path">path</dt><dd><p>A series of values that unambiguously navigates to a single <a href="#element">element</a> (scalar or sub-collection) in a <a href="#HANDS">heterogeneous, arbitrarily-nested data structure</a>. In the context of the Speculoos library, the series of values comprising a path is generated by the <code>all-paths</code> function and consumed by the <code>validate-…</code> functions. Almost identical to the second argument of <a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/get-in"><code>clojure.core/get-in</code></a>, but with more generality.</p><p>Elements of vectors, lists, and other sequences are addressed by zero-indexed integers. Map values are addressed by their keys, which are often keywords, but can be any data type, including integers, or composite types. Set members are addressed by their identities. Nested collections contained in a set can indeed be addressed: the path vector itself contains the collections. An empty vector <code>[]</code> addresses the outermost, containing collection.</p></dd><dt id="predicate">predicate</dt><dd><p>A function, or something that implements <code>IFn</code>, like a set, that returns a truthy or falsey value.  In most instances, a predicate is a function of one argument. Some Speculoos functions, such as <code>validate-scalars</code> and <code>valid-scalars?</code> also regard a regular expression as a competent predicate.</p></dd><dt id="relationship">relationship</dt><dd><p>A human- and machine-readable declaration about the congruence between two elements. Specifically, Speculoos function validation may involve specifying a relationship between the function's argument and the function's return value.</p></dd><dt id="scalar">scalar</dt><dd><p>A single, non-divisible datum, such as an integer, string, boolean, etc. Essentially, a shorter term for <em>non-collection</em>.</p></dd><dt id="specification">specification</dt><dd><p>A human- and machine-readable declaration about properties of data, composed of a <a href="#HANDS">heterogeneous, arbitrarily-nested data collection</a> and <a href="#predicate">predicates</a>.</p></dd><dt id="validate">validate</dt><dd><p>An action that returns an exhaustive listing of all datum+predicate pairs, their paths, and whether the datum satisfies the predicate. Note: Validation requires <em>two</em> components, a datum and a predicate. Any unpaired datum or any unpaired predicate, will not participate in validation.</p></dd><dt id="valid">valid?</dt><dd><p>An action that returns <code>true</code> if all paired datums satisfy their predicates during a validation, <code>false</code> otherwise. Note: A validation operation's result is considered <em>valid</em> if there are zero datum+predicates.</p></dd></dl></section><br><h2>License</h2><p>This program and the accompanying materials are made available under the terms of the <a href="https://opensource.org/license/MIT">MIT License</a>.</p><p id="page-footer">Copyright © 2024 Brad Losavio.<br>Compiled 2024 September 21.<span id="uuid"><br>b7613e59-3656-411e-8be6-f3cb8b5d8107</span></p></body></head></html>