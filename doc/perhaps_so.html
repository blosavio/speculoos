<!DOCTYPE html>
<html lang="en"><head><link href="speculoos.css" rel="stylesheet" type="text/css"><title>How Speculoos addresses Rich Hickey's 'Maybe Not' talk</title><meta charset="utf-8" compile-date="2024-10-23 09:58:35" content="width=device-width, initial-scale=1" name="viewport"><body><article><h1>Perhaps So</h1><h3><em>How Speculoos addresses issues raised in '<a href="https://www.youtube.com/watch?v=YR5WdGrpoug">Maybe Not</a>'</em></h3><section><p>Rich Hickey presented <a href="https://2018.clojure-conj.org/rich-hickey/">Maybe Not</a> at the 2018 <em>Clojure conj</em>. If I correctly understand his presentation, he identified some flaws in <code>clojure.spec.alpha</code>, the Clojure distribution's built-in library for specifying and validating data. Mr Hickey highlighted three issues.</p><ol><li><strong>Representing</strong> partial information in an aggregate data structure.</li><li><strong>Specifying</strong> partial information in an aggregate data structure.</li><li><strong>Validating</strong> partial information in an aggregate data structure.</li></ol><p>He was apparently not satisfied with the way <code>spec.alpha</code> handles these three issues.</p><p>The <a href="https://github.com/blosavio/speculoos">Speculoos library</a> is an experiment to see if it is possible to perform the same tasks as <code>spec.alpha</code> using literal specifications. Due to some of the implementation details and policies I chose, the library has some emergent properties that end up neatly handling those three issues.</p><p>Efficiently using Speculoos requires remembering three mottos.</p><ol><li>Validate scalars separately from validating collections.</li><li>Shape the specification to mimic the data.</li><li>Ignore un-paired predicates and un-paired datums.</li></ol><p>If we follow those three mottos, handling partial information is straightforward. Briefly, Speculoos specifies and validates scalars separately from specifying and validating collections. A scalar specification describes the properties of the datums themselves. The presence or absence of a scalar is a completely separate concern and falls under the jurisdiction of specifying and validating the collection. By separating the two concerns, Speculoos seamlessly handles partial information while avoiding the issues that befall <code>spec.alpha</code>.</p><p><em>Related:</em> <code>clojure.spec.alpha</code> <a href="https://blosavio.github.io/speculoos/diff.html">side-by-side comparison</a> to Speculoos.</p><p>Let's examine each issue in more detail.</p></section><section><h3>Representing partial information</h3><p>Representing partial data is not specifically the purview of the Speculoos library, but of Clojure itself. We'll discuss partial information only in order to supply us with examples for later.</p><p>Mr Hickey highlights the fact that idiomatic Clojure merely excludes missing information instead of 'holding a slot' with a <code>nil</code>. Imagine data about a person that could include their first name, last name, and and their age. Here's an example of 'complete' data.</p><pre><code>{:first-name "Albert"
 :last-name "Einstein"
 :age 76}</code></pre><p>The following example of partial data, with <code>nil</code> associated to 'missing' <code>:age</code> information, is atypical.</p><pre><code>{:first-name "Isaac"
 :last-name "Newton"
 :age nil}</code></pre><p>The more idiomatic way to represent partial information about a person involves merely leaving off the person's age.</p><pre><code>{:first-name "Maria"
 :last-name "GÃ¶ppert-Mayer"}</code></pre></section><section><h3>Specifying and validating partial information</h3><p>A Speculoos specification is a plain Clojure data structure containing predicates. The specification's shape mimics the shape of the data (Motto #2). Professor Einstein's data is a map with keys <code>:first-name</code>, <code>:last-name</code>, and <code>:age</code>. The Speculoos specification for that data might look like this.</p><pre><code>{:first-name string?
 :last-name string?
 :age int?}</code></pre><p>The specification is likewise a map with those same keys, i.e., the same 'shape', with predicates <code>string?</code> and <code>int?</code> replacing datums. Speculoos assembles pairs of datums and predicates and reports if the datums satisfy their corresponding predicates and returns <code>true/false</code>.</p><p>All of Speculoos' validating functions have a similar signature. The data is the first argument, the specification is the second argument.</p><pre><code>(valid-scalars? data
                specification)</code></pre><p>I'll be printing the specification directly below the data to visually emphasize how the shape of the specification mimics the shape of the data (Motto #2).</p><p>(Speculoos offers a <a href="https://github.com/blosavio/speculoos?tab=readme-ov-file#valid-thorough">verbose variant</a> if we need to see details of the validation.)</p><h4>Validating complete data</h4><pre><code>(require '[speculoos.core :refer [valid-scalars?]])</code><br><br><br><code>(valid-scalars? {:first-name "Albert", :last-name "Einstein", :age 76}
                {:first-name string?, :last-name string?, :age int?})
;; => true</code></pre><p><code>valid-scalars?</code> systematically walks through both the data and specification, and where it finds a datum paired with a predicate, it validates. </p><ul><li><code>"Albert"</code> at <code>:first-name</code> in the data (upper row) satisfies <code>string?</code> at <code>:first-name</code> in the specification (lower row), </li><li><code>"Einstein"</code> at <code>:last-name</code> in the data satisfies <code>string?</code> at <code>:last-name</code> in the specification, and</li><li><code>76</code> at <code>:age</code> in the data satisfies <code>int?</code> at <code>:age</code> in the specification.</li></ul><p>Three datums paired with three predicates. All predicates were satisfied. So <code>valid-scalars?</code> returned <code>true</code>.</p><h4>Validating partial data</h4><p>Let's see what happens if we remove Professor Einstein's age from the data but leave the corresponding predicate in the specification.</p><pre><code>(valid-scalars? {:first-name "Albert", :last-name "Einstein"}
                {:first-name string?, :last-name string?, :age int?})
;; => true</code></pre><p>That result may be surprising. Why doesn't the missing age datum cause a <code>false</code> result? We need to consider Motto #3: Un-paired predicates are ignored. <code>valid-scalars?</code> was able to find two datum+predicate pairs.</p><ul><li><code>"Albert"</code> at <code>:first-name</code> in the data satisfies predicate <code>string?</code> at <code>first-name</code> in the specification.</li><li><code>"Einstein"</code> at <code>:last-name</code> in the data satisfies predicate <code>string?</code> at <code>:last-name</code> in the specification.</li><li>Predicate <code>int?</code> at <code>:age</code> in the specification was not paired with an element in the data and was therefore ignored, as Motto #3 informs us.</li></ul><p>That may seem kinda broken, but it opens up some powerful capabilities we're about to explore. Later, we'll see how to verify that the age datum actually exists in the data.</p><h4>Validating complete data, partial specification</h4><p>What about the other way around? What if our data contains a key-value that does not appear in the specification? Let's add an email entry.</p><pre><code>(valid-scalars?
  {:first-name "Albert", :last-name "Einstein", :email "al@princeton.edu"}
  {:first-name string?, :last-name string?})
;; => true</code></pre><p>Again, <code>valid-scalars?</code> found two datum+predicate pairs. Both first-name and last-name datums satisfied their corresponding predicates, so the validation returned <code>true</code>. The email datum did not have a corresponding predicate, so, according to Motto #3, it was ignored.</p><p>The general idea behind Motto #3 is <em>This element may or may not exist, but if it does exist, it must satisfy this predicate.</em> Taken to its logical conclusion, <code>valid?</code>, within the Speculoos library, conveys the notion <em>Zero invalid results</em>.</p><h4>Validating complete data, empty specification</h4><p>We might imagine a scenario where we absolutely do not care about any facet of our data. In that case, our specification would contain exactly zero predicates.</p><pre><code>(valid-scalars?
  {:first-name "Albert", :last-name "Einstein", :age 76}
  {})
;; => true</code></pre><p><code>valid-scalars?</code> found zero pairs of datums and predicates. Since there were zero invalids, <code>valid-scalars?</code> returns <code>true</code>.</p><h4>Validating empty data</h4><p>Perhaps we've been building up a comprehensive specification for a person's data that includes predicates for a whole slew of possible datums. We need to be able to handle partial data. In other words, not every instance of data we encounter will be complete. The edge case would be zero datums.</p><pre><code>(valid-scalars? {}
                {:first-name string?,
                 :last-name string?,
                 :age int?,
                 :address {:street-name string?,
                           :street-number int?,
                           :zip-code int?,
                           :city string?,
                           :state keyword?},
                 :email #"\w@\w"})
;; => true</code></pre><p>Not a single one of those predicates was paired with a datum, so there were zero invalid results. Thus, <code>valid-scalars?</code> returns <code>true</code>.</p><h4>Validating complete data, one invalid datum</h4><p>In every example we've seen so far, all the datums satisfy the predicate they were paired with. Here's what happens if at least one datum does not satisfy its predicate.</p><pre><code>(valid-scalars?
  {:first-name "Albert", :last-name "Einstein", :age "not an integer!"}
  {:first-name string?, :last-name string?, :age int?})
;; => false</code></pre><p>String datum <code>"not an integer!"</code> failed to satisfy the <code>int?</code> predicate located at <code>:age</code> in the specification. Therefore, <code>valid-scalars?</code> returned <code>false</code>. Speculoos provides <a href="https://github.com/blosavio/speculoos?tab=readme-ov-file#function-naming-conventions">other functions</a> that give more detail about invalid elements, but for simplicity, we'll stick with the <code>true/false</code> results.</p><h3>Validating presence of a datum</h3><p>If we wanted to ensure that the data contains a particular key-value, we need to validate the collection itself (Motto #1). Presence of absence of a datum is a property of the collection. First, we'll write a <code>has-age?</code> collection predicate that tests whether the map contains an <code>:age</code> key.</p><pre><code>(defn has-age? [m] (contains? m :age))</code></pre><p>Then, we insert <code>has-age?</code> into the collection specification. Collection validation operates a <a href="https://github.com/blosavio/speculoos?tab=readme-ov-file#collection-validation">little differently</a> from scalar validation, but take my word that this is how to assemble the collection specification for this situation.</p><pre><code>{:foo has-age?}</code></pre><p>Given this collection specification, <code>has-age?</code> will be paired with the root collection of the data.</p><p>Finally, we invoke a completely different function, <code>validate-collections</code>, to validate (Motto #1).</p><pre><code>(require '[speculoos.core :refer [valid-collections?]])</code><br><br><br><code>(valid-collections? {:first-name "Albert", :last-name "Einstein"}
                    {:foo has-age?})
;; => false</code></pre><p><code>valid-collections?</code> informs us that the map fails to satisfy the <code>has-age?</code> collection predicate. It fails because the map does not contain <code>:age</code> as the collection specification requires.</p><p>We'll often want to validate some aspects of both the scalars and the collections, so Speculoos provides a combo function that does a scalar validation, immediately followed by a collection validation, and returns the overall result. The data is the first argument (upper row), the scalar specification is the second argument (middle row), and the collection specification is the third argument (lower row). </p><pre><code>(require '[speculoos.core :refer [valid?]])</code><br><br><br><code>(valid? {:first-name "Albert", :last-name "Einstein"}
        {:first-name string?, :last-name string?, :age int?}
        {:foo has-age?})
;; => false</code></pre><p>The <code>string?</code> scalar predicates at <code>:first-name</code> and <code>:last-name</code> were both satisfied. Scalar predicate <code>int?</code> at <code>:age</code> was ignored because it was un-paired. However, collection predicate <code>has-age?</code> at <code>:foo</code> was not satisfied, so <code>valid?</code> returns <code>false</code>.</p><p>Specifying and validating scalar datums separately from specifying and validating collections completely isolates two concerns. The scalar predicates are entirely devoted to testing the properties of the scalars themselves. The collection predicates are devoted to properties of the collections, including the size of the collections, the presence/absence of elements, and relationships <em>between</em> elements. Using both, Speculoos can validate any facet of a heterogeneous, arbitrarily-nested data structure.</p></section><section><h3>When?!</h3><p>A portion of <em>Maybe Not</em> discusses <code>spec.alpha</code>'s issues with optionality. Mr Hickey contends it is a mistake to put optionality into aggregate specifications because doing so destroys a specification's re-usability. An entity that is optional in one context might not be optional in another context.</p><p>Speculoos does not suffer from this problem. Because of Motto #3, any predicate that is not paired with a datum is ignored. Any datum that is not paired with predicate is also ignored. Only when a datum is paired with a predicate is the pair considered in the validation result. Separately, if a particular context requires the presence of a datum, we can validate that with a collection validation.</p><p>Mr Hickey points out that validating arguments and return values of a function provide a built-in context: the context of the function itself. Speculoos validations themselves carry an inherent context: The context is the validation function combined with the specification, at the moment of invocation, such as we've seen with <code>valid-scalars?</code>.</p><p id="flexible">In addition to being straightforward to compose, Speculoos specifications are extremely flexible because they are plain Clojure data structures. Speculoos specifications can be manipulated using any Clojure tools, including the entire core library or any third-party library. Quite a lot of this flexibility can be demonstrated with merely <code>get</code>, <code>assoc</code>, <code>update</code>, and <code>dissoc</code>.</p><p>Let's pretend that a specification someone handed us requires the age datum to be an integer. If Professor Einstein's age is instead a floating-point double, the validation would fail.</p><pre><code>(valid-scalars? {:first-name "Albert", :last-name "Einstein", :age 76.0}
                {:first-name string?, :last-name string?, :age int?})
;; => false</code></pre><p><code>76.0</code> is not an integer.</p><p>We can easily relax our specification to accept that the age be any kind of number.</p><pre><code>(assoc {:first-name string?, :last-name string?, :age int?} :age number?)
;; => {:age number?, :first-name string?, :last-name string?}</code></pre><p>With that relaxed specification in hand, that data is now valid.</p><pre><code>(valid-scalars? {:first-name "Albert", :last-name "Einstein", :age 76.0}
                (assoc {:first-name string?, :last-name string?, :age int?} :age number?))
;; => true</code></pre><p><code>76.0</code> satisfies scalar predicate <code>number?</code> which we <code>assoc</code>-ed into the specification on-the-fly.</p><p>The original specification is immutable, as it always was. During the validation, we associated a more permissive scalar predicate so that, in this context (while invoking <code>valid-scalars?</code>, with that particular specification), the data is valid.</p><p>Now, let's pretend someone handed us a collection specification that requires the presence of the age key-value, but in our little part of the world, our data doesn't have it, and our little machine doesn't need it. Without intervention, collection validation will fail.</p><pre><code>(valid-collections? {:first-name "Albert", :last-name "Einstein"}
                    {:foo has-age?})
;; => false</code></pre><p>The data (upper row) does not contain a key <code>:age</code> so the data is invalid, according to the specification (lower row) we were handed.</p><p>But, our little data processing machine doesn't need Professor Einstein's age, so we can straightforwardly remove that requirement in our context. Here's the altered collection specification.</p><pre><code>(dissoc {:foo has-age?} :foo) ;; => {}</code></pre><p>If we now use that altered collection specification in the context of our little machine, the data is valid.</p><pre><code>(valid-collections? {:first-name "Albert", :last-name "Einstein"}
                    (dissoc {:foo has-age?} :foo))
;; => true</code></pre><p>The collection specification no longer contains the <code>has-age?</code> predicate, so the data is declared valid in our context.</p><p>Specifications made of plain Clojure data structures absorb every drop of generality, composability, and re-usability of the underlying data structures. They may be passed over the wire, stored in the file system, version controlled, annotated with metadata, and manipulated at will to suit any context.</p></section><section><h3>Replicating specific scenarios from <em>Maybe Not</em></h3><p>In this section, we'll explore how Speculoos handles the specific, problematic scenarios presented by Mr Hickey.</p><h4>Predicates use proper <code>or</code></h4><p>Speculoos predicates are plain old Clojure functions. When we need to validate an element that may be one of multiple types, the predicates use <code>clojure.core/or</code>, which will inherit all the proper semantics.</p><p>Commutative:</p><pre><code>(#(or (int? %) (string? %)) 42) ;; => true</code><br><code>(#(or (string? %) (int? %)) 42) ;; => true</code></pre><p>Associative:</p><pre><code>(#(or (int? %) (or (string? %) (char? %))) 42) ;; => true</code><br><code>(#(or (or (int? %) (string? %)) (char? %)) 42) ;; => true</code></pre><p>Distributive:</p><pre><code>(#(or (and (int? %) (even? %)) (string? %)) 42) ;; => true</code></pre><p>Etc.</p><h4><code>nil</code>-able</h4><p>This one's easy: just write Speculoos predicates without <code>nilable</code>.</p><h4>Namespaced specifications</h4><p>One of <code>spec.alpha</code>'s propositions is that specs are <a href="https://clojure.org/about/spec#_global_namespaced_names_are_more_important">required to be namespace-qualified</a>. Speculoos takes a hands-off approach. Speculoos specifications are plain Clojure data structures that are referenced however we want. Specifications may be a literal, like <code>[int? string? ratio?]</code>.</p><pre><code>(valid-scalars? [42 "abc" 22/7]
                [int? string? ratio?])
;; => true</code></pre><p>Or, we may bind them to a symbol in our current namespace.</p><pre><code>(def specification-1 [int? string? ratio?])</code><br><br><br><code>(valid-scalars? [42 "abc" 22/7]
                specification-1) ;; => true</code></pre><p>(We could also bind them to a symbol in a different namespace; not shown.)</p><p>Or, we may gather them into our own bespoke registry.</p><div class="no-display">#'perhaps-so/speculoos-registry</div><pre><code>(defonce speculoos-registry (atom {:speculoos/specification-2 [int? string? ratio?]
                                   :speculoos/specification-3 {:first-name string?
                                                               :last-name string?
                                                               :age int?}}))</code><br><br><br><code>(valid-scalars? [42 "abc" 22/7]
                (@speculoos-registry :speculoos/specification-2))
;; => true</code></pre><h4>Cars schema</h4><p>To follow along precisely, we could split out the <em>make</em>, <em>model</em>, and <em>year</em> concepts into their own named predicate functions, but for brevity, I'll stuff them directly into our <code>car</code> scalar specification.</p><pre><code>(def car-scalar-specification
  {:make string?, :model string?, :year #(and (int? %) (>= % 1885))})</code></pre><p>At this point, we're not stating anything definitive about presence or absence of an element. A scalar specification says, for each scalar predicate, <em>This element may or may not exist, but if it does, the element must satisfy this predicate</em>. Declaring that <code>:make</code> is a string is completely separate from declaring that our car data must contain a <code>:make</code> value.</p><p>If we want to require that our car data contains a <code>:make</code> entry, we declare that requirement in a collection specification.</p><pre><code>(def car-collection-specification {:foo #(contains? % :make)})</code></pre><p>Unless explicitly required in a collection specification, Speculoos treats all scalars as optional. So we don't have to say anything about <code>:model</code> or <code>:year</code>.</p><p>Let's validate with all the specified values.</p><pre><code>(valid? {:make "Acme Motor Cars", :model "Type 1", :year 1905}
        car-scalar-specification
        car-collection-specification)
;; => true</code></pre><p>The values we supplied for <code>:make</code>, <code>:model</code>, and <code>year</code> all satisfied their respective scalar predicates. Furthermore, the <cde>car</cde> map itself satisfied the collection specification's requirement that the map contain a key <code>:make</code>.</p><p>Now, let's validate some car data with partial information: <code>:model</code> and <code>:year</code> values are missing.</p><pre><code>(valid? {:make "Acme Motor Cars"}
        car-scalar-specification
        car-collection-specification)
;; => true</code></pre><p><code>{:make "Acme Motor Cars"}</code> is valid car data because <code>:make</code> satisfies its scalar predicate and the map itself contains the only key we required in the collection specification. <code>:model</code> and <code>:year</code> are implicitly optional because we did not require their existence in the collection specification.</p><p>What if we have extra information? Let's validate data about an early 1900s car with a completely anachronistic computer chip.</p><pre><code>(valid? {:make "Acme Motor Cars", :year 1905, :cpu "Intel Pentium"}
        car-scalar-specification
        car-collection-specification)
;; => true</code></pre><p>Again, this car data is valid, because we did not specify any property relating to <code>:cpu</code>, so the validation ignored that datum. All the other existing datums satisfied their corresponding predicates.</p><p>What if we neglect to include the <code>:make</code> element?</p><pre><code>(valid? {:model "Type 1", :year 1905}
        car-scalar-specification
        car-collection-specification)
;; => false</code></pre><p>Finally, we run afoul of our collection specification: Our car data lacks a <code>:make</code> element, which our collection specification explicitly requires.</p><p>What if we're in a different context, and suddenly we absolutely must have a <code>:year</code> element, too? Right then and there, we can augment the collection specification, because it's a plain Clojure data structure. And we know how to associate items on-the-fly into a map.</p><pre><code>(assoc car-collection-specification :bar #(contains? % :year))
;; => {:foo #(contains? % :make), :bar #(contains? % :year)}</code></pre><p>So in this new context, we use that new collection specification with tighter requirements.</p><pre><code>(valid? {:make "Acme Motor Cars", :model "Type 1"}
        car-scalar-specification
        (assoc car-collection-specification :bar #(contains? % :year)))
;; => false</code></pre><p>Now, the absence of <code>:year</code> element of our car data is no longer ignored. This car data fails to satisfy one of its collection predicates that require the presence of a <code>:year</code> entry.</p><p>Note that specifying the values of the scalars themselves (in a Speculoos scalar specification), is completely orthogonal to requiring their presence (which we declare in a Speculoos collection specification). By splitting the two concerns, the specifications become straightforwardly re-usable. We are free to specify any number of properties of the car data that may or may not exist. Then, in a particular context, we adjust our collection specification to require the particular group of elements that we need for that particular context.</p><p>Speculoos specifications shouldn't proliferate uncontrollably because, as plain Clojure data structures, they're readily manipulable, on-the-fly, with <code>assoc</code> and friends.</p><h4>Symmetric request/response schemas</h4><p><em>Give me a partially filled-in form, and I will give you back a more filled-in form</em>. No problem for Speculoos to validate that scenario with a single scalar specification. Because un-paired predicates are ignored, we can simply use the same scalar specification to validate both the <em>before</em> data and the <em>after</em> data.</p><p>Let's pretend we query a service with an ID, and the service returns that ID and the associated name and phone number. That would be a straightforward scalar specification.</p><pre><code>(def one-spec {:ID int?, :name string?, :phone int?})</code></pre><p>Before we submit our request to the service, let's validate the partially filled-in form.</p><pre><code>(valid-scalars? {:ID 99} one-spec) ;; => true</code></pre><p><code>valid-scalars?</code> only considers pairs of datum+predicates. Our partially filled-in request only has one datum that is paired with a predicate: <code>99</code> at <code>:ID</code> is paired with <code>int?</code> at <code>:ID</code> in the scalar specification. <code>99</code> satisfies its paired scalar predicate <code>int?</code>, so <code>valid-scalars?</code> returns <code>true</code>.</p><p>Now that we've validated our request, we send it off to the service, which returns <code>{:ID 99 :name "Sherlock Holmes" :phone 123456789}</code>. We can validate the response with the exact same scalar specification.</p><pre><code>(valid-scalars? {:ID 99, :name "Sherlock Holmes", :phone 12345678} one-spec)
;; => true</code></pre><p>During this invocation, <code>valid-scalars?</code> encountered three datum+predicate pairs, and each datum satisfied its corresponding scalar predicate, so the validation returns <code>true</code>.</p><p>What if we submit a query that causes the service to emit garbage data like <code>{:ID 0 :name \z :phone \q}</code>? Let's validate that.</p><pre><code>(valid-scalars? {:ID 99, :name \z, :phone \q} one-spec) ;; => false</code></pre><p>Same scalar specification, but since the datums do not satisfy their scalar predicates, the service's response does not satisfy the specification.</p><p>One specification is sufficient to validate the data at each step. The specification is re-used, and there's one authoritative description of what an <em>ID/name/phone</em> aggregate looks like.</p><h4>Information-building pipelines</h4><p>An information-building pipeline is merely repeated application of the principles embodied in the  <em>request/response</em> pattern we discussed earlier. A singular scalar specification can describe all the steps of a serially aggregating data structure.</p><p>Let's pretend our cupcake processing pipeline accepts an accumulating map, and adds a new quantity based on an ingredient we pass alongside. It might look something like this.</p><ol><li>empty bowl</li><li><strong>flour</strong> â 150 grams</li><li><strong>eggs</strong> â 2</li><li><strong>sugar</strong> â 130 grams</li><li><strong>butter</strong> â 60 grams</li><li><strong>milk</strong> â 1/8 liter</li></ol><p>Our pipeline constructs the accumulating map in six steps like this.</p><ol><li><code>{}</code></li><li><code>{:flour 150.0}</code></li><li><code>{:flour 150.0 :eggs 2}</code></li><li><code>{:flour 150.0 :eggs 2 :sugar 130.0}</code></li><li><code>{:flour 150.0 :eggs 2 :sugar 130.0 :butter 60.0}</code></li><li><code>{:flour 150.0 :eggs 2 :sugar 130.0 :butter 60.0 :milk 1/8}</code></li></ol><p>We can write one single scalar specification that will validate the result of each of those six steps.</p><pre><code>(def cupcake-spec
  {:flour double?, :eggs int?, :sugar double?, :butter double?, :milk ratio?})</code></pre><p>Now, we can validate the data at each step.</p><pre><code>(valid-scalars? {}
                cupcake-spec) ;; => true</code><br><br><code>(valid-scalars? {:flour 150.0}
                cupcake-spec) ;; => true</code><br><br><code>(valid-scalars? {:flour 150.0, :eggs 2}
                cupcake-spec) ;; => true</code><br><br><code>(valid-scalars? {:flour 150.0, :eggs 2, :sugar 130.0}
                cupcake-spec)
;; => true</code><br><br><code>(valid-scalars? {:flour 150.0, :eggs 2, :sugar 130.0, :butter 60.0}
                cupcake-spec)
;; => true</code><br><br><code>(valid-scalars? {:flour 150.0, :eggs 2, :sugar 130.0, :butter 60.0, :milk 1/8}
                cupcake-spec)
;; => true</code></pre><p>Notice: <code>cupcake-spec</code> remained the same for each of the six validations as the pipeline added more and more elements. Speculoos' policy of ignoring un-paired predicates offers us the ability to specify the final shape at the outset, and the validation only considers the elements present at the moment of invocation.</p><h4>Nested schemas</h4><p>Speculoos was designed from the outset to validate any heterogeneous, arbitrarily-nested data structure. Mr Hickey imagines a data structure something like this.</p><pre><code>{:a 42
 :b "abc"
 :c [\x \y \z]
 :d ['foo 'bar 'baz]}</code></pre><p>We can immediately compose a specification for that data. One trick is to take advantage of the fact that Speculoos specifications mimic the shape of the data (Motto #2). So first, we copy-paste the data, and delete the scalars.</p><pre><code>{:a    :b     :c [       ] :d [        ]}</code></pre><p>Then, we insert our predicates, one predicate for each scalar.</p><pre><code>{:a int? :b string? :c [char? char? char?] :d [symbol? symbol? symbol?]}</code></pre><p>Finally, we validate.</p><pre><code>(valid-scalars?
  {:a 42, :b "abc", :c [\x \y \z], :d ['foo 'bar 'baz]}
  {:a int?, :b string?, :c [char? char? char?], :d [symbol? symbol? symbol?]})
;; => true</code></pre><p><code>valid-scalars?</code> systematically marches through the data and specification, searching for pairs of scalars and predicates. In this case, it finds pairs at keys <code>:a</code> and <code>:b</code>, and dives down into the nested vectors at keys <code>:c</code> and <code>:d</code>. So scalar <code>\x</code> is paired with predicate <code>char?</code>, scalar <code>'foo</code> is paired with predicate <code>symbol?</code>, etc. All the scalars satisfy their corresponding predicates, so the validation returns <code>true</code>.</p><p>We could also compose an equivalent scalar specification from pre-defined subcomponents. Consider this.</p><pre><code>(def three-chars? [char? char? char?])</code><br><code>(def three-syms? [symbol? symbol? symbol?])</code><br><br><br><code>(valid-scalars? {:a 42, :b "abc", :c [\x \y \z], :d ['foo 'bar 'baz]}
                {:a int?, :b string?, :c three-chars?, :d three-syms?})
;; => true</code></pre><p>Regular old Clojure composition in action. The scalar specification refers to <code>three-chars?</code> at its key <code>:c</code> and refers to <code>three-syms?</code> at its key <code>:d</code>. We can thus mix and match with impunity to compose our specifications.</p><p>A riff on that tune is to extract some selection of our data and validate it against a smaller specification. Pretend we only care about validating the three-element vector at <code>:c</code>. We've got tools that can pull that vector out.</p><pre><code>(get {:a 42, :b "abc", :c [\x \y \z], :d ['foo 'bar 'baz]} :c) ;; => [\x \y \z]</code></pre><p>And we've already written a specification for that extracted vector, <code>three-chars?</code>, so we can immediately validate.</p><pre><code>(valid-scalars? (get {:a 42, :b "abc", :c [\x \y \z], :d ['foo 'bar 'baz]} :c)
                three-chars?)
;; => true</code></pre><p>This invocation used <code>get</code> to extract the vector at <code>:c</code> and validated it against predicate <code>three-chars?</code>.</p><p>Alternatively, we could leverage the fact that un-paired datums are ignored, and specify only that nested vector.</p><pre><code>(valid-scalars? {:a 42, :b "abc", :c [\x \y \z], :d ['foo 'bar 'baz]}
                {:c three-chars?})
;; => true</code></pre><p>We performed a validation on only a selected slice of data because <code>valid-scalars?</code> applied only the three <code>char?</code> scalar predicates to the contents of the nested vector at <code>:c</code>.</p><h4>Movie times & placing orders</h4><p>Mr Hickey's next example extends the discussion of validating Professor Einstein's data from earlier. First, we'll write some bottom-level specifications.</p><pre><code>(def street string?)</code><br><code>(def city string?)</code><br><code>(def state keyword?)</code><br><code>(def zip int?)</code></pre><p>Then, we aggregate them into a specification for an address.</p><pre><code>(def address {:street street, :city city, :state state, :zip zip})</code></pre><p>Next, we write some more bottom-level specifications.</p><pre><code>(def id int?)</code><br><code>(def first-name string?)</code><br><code>(def last-name string?)</code></pre><p>Finally, we aggregate those specifications into a user specification, including the <code>address</code> aggregate from before.</p><pre><code>(def user
  {:id id, :first-name first-name, :last-name last-name, :address address})</code></pre><p>Speculoos provides several utilities for <a href="https://github.com/blosavio/speculoos?tab=readme-ov-file#function-validation">validating function arguments and return values</a>, but to avoid introducing a new utility, we'll stick with <code>valid-scalars?</code> and I'll ask that you trust me that the function validation operates substantially the same way.</p><p>If we imagine that a function <code>get-movie-times</code> expects an ID and a zip, we could validate that slice of data.</p><pre><code>(valid-scalars?
  {:id 101, :address {:zip 90210}}
  {:id id, :first-name first-name, :last-name last-name, :address address})
;; => true</code></pre><p>In the context of a different function, <code>place-order</code>, we might want to validate a first name, last name, and the full address. Validating that slice of data would look like this.</p><pre><code>(valid-scalars? {:first-name "Helen",
                 :last-name "tis TroÃ­as",
                 :address {:street "Equine Avenue",
                           :city "Sparta",
                           :state :LCNIA,
                           :zip 54321}}
                {:id id,
                 :first-name first-name,
                 :last-name last-name,
                 :address address})
;; => true</code></pre><p>Exact same specification, <code>user</code>, in both cases, but this time, a different slice of data was compared to specification. Because Speculoos only validates using predicates that are paired with scalars, the extra, un-paired predicates (in this example, <code>:id</code>) in scalar specification <code>user</code> have no effect.</p><p>Also note that the data is a heterogeneous, nested data structure (Mr Hickey calls it a 'tree'), and because Speculoos specifications mimic the shape of the data, the <code>user</code> scalar specification is also a tree. Speculoos can handle any depth of nesting, with any of Clojure's data structures (vectors, lists, sequences, maps, and sets).</p><h4>No requirements</h4><p>Speculoos will happily validate data with an empty specification.</p><pre><code>(valid-scalars? {:sheep #{"Fred" "Ethel"}, :helicopters 1}
                {})
;; => true</code></pre><p>Validating with an empty specification will always return <code>true</code>. That behavior is governed by ignoring un-paired scalars (i.e., there are no predicates to pair with), and zero un-satisfied predicates is considered <em>valid</em>. Speculoos is 'open' in the sense that Mr Hickey discusses: Extra information is okay. Speculoos merely ignores it if it isn't paired with a predicate.</p><p>Speculoos can generate valid test data if we supply it with a scalar specification.</p><pre><code>(require '[speculoos.utility :refer [exercise]])</code><br><br><br><code>(exercise {:sheep #{"Fred" "Ethel" "Lucy" "Ricky" "Little Ricky"},
           :helicopters pos-int?}
          5)
;; => ([{:helicopters 31, :sheep "Ricky"} true]
;;     [{:helicopters 16, :sheep "Ethel"} true]
;;     [{:helicopters 15, :sheep "Ethel"} true]
;;     [{:helicopters 6, :sheep "Fred"} true]
;;     [{:helicopters 19, :sheep "Fred"} true])</code></pre><h4>Programmatically manipulating specifications</h4><p>We <a href="#flexible">discussed</a> this earlier. Speculoos specifications are plain Clojure data structures containing plain predicate functions. Slice and dice them however we want.</p><p>Extract a slice of a specification, perhaps just the address.</p><pre><code>(get {:id int?,
      :first-name string?,
      :last-name string?,
      :address {:street string?,
                :city string?,
                :zip int?,
                :state keyword?}}
     :address)
;; => {:city string?,
;;     :state keyword?,
;;     :street string?,
;;     :zip int?}</code></pre><p>Alter a portion of a specification, perhaps by tightening the requirements of the ID.</p><pre><code>(assoc {:id int?,
        :first-name string?,
        :last-name string?,
        :address {:street string?,
                  :city string?,
                  :zip int?,
                  :state keyword?}}
  :id even?)
;; => {:address {:city string?,
;;               :state keyword?,
;;               :street string?,
;;               :zip int?},
;;     :first-name string?,
;;     :id even?,
;;     :last-name string?}</code></pre><p>We could, on-the-fly, require <code>:id</code> to be a positive integer by invoking <code>valid-scalars?</code> with that <code>assoc</code>-ed specification. The original specification is immutable as always, and remains unchanged. But at that moment of validation, the requirements were tightened.</p><p>No need to write a macro. Just manipulate Clojure data with our favorite utilities.</p><h4>Function validation</h4><p>Speculoos has an <a href="https://blosavio.github.io/speculoos/speculoos.function-specs.html">entire namespace</a> dedicated to validating function arguments and return values. Function validation follows all the same principles we've been discussing about validating data. It's a lengthy topic, so I'll refer to the <a href="https://github.com/blosavio/speculoos?tab=readme-ov-file#function-validation">documentation on the subject</a>.</p><h4>Nail down everything!</h4><p>I hope at this point I've made a convincing case that Speculoos is open and permissive: Only specify what we're interested in, and Speculoos will ignore the rest. There is no requirement that we describe every possible facet of our data. Whatever small amount we <em>do</em> specify, can be used to validate our data, and generate test samples, etc.</p></section><section><h3>Final thoughts</h3><p>It's fortunate that Speculoos' implementation details combined with a few policy decisions resulted in being able to address most all of <em>Maybe Not</em>'s concerns. I don't claim that Speculoos is the only solution to these issues, but that the principles under which Speculoos operates provides one possible solution.</p><p><a href="https://github.com/blosavio">Let me know</a> what you think.</p></section></article><p id="page-footer">Copyright Â© 2024 Brad Losavio.<br>Compiled 2024 October 23.<span id="uuid"><br>f7794d40-96ff-4c8c-95cf-6b5cf0648e6f</span></p></body></head></html>